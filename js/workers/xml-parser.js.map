{"version":3,"sources":["workers/node_modules/browserify/node_modules/browser-pack/_prelude.js","client/js/workers/xml-parser.js","workers/xml-parser.js","workers/node_modules/browserify/node_modules/buffer/index.js","workers/node_modules/browserify/node_modules/buffer/node_modules/base64-js/lib/b64.js","workers/node_modules/browserify/node_modules/buffer/node_modules/ieee754/index.js","workers/node_modules/browserify/node_modules/buffer/node_modules/isarray/index.js","workers/node_modules/browserify/node_modules/events/events.js","workers/node_modules/browserify/node_modules/https-browserify/index.js","workers/node_modules/browserify/node_modules/inherits/inherits_browser.js","workers/node_modules/browserify/node_modules/insert-module-globals/node_modules/is-buffer/index.js","workers/node_modules/browserify/node_modules/isarray/index.js","workers/node_modules/browserify/node_modules/process/browser.js","workers/node_modules/browserify/node_modules/punycode/punycode.js","workers/node_modules/browserify/node_modules/querystring-es3/decode.js","workers/node_modules/browserify/node_modules/querystring-es3/encode.js","workers/node_modules/browserify/node_modules/querystring-es3/index.js","workers/node_modules/browserify/node_modules/readable-stream/duplex.js","workers/node_modules/browserify/node_modules/readable-stream/lib/_stream_duplex.js","workers/node_modules/browserify/node_modules/readable-stream/lib/_stream_passthrough.js","workers/node_modules/browserify/node_modules/readable-stream/lib/_stream_readable.js","workers/node_modules/browserify/node_modules/readable-stream/lib/_stream_transform.js","workers/node_modules/browserify/node_modules/readable-stream/lib/_stream_writable.js","workers/node_modules/browserify/node_modules/readable-stream/node_modules/core-util-is/lib/util.js","workers/node_modules/browserify/node_modules/readable-stream/node_modules/process-nextick-args/index.js","workers/node_modules/browserify/node_modules/readable-stream/node_modules/util-deprecate/browser.js","workers/node_modules/browserify/node_modules/readable-stream/passthrough.js","workers/node_modules/browserify/node_modules/readable-stream/readable.js","workers/node_modules/browserify/node_modules/readable-stream/transform.js","workers/node_modules/browserify/node_modules/readable-stream/writable.js","workers/node_modules/browserify/node_modules/stream-browserify/index.js","workers/node_modules/browserify/node_modules/stream-http/index.js","workers/node_modules/browserify/node_modules/stream-http/lib/capability.js","workers/node_modules/browserify/node_modules/stream-http/lib/request.js","workers/node_modules/browserify/node_modules/stream-http/lib/response.js","workers/node_modules/browserify/node_modules/stream-http/node_modules/builtin-status-codes/browser.js","workers/node_modules/browserify/node_modules/string_decoder/index.js","workers/node_modules/browserify/node_modules/url/url.js","workers/node_modules/browserify/node_modules/url/util.js","workers/node_modules/browserify/node_modules/xtend/immutable.js","workers/node_modules/escape-html/index.js","workers/node_modules/sax/lib/sax.js"],"names":["e","t","n","r","s","o","u","a","require","i","f","Error","code","l","exports","call","length",1,"module","peek","stack","createElement","name","xmlTag","attrs","children","xml","setAttr","xmlKey","xmlAttrs","htmlKey","htmlAttrs","escapeHtml","getHtmlAttributes","node","class","nas","attributes","match","key","hasOwnProperty","simpleNodeHtml","htmlTag","setAnchor","xmlNode","htmlNode","parse","inStream","currentElHasIgnoredParent","elementStack","undefined","shouldIgnore","ignoredElements","xmlNodeToHtmlNode","nm","tagName","htmlMappings","htmlNod","rootNode","saxStream","sax","createStream","strict","options","on","console","error","this","_parser","resume","str","parentChildren","_WHITESPACE","push","ignore","nodeName","element","pop","postMessage","pipe","https","jcis","jci","alias-titels","meta-data","metadata","al","lijst","nadruk","intitule","titel","title","tussenkop","label","nr","lidnr","artikel","dagtekening","plaats","datum","functie","redactie","naam","voornaam","achternaam","organisatie","sup","sub","intref","extref","illustratie","table","colspec","thead","tfoot","entrytbl","tbody","li","kop","row","onmessage","data","url","get","log","escape-html",2,3,"global","typedArraySupport","Bar","arr","Uint8Array","foo","constructor","subarray","byteLength","kMaxLength","Buffer","TYPED_ARRAY_SUPPORT","arg","parent","fromNumber","fromString","arguments","fromObject","that","allocate","checked","string","encoding","write","object","isBuffer","fromBuffer","isArray","fromArray","TypeError","ArrayBuffer","buffer","fromTypedArray","fromArrayBuffer","fromArrayLike","fromJsonObject","copy","array","_augment","type","__proto__","prototype","_isBuffer","fromPool","poolSize","rootParent","RangeError","toString","SlowBuffer","subject","buf","len","loweredCase","utf8ToBytes","base64ToBytes","toLowerCase","slowToString","start","end","Infinity","hexSlice","utf8Slice","asciiSlice","binarySlice","base64Slice","utf16leSlice","hexWrite","offset","Number","remaining","strLen","parsed","parseInt","substr","isNaN","utf8Write","blitBuffer","asciiWrite","asciiToBytes","binaryWrite","base64Write","ucs2Write","utf16leToBytes","base64","fromByteArray","slice","Math","min","res","firstByte","codePoint","bytesPerSequence","secondByte","thirdByte","fourthByte","tempCodePoint","decodeCodePointsArray","codePoints","MAX_ARGUMENTS_LENGTH","String","fromCharCode","apply","ret","out","toHex","bytes","checkOffset","ext","checkInt","value","max","objectWriteUInt16","littleEndian","j","objectWriteUInt32","checkIEEE754","writeFloat","noAssert","ieee754","writeDouble","base64clean","stringtrim","replace","INVALID_BASE64_RE","trim","units","leadSurrogate","charCodeAt","byteArray","c","hi","lo","toByteArray","src","dst","INSPECT_MAX_BYTES","b","compare","x","y","isEncoding","concat","list","pos","item","equals","inspect","join","indexOf","val","byteOffset","arrayIndexOf","foundIndex","readUInt8","set","v","writeUInt8","isFinite","swap","toJSON","Array","_arr","newBuf","sliceLen","readUIntLE","mul","readUIntBE","readUInt16LE","readUInt16BE","readUInt32LE","readUInt32BE","readIntLE","pow","readIntBE","readInt8","readInt16LE","readInt16BE","readInt32LE","readInt32BE","readFloatLE","read","readFloatBE","readDoubleLE","readDoubleBE","writeUIntLE","writeUIntBE","floor","writeUInt16LE","writeUInt16BE","writeUInt32LE","writeUInt32BE","writeIntLE","limit","writeIntBE","writeInt8","writeInt16LE","writeInt16BE","writeInt32LE","writeInt32BE","writeFloatLE","writeFloatBE","writeDoubleLE","writeDoubleBE","target","targetStart","_set","fill","toArrayBuffer","BP","toLocaleString","self","window","base64-js","isarray",4,"lookup","decode","elt","PLUS","PLUS_URL_SAFE","SLASH","SLASH_URL_SAFE","NUMBER","UPPER","LOWER","b64ToByteArray","b64","L","tmp","placeHolders","charAt","Arr","uint8ToBase64","uint8","encode","num","tripletToBase64","temp","extraBytes","output","base64js",5,"isLE","mLen","nBytes","m","eLen","eMax","eBias","nBits","d","NaN","rt","abs","LN2",6,7,"EventEmitter","_events","_maxListeners","isFunction","isNumber","isObject","isUndefined","defaultMaxListeners","setMaxListeners","emit","er","handler","args","listeners","addListener","listener","newListener","warned","trace","once","g","removeListener","fired","position","splice","removeAllListeners","listenerCount","evlistener","emitter",8,"http","request","params","cb","scheme","protocol",9,"Object","create","ctor","superCtor","super_","enumerable","writable","configurable","TempCtor",10,"obj",11,12,"cleanUpNextTick","draining","currentQueue","queue","queueIndex","drainQueue","timeout","setTimeout","run","clearTimeout","Item","fun","noop","process","nextTick","browser","env","argv","version","versions","off","binding","cwd","chdir","dir","umask",13,"root","errors","map","fn","result","mapDomain","parts","split","regexSeparators","labels","encoded","ucs2decode","extra","counter","ucs2encode","stringFromCharCode","basicToDigit","base","digitToBasic","digit","flag","adapt","delta","numPoints","firstTime","k","damp","baseMinusTMin","tMax","skew","input","basic","index","oldi","w","baseMinusT","inputLength","initialN","bias","initialBias","lastIndexOf","delimiter","maxInt","tMin","handledCPCount","basicLength","q","currentValue","handledCPCountPlusOne","qMinusT","toUnicode","regexPunycode","test","toASCII","regexNonASCII","freeExports","nodeType","freeModule","freeGlobal","punycode","overflow","not-basic","invalid-input","ucs2","define","amd",14,"prop","qs","sep","eq","regexp","maxKeys","kstr","vstr","idx","decodeURIComponent","xs",15,"stringifyPrimitive","objectKeys","ks","encodeURIComponent","keys",16,"stringify","./decode","./encode",17,"./lib/_stream_duplex.js",18,"Duplex","Readable","Writable","readable","allowHalfOpen","onend","_writableState","ended","processNextTick","onEndNT","util","inherits","method","./_stream_readable","./_stream_writable","core-util-is","process-nextick-args",19,"PassThrough","Transform","_transform","chunk","./_stream_transform",20,"ReadableState","stream","objectMode","readableObjectMode","hwm","highWaterMark","defaultHwm","pipes","pipesCount","flowing","endEmitted","reading","sync","needReadable","emittedReadable","readableListening","defaultEncoding","ranOut","awaitDrain","readingMore","decoder","StringDecoder","_readableState","_read","Stream","readableAddChunk","state","addToFront","chunkInvalid","onEofChunk","unshift","emitReadable","maybeReadMore","needMoreData","computeNewHighWaterMark","MAX_HWM","howMuchToRead","debug","emitReadable_","flow","maybeReadMore_","pipeOnDrain","EElistenerCount","nReadingNextTick","resumeScheduled","resume_","fromList","stringMode","shift","cpy","endReadable","endReadableNT","forEach","_","debugUtil","debuglog","isPaused","setEncoding","enc","nOrig","doRead","dest","pipeOpts","onunpipe","cleanup","onclose","onfinish","ondrain","onerror","ondata","cleanedUp","needDrain","pause","unpipe","doEnd","stdout","stderr","endFn","dests","ev","wrap","paused","events","bind","_fromList","./_stream_duplex","_process","string_decoder/",21,"TransformState","afterTransform","needTransform","transforming","writecb","writechunk","ts","_transformState","rs","transform","flush","_flush","done","ws","_write","writeencoding",22,"nop","WriteReq","callback","next","WritableState","writableObjectMode","ending","finished","noDecode","decodeStrings","writing","corked","bufferProcessing","onwrite","writelen","bufferedRequest","lastBufferedRequest","pendingcb","prefinished","errorEmitted","writev","_writev","writeAfterEnd","validChunk","valid","decodeChunk","writeOrBuffer","last","doWrite","onwriteError","onwriteStateUpdate","needFinish","clearBuffer","afterWrite","onwriteDrain","finishMaybe","entry","cbs","err","prefinish","need","endWritable","internalUtil","deprecate","getBuffer","current","defineProperty","cork","uncork","setDefaultEncoding","util-deprecate",23,"objectToString","isBoolean","isNull","isNullOrUndefined","isString","isSymbol","isRegExp","re","isDate","isError","isPrimitive","../../../../insert-module-globals/node_modules/is-buffer/index.js",24,25,"msg","deprecated","config","warn","localStorage",26,"./lib/_stream_passthrough.js",27,"./lib/_stream_readable.js","./lib/_stream_transform.js","./lib/_stream_writable.js",28,29,30,"EE","source","didOnEnd","destroy","_isStdio","readable-stream/duplex.js","readable-stream/passthrough.js","readable-stream/readable.js","readable-stream/transform.js","readable-stream/writable.js",31,"ClientRequest","extend","statusCodes","opts","host","hostname","port","path","toUpperCase","headers","req","Agent","defaultMaxSockets","STATUS_CODES","METHODS","./lib/request","builtin-status-codes","xtend",32,"checkTypeSupport","xhr","responseType","fetch","ReadableByteStream","blobConstructor","Blob","XMLHttpRequest","open","location","haveArrayBuffer","haveSlice","arraybuffer","msstream","mozchunkedarraybuffer","overrideMimeType","vbArray","VBArray",33,"decideMode","preferBinary","capability","statusValid","status","response","IncomingMessage","rStates","readyStates","_opts","_body","_headers","auth","setHeader","mode","_mode","_onFinish","lowerName","unsafeHeaders","getHeader","removeHeader","_destroyed","body","headersObj","credentials","withCredentials","then","_fetchResponse","_connect","reason","_xhr","setRequestHeader","_response","onreadystatechange","readyState","LOADING","DONE","_onXHRProgress","onprogress","send","abort","flushHeaders","setNoDelay","setSocketKeepAlive","./capability","./response",34,"UNSENT","OPENED","HEADERS_RECEIVED","reader","rawHeaders","trailers","rawTrailers","statusCode","statusMessage","statusText","header","_i","_it","Symbol","iterator","getReader","_pos","getAllResponseHeaders","matches","_charset","mimeType","charsetMatch","responseBody","toArray","responseText","newData","MSStreamReader","onload","readAsArrayBuffer",35,"100","101","102","200","201","202","203","204","205","206","207","300","301","302","303","304","305","307","308","400","401","402","403","404","405","406","407","408","409","410","411","412","413","414","415","416","417","418","422","423","424","425","426","428","429","431","500","501","502","503","504","505","506","507","509","510","511",36,"assertEncoding","isBufferEncoding","passThroughWrite","utf16DetectIncompleteChar","charReceived","charLength","base64DetectIncompleteChar","surrogateSize","detectIncompleteChar","charBuffer","charStr","available","charCode","size","substring","cr",37,"Url","slashes","hash","search","query","pathname","href","urlParse","parseQueryString","slashesDenoteHost","urlFormat","format","urlResolve","relative","resolve","urlResolveObject","resolveObject","protocolPattern","portPattern","simplePathPattern","delims","unwise","autoEscape","nonHostChars","hostEndingChars","hostnameMaxLen","hostnamePartPattern","hostnamePartStart","unsafeProtocol","javascript","javascript:","hostlessProtocol","slashedProtocol","ftp","gopher","file","http:","https:","ftp:","gopher:","file:","querystring","queryIndex","splitter","uSplit","slashRegex","rest","simplePath","exec","proto","lowerProto","hostEnd","hec","atSign","parseHost","ipv6Hostname","hostparts","part","newpart","validParts","notHost","bit","p","h","ae","esc","escape","qm","rel","tkeys","tk","tkey","rkeys","rk","rkey","relPath","isSourceAbs","isRelAbs","mustEndAbs","removeAllDots","srcPath","psychotic","authInHost","hasTrailingSlash","up","isAbsolute","./util",38,39,40,"matchHtmlRegExp","html","lastIndex",41,"SAXParser","opt","parser","clearBuffers","bufferCheckPosition","MAX_BUFFER_LENGTH","lowercase","lowercasetags","looseCase","tags","closed","closedRoot","sawRoot","tag","noscript","S","BEGIN","strictEntities","ENTITIES","XML_ENTITIES","attribList","xmlns","ns","rootNS","trackPosition","line","column","checkBufferLength","maxAllowed","maxActual","buffers","closeText","emitNode","cdata","script","flushBuffers","SAXStream","me","_decoder","streamWraps","charClass","reduce","is","charclass","not","event","textNode","textopts","text","normalize","strictFail","BEGIN_WHITESPACE","TEXT","message","newTag","qname","attribute","qualName","prefix","local","attrib","attribName","attribValue","qn","XML_NAMESPACE","XMLNS_NAMESPACE","openTag","selfClosing","uri","JSON","nv","isSelfClosing","SCRIPT","closeTag","closeTo","close","parseEntity","entity","entityLC","numStr","fromCodePoint","beginWhiteSpace","OPEN_WAKA","startTagPosition","whitespace","starti","TEXT_ENTITY","SCRIPT_ENDING","CLOSE_TAG","SGML_DECL","sgmlDecl","nameStart","OPEN_TAG","PROC_INST","procInstName","procInstBody","pad","CDATA","COMMENT","comment","DOCTYPE","doctype","quote","SGML_DECL_QUOTED","DOCTYPE_DTD","DOCTYPE_QUOTED","DOCTYPE_DTD_QUOTED","COMMENT_ENDING","COMMENT_ENDED","CDATA_ENDING","CDATA_ENDING_2","PROC_INST_ENDING","PROC_INST_BODY","nameBody","OPEN_TAG_SLASH","ATTRIB","ATTRIB_NAME","ATTRIB_VALUE","ATTRIB_NAME_SAW_WHITE","ATTRIB_VALUE_QUOTED","ATTRIB_VALUE_UNQUOTED","ATTRIB_VALUE_ENTITY_Q","ATTRIB_VALUE_CLOSED","attribEnd","ATTRIB_VALUE_ENTITY_U","CLOSE_TAG_SAW_WHITE","returnState","entityBody","entityStart","EVENTS","F","newf","ex","filter","SD","number","letter","STATE","COMMENT_STARTING","amp","gt","lt","quot","apos","AElig","Aacute","Acirc","Agrave","Aring","Atilde","Auml","Ccedil","ETH","Eacute","Ecirc","Egrave","Euml","Iacute","Icirc","Igrave","Iuml","Ntilde","Oacute","Ocirc","Ograve","Oslash","Otilde","Ouml","THORN","Uacute","Ucirc","Ugrave","Uuml","Yacute","aacute","acirc","aelig","agrave","aring","atilde","auml","ccedil","eacute","ecirc","egrave","eth","euml","iacute","icirc","igrave","iuml","ntilde","oacute","ocirc","ograve","oslash","otilde","ouml","szlig","thorn","uacute","ucirc","ugrave","uuml","yacute","yuml","reg","nbsp","iexcl","cent","pound","curren","yen","brvbar","sect","uml","ordf","laquo","shy","macr","deg","plusmn","sup1","sup2","sup3","acute","micro","para","middot","cedil","ordm","raquo","frac14","frac12","frac34","iquest","times","divide","OElig","oelig","Scaron","scaron","Yuml","fnof","circ","tilde","Alpha","Beta","Gamma","Delta","Epsilon","Zeta","Eta","Theta","Iota","Kappa","Lambda","Mu","Nu","Xi","Omicron","Pi","Rho","Sigma","Tau","Upsilon","Phi","Chi","Psi","Omega","alpha","beta","gamma","epsilon","zeta","eta","theta","iota","kappa","lambda","mu","nu","xi","omicron","pi","rho","sigmaf","sigma","tau","upsilon","phi","chi","psi","omega","thetasym","upsih","piv","ensp","emsp","thinsp","zwnj","zwj","lrm","rlm","ndash","mdash","lsquo","rsquo","sbquo","ldquo","rdquo","bdquo","dagger","Dagger","bull","hellip","permil","prime","Prime","lsaquo","rsaquo","oline","frasl","euro","image","weierp","real","trade","alefsym","larr","uarr","rarr","darr","harr","crarr","lArr","uArr","rArr","dArr","hArr","forall","exist","empty","nabla","isin","notin","ni","prod","sum","minus","lowast","radic","infin","ang","and","or","cap","cup","int","there4","sim","cong","asymp","ne","equiv","le","ge","nsub","sube","supe","oplus","otimes","perp","sdot","lceil","rceil","lfloor","rfloor","lang","rang","loz","spades","clubs","hearts","diams","highSurrogate","lowSurrogate","MAX_SIZE","codeUnits","string_decoder"],"mappings":"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","file":"workers/xml-parser.js","sourcesContent":["(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require==\"function\"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error(\"Cannot find module '\"+o+\"'\");throw f.code=\"MODULE_NOT_FOUND\",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require==\"function\"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})","var sax = require(\"sax\");\nvar https = require(\"https\");\nvar escapeHtml = require('escape-html');\n\nvar strict = true;\nvar options = {};\nvar _WHITESPACE = ' ';\n\n/**\n *\n * @param stack Given array\n * @returns {*} last element of given array\n */\nfunction peek(stack) {\n    return stack.length > 0 ? stack[stack.length - 1] : null;\n}\n\nvar ignoredElements = {\n    'jcis': true,\n    'jci': true,\n    'alias-titels': true,\n    'meta-data': true,\n    'metadata': true\n};\nvar htmlMappings = {\n    al: 'p',\n    lijst: 'ul',\n    nadruk: 'em',\n    intitule: 'h1',\n    titel: 'h3',\n    title: 'h3',\n    tussenkop: 'h3',\n    label: 'h3',\n    nr: 'h3',\n    lidnr: 'h4',\n    artikel: 'article',\n    dagtekening: 'div',\n    plaats: 'span',\n    datum: 'span',\n    functie: 'span',\n    redactie: 'span',\n    naam: 'span',\n    voornaam: 'span',\n    achternaam: 'span',\n    organisatie: 'span',\n    sup: 'sup',\n    sub: 'sub',\n    intref: 'a', // TODO handle intrefgroep\n    extref: 'a', // TODO handle extrefgroep\n    illustratie: 'img', // TODO properly handle get src url\n    table: 'div', // TODO handle the myriad table attrs\n    colspec: 'col',\n    thead: 'thead',\n    tfoot: 'tfoot',\n    entrytbl: 'table',\n    tbody: 'tbody',\n    li: 'li',\n    kop: 'header',\n    row: 'tr'\n};\n\n/**\n *\n * @param name tagname string\n * @param xmlTag xml tag name string\n * @param attrs string to string map\n * @param children Array of strings\n * @returns {{name: *, attrs: *, children: *}}\n */\nfunction createElement(name, xmlTag, attrs, children) {\n    return {\n        name: name,\n        xml: xmlTag,\n        attrs: attrs,\n        children: children\n    };\n}\n\nfunction setAttr(xmlKey, xmlAttrs, htmlKey, htmlAttrs) {\n    htmlAttrs[htmlKey] = escapeHtml(xmlAttrs[xmlKey]);\n}\nfunction getHtmlAttributes(node) {\n    var attrs = {\n        'class': node.name\n        //'data-xml-tag': xmlTag\n    };\n    var nas = node.attributes;\n    if (nas['bwb-ng-variabel-deel'] && !(node.name.match(/(int?|ext)ref/))) {\n        setAttr('bwb-ng-variabel-deel', nas, 'id', attrs);\n    } else if (nas['if']) {\n        setAttr('id', nas, 'id', attrs);\n    }\n\n    for (var key in nas) {\n        if (nas.hasOwnProperty(key))\n            if (key == 'id') {\n                setAttr(key, nas, 'data-id', attrs);\n            } else if (key == 'stam-id') {\n                setAttr(key, nas, 'data-stam-id', attrs);\n            } else if (key == 'versie-id') {\n                setAttr(key, nas, 'data-versie-id', attrs);\n            } else if (key == 'label-id') {\n                setAttr(key, nas, 'data-label-id', attrs);\n                //doc=\"32004L0017\" label=\"richtlijn\" reeks=\"Celex\"\n                //verwijzing-id=\"2556878\" doc=\"\" bwb-id=\"\" label-id=\"12115324\"\n            } else if (key == 'bwb-id') {\n                setAttr(key, nas, 'data-bwb-id', attrs);\n            } else if (key == 'verwijzing-id') {\n                setAttr(key, nas, 'data-verwijzing-id', attrs);\n            } else if (key == 'label') {\n                setAttr(key, nas, 'data-label', attrs);\n            } else if (key == 'reeks') {\n                setAttr(key, nas, 'data-reeks', attrs);\n            } else if (key == 'doc') {\n                setAttr(key, nas, 'data-doc', attrs);\n\n            } else {\n                //console.log(attr);\n            }\n    }\n    return attrs;\n}\n\nfunction simpleNodeHtml(htmlTag, node) {\n    return createElement(htmlTag, node.name, getHtmlAttributes(node), []);\n}\n\n\nfunction getAttributesAsString(attrs) {\n    if (attrs.length <= 0) {\n        return ''\n    } else {\n        var ss = [];\n        for (var key in attrs) {\n            if (attrs.hasOwnProperty(key))\n                ss.push('' + key + '=\"' + attrs[key] + '\"');\n        }\n        return ' ' + ss.join(' ');\n    }\n}\n\nfunction setAnchor(xmlNode, htmlNode) {\n    // TODO parse version (jcil); CELEX, etc.\n    var nas = xmlNode.attributes;\n    if (nas['bwb-id']) {\n        htmlNode.attrs['href'] = '../reader/?bwbId=' + nas['bwb-id'];\n    }\n}\n/**\n *\n * @param inStream xml input stream\n */\nfunction parse(inStream) {\n    var elementStack = [];\n    var html = null;\n    var rootNode = createElement(\"article\", \"wetgeving\", {\n        'class': \"wetgeving legal-document wrapper\"\n    }, []);\n\n    function currentElHasIgnoredParent() {\n        if (peek(elementStack)) {\n            return peek(elementStack).children == undefined;\n        }\n        return false;\n    }\n\n    function shouldIgnore(name) {\n        return !!(!!ignoredElements[name] || !!currentElHasIgnoredParent());\n    }\n\n    function xmlNodeToHtmlNode(node) {\n        var nm = node.name;\n\n        if ('entry' == nm) {\n            if (peek(elementStack) && peek(elementStack).xml == 'thead')\n                return simpleNodeHtml('th', node);\n            if (peek(elementStack) && peek(elementStack).xml == 'tbody')\n                return simpleNodeHtml('td', node);\n            if (peek(elementStack) && peek(elementStack).xml == 'row')\n                return simpleNodeHtml('td', node);\n        }\n\n\n        // Check if there is a simple mapping\n        for (var tagName in htmlMappings) {\n            if (tagName == nm && htmlMappings.hasOwnProperty(tagName)) {\n                var htmlNod = simpleNodeHtml(htmlMappings[tagName], node);\n                if (tagName == 'extref') {\n                    setAnchor(node, htmlNod);\n                }\n                return htmlNod;\n            }\n        }\n\n        if ('tgroup' == nm) {\n            // TODO <tgroup align=\"left\" char=\"\" charoff=\"50\" cols=\"3\" colsep=\"0\" rowsep=\"0\">\n            return simpleNodeHtml('table', node);\n        }\n\n        if ('meta' == nm) {\n            // TODO handle meta tag\n        }\n\n        // Default: just make a <div>\n        return simpleNodeHtml('div', node);\n    }\n\n    var saxStream = sax.createStream(strict, options);\n    saxStream.on(\"error\", function (e) {\n        // unhandled errors will throw, since this is a proper node\n        // event emitter.\n        console.error(\"error!\", e);\n\n        // clear the error\n        this._parser.error = null;\n        this._parser.resume()\n    });\n\n    saxStream.on(\"text\", function (str) {\n        if (peek(elementStack) && !currentElHasIgnoredParent()) {\n            var parentChildren = peek(elementStack).children;\n            if (str.match(/^\\s+$/)) {\n                // Replace multiple whitespace characters by a single space\n                if (!(parentChildren.length > 0 &&\n                    parentChildren[parentChildren.length - 1] == _WHITESPACE)) {\n                    parentChildren.push(_WHITESPACE);\n                }\n            } else {\n                parentChildren.push(escapeHtml(str));\n            }\n        }\n    });\n\n    saxStream.on(\"opentag\", function (node) {\n            if (elementStack.length <= 0 && node.name != 'wetgeving') return; // We haven't even started yet\n\n            var ignore = shouldIgnore(node.name);\n            var htmlNode = {xml: node.name};\n            if (ignore) {\n            } else {\n                if (node.name == 'wetgeving') {\n                    /**\n                     * Root node\n                     */\n                        //console.log('rootnode set: ' + rootNode);\n                    htmlNode = rootNode;\n                }\n\n                if (elementStack.length > 0) {\n                    htmlNode = xmlNodeToHtmlNode(node);\n                }\n            }\n            elementStack.push(htmlNode);\n        }\n    );\n\n    saxStream.on(\"closetag\", function (nodeName) {\n        if (elementStack.length <= 0) return; // We're already done\n\n        var element = elementStack.pop();\n        if (nodeName != element.xml) {\n            console.error(\"Expected \" + element.xml + \" instead of \" + nodeName);\n        }\n        if (!shouldIgnore(nodeName)) {\n            postMessage(element);\n        }\n        //if (element.attrs) {\n        //    var elementString =\n        //        \"<\" + element.name + getAttributesAsString(element.attrs) + \">\" +\n        //        element.children.join('') +\n        //        \"</\" + element.name + \">\";\n        //\n        //    var parentNode = peek(elementStack);\n        //    if (parentNode) {\n        //        parentNode.children.push(elementString);\n        //    } else {\n        //        html = elementString;\n        //    }\n        //}\n    });\n    saxStream.on(\"end\", function () {\n        postMessage(\"done parsing\");\n    });\n\n    // Pipe stream to parser\n    inStream.pipe(saxStream);\n}\n\nonmessage = function (e) {\n    if (!e.data) console.error(\"No url specified\");\n\n    var url = e.data;\n    https.get(url, parse);\n\n    console.log('Started parsing ' + (url));\n};\n","(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require==\"function\"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error(\"Cannot find module '\"+o+\"'\");throw f.code=\"MODULE_NOT_FOUND\",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require==\"function\"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(require,module,exports){\nvar sax = require(\"sax\");\nvar https = require(\"https\");\nvar escapeHtml = require('escape-html');\n\nvar strict = true;\nvar options = {};\nvar _WHITESPACE = ' ';\n\n/**\n *\n * @param stack Given array\n * @returns {*} last element of given array\n */\nfunction peek(stack) {\n    return stack.length > 0 ? stack[stack.length - 1] : null;\n}\n\nvar ignoredElements = {\n    'jcis': true,\n    'jci': true,\n    'alias-titels': true,\n    'meta-data': true,\n    'metadata': true\n};\nvar htmlMappings = {\n    al: 'p',\n    lijst: 'ul',\n    nadruk: 'em',\n    intitule: 'h1',\n    titel: 'h3',\n    title: 'h3',\n    tussenkop: 'h3',\n    label: 'h3',\n    nr: 'h3',\n    lidnr: 'h4',\n    artikel: 'article',\n    dagtekening: 'div',\n    plaats: 'span',\n    datum: 'span',\n    functie: 'span',\n    redactie: 'span',\n    naam: 'span',\n    voornaam: 'span',\n    achternaam: 'span',\n    organisatie: 'span',\n    sup: 'sup',\n    sub: 'sub',\n    intref: 'a', // TODO handle intrefgroep\n    extref: 'a', // TODO handle extrefgroep\n    illustratie: 'img', // TODO properly handle get src url\n    table: 'div', // TODO handle the myriad table attrs\n    colspec: 'col',\n    thead: 'thead',\n    tfoot: 'tfoot',\n    entrytbl: 'table',\n    tbody: 'tbody',\n    li: 'li',\n    kop: 'header',\n    row: 'tr'\n};\n\n/**\n *\n * @param name tagname string\n * @param xmlTag xml tag name string\n * @param attrs string to string map\n * @param children Array of strings\n * @returns {{name: *, attrs: *, children: *}}\n */\nfunction createElement(name, xmlTag, attrs, children) {\n    return {\n        name: name,\n        xml: xmlTag,\n        attrs: attrs,\n        children: children\n    };\n}\n\nfunction setAttr(xmlKey, xmlAttrs, htmlKey, htmlAttrs) {\n    htmlAttrs[htmlKey] = escapeHtml(xmlAttrs[xmlKey]);\n}\nfunction getHtmlAttributes(node) {\n    var attrs = {\n        'class': node.name\n        //'data-xml-tag': xmlTag\n    };\n    var nas = node.attributes;\n    if (nas['bwb-ng-variabel-deel'] && !(node.name.match(/(int?|ext)ref/))) {\n        setAttr('bwb-ng-variabel-deel', nas, 'id', attrs);\n    } else if (nas['if']) {\n        setAttr('id', nas, 'id', attrs);\n    }\n\n    for (var key in nas) {\n        if (nas.hasOwnProperty(key))\n            if (key == 'id') {\n                setAttr(key, nas, 'data-id', attrs);\n            } else if (key == 'stam-id') {\n                setAttr(key, nas, 'data-stam-id', attrs);\n            } else if (key == 'versie-id') {\n                setAttr(key, nas, 'data-versie-id', attrs);\n            } else if (key == 'label-id') {\n                setAttr(key, nas, 'data-label-id', attrs);\n                //doc=\"32004L0017\" label=\"richtlijn\" reeks=\"Celex\"\n                //verwijzing-id=\"2556878\" doc=\"\" bwb-id=\"\" label-id=\"12115324\"\n            } else if (key == 'bwb-id') {\n                setAttr(key, nas, 'data-bwb-id', attrs);\n            } else if (key == 'verwijzing-id') {\n                setAttr(key, nas, 'data-verwijzing-id', attrs);\n            } else if (key == 'label') {\n                setAttr(key, nas, 'data-label', attrs);\n            } else if (key == 'reeks') {\n                setAttr(key, nas, 'data-reeks', attrs);\n            } else if (key == 'doc') {\n                setAttr(key, nas, 'data-doc', attrs);\n\n            } else {\n                //console.log(attr);\n            }\n    }\n    return attrs;\n}\n\nfunction simpleNodeHtml(htmlTag, node) {\n    return createElement(htmlTag, node.name, getHtmlAttributes(node), []);\n}\n\n\nfunction getAttributesAsString(attrs) {\n    if (attrs.length <= 0) {\n        return ''\n    } else {\n        var ss = [];\n        for (var key in attrs) {\n            if (attrs.hasOwnProperty(key))\n                ss.push('' + key + '=\"' + attrs[key] + '\"');\n        }\n        return ' ' + ss.join(' ');\n    }\n}\n\nfunction setAnchor(xmlNode, htmlNode) {\n    // TODO parse version (jcil); CELEX, etc.\n    var nas = xmlNode.attributes;\n    if (nas['bwb-id']) {\n        htmlNode.attrs['href'] = '../reader/?bwbId=' + nas['bwb-id'];\n    }\n}\n/**\n *\n * @param inStream xml input stream\n */\nfunction parse(inStream) {\n    var elementStack = [];\n    var html = null;\n    var rootNode = createElement(\"article\", \"wetgeving\", {\n        'class': \"wetgeving legal-document wrapper\"\n    }, []);\n\n    function currentElHasIgnoredParent() {\n        if (peek(elementStack)) {\n            return peek(elementStack).children == undefined;\n        }\n        return false;\n    }\n\n    function shouldIgnore(name) {\n        return !!(!!ignoredElements[name] || !!currentElHasIgnoredParent());\n    }\n\n    function xmlNodeToHtmlNode(node) {\n        var nm = node.name;\n\n        if ('entry' == nm) {\n            if (peek(elementStack) && peek(elementStack).xml == 'thead')\n                return simpleNodeHtml('th', node);\n            if (peek(elementStack) && peek(elementStack).xml == 'tbody')\n                return simpleNodeHtml('td', node);\n            if (peek(elementStack) && peek(elementStack).xml == 'row')\n                return simpleNodeHtml('td', node);\n        }\n\n\n        // Check if there is a simple mapping\n        for (var tagName in htmlMappings) {\n            if (tagName == nm && htmlMappings.hasOwnProperty(tagName)) {\n                var htmlNod = simpleNodeHtml(htmlMappings[tagName], node);\n                if (tagName == 'extref') {\n                    setAnchor(node, htmlNod);\n                }\n                return htmlNod;\n            }\n        }\n\n        if ('tgroup' == nm) {\n            // TODO <tgroup align=\"left\" char=\"\" charoff=\"50\" cols=\"3\" colsep=\"0\" rowsep=\"0\">\n            return simpleNodeHtml('table', node);\n        }\n\n        if ('meta' == nm) {\n            // TODO handle meta tag\n        }\n\n        // Default: just make a <div>\n        return simpleNodeHtml('div', node);\n    }\n\n    var saxStream = sax.createStream(strict, options);\n    saxStream.on(\"error\", function (e) {\n        // unhandled errors will throw, since this is a proper node\n        // event emitter.\n        console.error(\"error!\", e);\n\n        // clear the error\n        this._parser.error = null;\n        this._parser.resume()\n    });\n\n    saxStream.on(\"text\", function (str) {\n        if (peek(elementStack) && !currentElHasIgnoredParent()) {\n            var parentChildren = peek(elementStack).children;\n            if (str.match(/^\\s+$/)) {\n                // Replace multiple whitespace characters by a single space\n                if (!(parentChildren.length > 0 &&\n                    parentChildren[parentChildren.length - 1] == _WHITESPACE)) {\n                    parentChildren.push(_WHITESPACE);\n                }\n            } else {\n                parentChildren.push(escapeHtml(str));\n            }\n        }\n    });\n\n    saxStream.on(\"opentag\", function (node) {\n            if (elementStack.length <= 0 && node.name != 'wetgeving') return; // We haven't even started yet\n\n            var ignore = shouldIgnore(node.name);\n            var htmlNode = {xml: node.name};\n            if (ignore) {\n            } else {\n                if (node.name == 'wetgeving') {\n                    /**\n                     * Root node\n                     */\n                        //console.log('rootnode set: ' + rootNode);\n                    htmlNode = rootNode;\n                }\n\n                if (elementStack.length > 0) {\n                    htmlNode = xmlNodeToHtmlNode(node);\n                }\n            }\n            elementStack.push(htmlNode);\n        }\n    );\n\n    saxStream.on(\"closetag\", function (nodeName) {\n        if (elementStack.length <= 0) return; // We're already done\n\n        var element = elementStack.pop();\n        if (nodeName != element.xml) {\n            console.error(\"Expected \" + element.xml + \" instead of \" + nodeName);\n        }\n        if (!shouldIgnore(nodeName)) {\n            postMessage(element);\n        }\n        //if (element.attrs) {\n        //    var elementString =\n        //        \"<\" + element.name + getAttributesAsString(element.attrs) + \">\" +\n        //        element.children.join('') +\n        //        \"</\" + element.name + \">\";\n        //\n        //    var parentNode = peek(elementStack);\n        //    if (parentNode) {\n        //        parentNode.children.push(elementString);\n        //    } else {\n        //        html = elementString;\n        //    }\n        //}\n    });\n    saxStream.on(\"end\", function () {\n        postMessage(\"done parsing\");\n    });\n\n    // Pipe stream to parser\n    inStream.pipe(saxStream);\n}\n\nonmessage = function (e) {\n    if (!e.data) console.error(\"No url specified\");\n\n    var url = e.data;\n    https.get(url, parse);\n\n    console.log('Started parsing ' + (url));\n};\n\n},{\"escape-html\":40,\"https\":8,\"sax\":41}],2:[function(require,module,exports){\n\n},{}],3:[function(require,module,exports){\n(function (global){\n/*!\n * The buffer module from node.js, for the browser.\n *\n * @author   Feross Aboukhadijeh <feross@feross.org> <http://feross.org>\n * @license  MIT\n */\n/* eslint-disable no-proto */\n\nvar base64 = require('base64-js')\nvar ieee754 = require('ieee754')\nvar isArray = require('isarray')\n\nexports.Buffer = Buffer\nexports.SlowBuffer = SlowBuffer\nexports.INSPECT_MAX_BYTES = 50\nBuffer.poolSize = 8192 // not used by this implementation\n\nvar rootParent = {}\n\n/**\n * If `Buffer.TYPED_ARRAY_SUPPORT`:\n *   === true    Use Uint8Array implementation (fastest)\n *   === false   Use Object implementation (most compatible, even IE6)\n *\n * Browsers that support typed arrays are IE 10+, Firefox 4+, Chrome 7+, Safari 5.1+,\n * Opera 11.6+, iOS 4.2+.\n *\n * Due to various browser bugs, sometimes the Object implementation will be used even\n * when the browser supports typed arrays.\n *\n * Note:\n *\n *   - Firefox 4-29 lacks support for adding new properties to `Uint8Array` instances,\n *     See: https://bugzilla.mozilla.org/show_bug.cgi?id=695438.\n *\n *   - Safari 5-7 lacks support for changing the `Object.prototype.constructor` property\n *     on objects.\n *\n *   - Chrome 9-10 is missing the `TypedArray.prototype.subarray` function.\n *\n *   - IE10 has a broken `TypedArray.prototype.subarray` function which returns arrays of\n *     incorrect length in some situations.\n\n * We detect these buggy browsers and set `Buffer.TYPED_ARRAY_SUPPORT` to `false` so they\n * get the Object implementation, which is slower but behaves correctly.\n */\nBuffer.TYPED_ARRAY_SUPPORT = global.TYPED_ARRAY_SUPPORT !== undefined\n  ? global.TYPED_ARRAY_SUPPORT\n  : typedArraySupport()\n\nfunction typedArraySupport () {\n  function Bar () {}\n  try {\n    var arr = new Uint8Array(1)\n    arr.foo = function () { return 42 }\n    arr.constructor = Bar\n    return arr.foo() === 42 && // typed array instances can be augmented\n        arr.constructor === Bar && // constructor can be set\n        typeof arr.subarray === 'function' && // chrome 9-10 lack `subarray`\n        arr.subarray(1, 1).byteLength === 0 // ie10 has broken `subarray`\n  } catch (e) {\n    return false\n  }\n}\n\nfunction kMaxLength () {\n  return Buffer.TYPED_ARRAY_SUPPORT\n    ? 0x7fffffff\n    : 0x3fffffff\n}\n\n/**\n * Class: Buffer\n * =============\n *\n * The Buffer constructor returns instances of `Uint8Array` that are augmented\n * with function properties for all the node `Buffer` API functions. We use\n * `Uint8Array` so that square bracket notation works as expected -- it returns\n * a single octet.\n *\n * By augmenting the instances, we can avoid modifying the `Uint8Array`\n * prototype.\n */\nfunction Buffer (arg) {\n  if (!(this instanceof Buffer)) {\n    // Avoid going through an ArgumentsAdaptorTrampoline in the common case.\n    if (arguments.length > 1) return new Buffer(arg, arguments[1])\n    return new Buffer(arg)\n  }\n\n  this.length = 0\n  this.parent = undefined\n\n  // Common case.\n  if (typeof arg === 'number') {\n    return fromNumber(this, arg)\n  }\n\n  // Slightly less common case.\n  if (typeof arg === 'string') {\n    return fromString(this, arg, arguments.length > 1 ? arguments[1] : 'utf8')\n  }\n\n  // Unusual.\n  return fromObject(this, arg)\n}\n\nfunction fromNumber (that, length) {\n  that = allocate(that, length < 0 ? 0 : checked(length) | 0)\n  if (!Buffer.TYPED_ARRAY_SUPPORT) {\n    for (var i = 0; i < length; i++) {\n      that[i] = 0\n    }\n  }\n  return that\n}\n\nfunction fromString (that, string, encoding) {\n  if (typeof encoding !== 'string' || encoding === '') encoding = 'utf8'\n\n  // Assumption: byteLength() return value is always < kMaxLength.\n  var length = byteLength(string, encoding) | 0\n  that = allocate(that, length)\n\n  that.write(string, encoding)\n  return that\n}\n\nfunction fromObject (that, object) {\n  if (Buffer.isBuffer(object)) return fromBuffer(that, object)\n\n  if (isArray(object)) return fromArray(that, object)\n\n  if (object == null) {\n    throw new TypeError('must start with number, buffer, array or string')\n  }\n\n  if (typeof ArrayBuffer !== 'undefined') {\n    if (object.buffer instanceof ArrayBuffer) {\n      return fromTypedArray(that, object)\n    }\n    if (object instanceof ArrayBuffer) {\n      return fromArrayBuffer(that, object)\n    }\n  }\n\n  if (object.length) return fromArrayLike(that, object)\n\n  return fromJsonObject(that, object)\n}\n\nfunction fromBuffer (that, buffer) {\n  var length = checked(buffer.length) | 0\n  that = allocate(that, length)\n  buffer.copy(that, 0, 0, length)\n  return that\n}\n\nfunction fromArray (that, array) {\n  var length = checked(array.length) | 0\n  that = allocate(that, length)\n  for (var i = 0; i < length; i += 1) {\n    that[i] = array[i] & 255\n  }\n  return that\n}\n\n// Duplicate of fromArray() to keep fromArray() monomorphic.\nfunction fromTypedArray (that, array) {\n  var length = checked(array.length) | 0\n  that = allocate(that, length)\n  // Truncating the elements is probably not what people expect from typed\n  // arrays with BYTES_PER_ELEMENT > 1 but it's compatible with the behavior\n  // of the old Buffer constructor.\n  for (var i = 0; i < length; i += 1) {\n    that[i] = array[i] & 255\n  }\n  return that\n}\n\nfunction fromArrayBuffer (that, array) {\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    // Return an augmented `Uint8Array` instance, for best performance\n    array.byteLength\n    that = Buffer._augment(new Uint8Array(array))\n  } else {\n    // Fallback: Return an object instance of the Buffer class\n    that = fromTypedArray(that, new Uint8Array(array))\n  }\n  return that\n}\n\nfunction fromArrayLike (that, array) {\n  var length = checked(array.length) | 0\n  that = allocate(that, length)\n  for (var i = 0; i < length; i += 1) {\n    that[i] = array[i] & 255\n  }\n  return that\n}\n\n// Deserialize { type: 'Buffer', data: [1,2,3,...] } into a Buffer object.\n// Returns a zero-length buffer for inputs that don't conform to the spec.\nfunction fromJsonObject (that, object) {\n  var array\n  var length = 0\n\n  if (object.type === 'Buffer' && isArray(object.data)) {\n    array = object.data\n    length = checked(array.length) | 0\n  }\n  that = allocate(that, length)\n\n  for (var i = 0; i < length; i += 1) {\n    that[i] = array[i] & 255\n  }\n  return that\n}\n\nif (Buffer.TYPED_ARRAY_SUPPORT) {\n  Buffer.prototype.__proto__ = Uint8Array.prototype\n  Buffer.__proto__ = Uint8Array\n}\n\nfunction allocate (that, length) {\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    // Return an augmented `Uint8Array` instance, for best performance\n    that = Buffer._augment(new Uint8Array(length))\n    that.__proto__ = Buffer.prototype\n  } else {\n    // Fallback: Return an object instance of the Buffer class\n    that.length = length\n    that._isBuffer = true\n  }\n\n  var fromPool = length !== 0 && length <= Buffer.poolSize >>> 1\n  if (fromPool) that.parent = rootParent\n\n  return that\n}\n\nfunction checked (length) {\n  // Note: cannot use `length < kMaxLength` here because that fails when\n  // length is NaN (which is otherwise coerced to zero.)\n  if (length >= kMaxLength()) {\n    throw new RangeError('Attempt to allocate Buffer larger than maximum ' +\n                         'size: 0x' + kMaxLength().toString(16) + ' bytes')\n  }\n  return length | 0\n}\n\nfunction SlowBuffer (subject, encoding) {\n  if (!(this instanceof SlowBuffer)) return new SlowBuffer(subject, encoding)\n\n  var buf = new Buffer(subject, encoding)\n  delete buf.parent\n  return buf\n}\n\nBuffer.isBuffer = function isBuffer (b) {\n  return !!(b != null && b._isBuffer)\n}\n\nBuffer.compare = function compare (a, b) {\n  if (!Buffer.isBuffer(a) || !Buffer.isBuffer(b)) {\n    throw new TypeError('Arguments must be Buffers')\n  }\n\n  if (a === b) return 0\n\n  var x = a.length\n  var y = b.length\n\n  var i = 0\n  var len = Math.min(x, y)\n  while (i < len) {\n    if (a[i] !== b[i]) break\n\n    ++i\n  }\n\n  if (i !== len) {\n    x = a[i]\n    y = b[i]\n  }\n\n  if (x < y) return -1\n  if (y < x) return 1\n  return 0\n}\n\nBuffer.isEncoding = function isEncoding (encoding) {\n  switch (String(encoding).toLowerCase()) {\n    case 'hex':\n    case 'utf8':\n    case 'utf-8':\n    case 'ascii':\n    case 'binary':\n    case 'base64':\n    case 'raw':\n    case 'ucs2':\n    case 'ucs-2':\n    case 'utf16le':\n    case 'utf-16le':\n      return true\n    default:\n      return false\n  }\n}\n\nBuffer.concat = function concat (list, length) {\n  if (!isArray(list)) throw new TypeError('list argument must be an Array of Buffers.')\n\n  if (list.length === 0) {\n    return new Buffer(0)\n  }\n\n  var i\n  if (length === undefined) {\n    length = 0\n    for (i = 0; i < list.length; i++) {\n      length += list[i].length\n    }\n  }\n\n  var buf = new Buffer(length)\n  var pos = 0\n  for (i = 0; i < list.length; i++) {\n    var item = list[i]\n    item.copy(buf, pos)\n    pos += item.length\n  }\n  return buf\n}\n\nfunction byteLength (string, encoding) {\n  if (typeof string !== 'string') string = '' + string\n\n  var len = string.length\n  if (len === 0) return 0\n\n  // Use a for loop to avoid recursion\n  var loweredCase = false\n  for (;;) {\n    switch (encoding) {\n      case 'ascii':\n      case 'binary':\n      // Deprecated\n      case 'raw':\n      case 'raws':\n        return len\n      case 'utf8':\n      case 'utf-8':\n        return utf8ToBytes(string).length\n      case 'ucs2':\n      case 'ucs-2':\n      case 'utf16le':\n      case 'utf-16le':\n        return len * 2\n      case 'hex':\n        return len >>> 1\n      case 'base64':\n        return base64ToBytes(string).length\n      default:\n        if (loweredCase) return utf8ToBytes(string).length // assume utf8\n        encoding = ('' + encoding).toLowerCase()\n        loweredCase = true\n    }\n  }\n}\nBuffer.byteLength = byteLength\n\n// pre-set for values that may exist in the future\nBuffer.prototype.length = undefined\nBuffer.prototype.parent = undefined\n\nfunction slowToString (encoding, start, end) {\n  var loweredCase = false\n\n  start = start | 0\n  end = end === undefined || end === Infinity ? this.length : end | 0\n\n  if (!encoding) encoding = 'utf8'\n  if (start < 0) start = 0\n  if (end > this.length) end = this.length\n  if (end <= start) return ''\n\n  while (true) {\n    switch (encoding) {\n      case 'hex':\n        return hexSlice(this, start, end)\n\n      case 'utf8':\n      case 'utf-8':\n        return utf8Slice(this, start, end)\n\n      case 'ascii':\n        return asciiSlice(this, start, end)\n\n      case 'binary':\n        return binarySlice(this, start, end)\n\n      case 'base64':\n        return base64Slice(this, start, end)\n\n      case 'ucs2':\n      case 'ucs-2':\n      case 'utf16le':\n      case 'utf-16le':\n        return utf16leSlice(this, start, end)\n\n      default:\n        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)\n        encoding = (encoding + '').toLowerCase()\n        loweredCase = true\n    }\n  }\n}\n\nBuffer.prototype.toString = function toString () {\n  var length = this.length | 0\n  if (length === 0) return ''\n  if (arguments.length === 0) return utf8Slice(this, 0, length)\n  return slowToString.apply(this, arguments)\n}\n\nBuffer.prototype.equals = function equals (b) {\n  if (!Buffer.isBuffer(b)) throw new TypeError('Argument must be a Buffer')\n  if (this === b) return true\n  return Buffer.compare(this, b) === 0\n}\n\nBuffer.prototype.inspect = function inspect () {\n  var str = ''\n  var max = exports.INSPECT_MAX_BYTES\n  if (this.length > 0) {\n    str = this.toString('hex', 0, max).match(/.{2}/g).join(' ')\n    if (this.length > max) str += ' ... '\n  }\n  return '<Buffer ' + str + '>'\n}\n\nBuffer.prototype.compare = function compare (b) {\n  if (!Buffer.isBuffer(b)) throw new TypeError('Argument must be a Buffer')\n  if (this === b) return 0\n  return Buffer.compare(this, b)\n}\n\nBuffer.prototype.indexOf = function indexOf (val, byteOffset) {\n  if (byteOffset > 0x7fffffff) byteOffset = 0x7fffffff\n  else if (byteOffset < -0x80000000) byteOffset = -0x80000000\n  byteOffset >>= 0\n\n  if (this.length === 0) return -1\n  if (byteOffset >= this.length) return -1\n\n  // Negative offsets start from the end of the buffer\n  if (byteOffset < 0) byteOffset = Math.max(this.length + byteOffset, 0)\n\n  if (typeof val === 'string') {\n    if (val.length === 0) return -1 // special case: looking for empty string always fails\n    return String.prototype.indexOf.call(this, val, byteOffset)\n  }\n  if (Buffer.isBuffer(val)) {\n    return arrayIndexOf(this, val, byteOffset)\n  }\n  if (typeof val === 'number') {\n    if (Buffer.TYPED_ARRAY_SUPPORT && Uint8Array.prototype.indexOf === 'function') {\n      return Uint8Array.prototype.indexOf.call(this, val, byteOffset)\n    }\n    return arrayIndexOf(this, [ val ], byteOffset)\n  }\n\n  function arrayIndexOf (arr, val, byteOffset) {\n    var foundIndex = -1\n    for (var i = 0; byteOffset + i < arr.length; i++) {\n      if (arr[byteOffset + i] === val[foundIndex === -1 ? 0 : i - foundIndex]) {\n        if (foundIndex === -1) foundIndex = i\n        if (i - foundIndex + 1 === val.length) return byteOffset + foundIndex\n      } else {\n        foundIndex = -1\n      }\n    }\n    return -1\n  }\n\n  throw new TypeError('val must be string, number or Buffer')\n}\n\n// `get` is deprecated\nBuffer.prototype.get = function get (offset) {\n  console.log('.get() is deprecated. Access using array indexes instead.')\n  return this.readUInt8(offset)\n}\n\n// `set` is deprecated\nBuffer.prototype.set = function set (v, offset) {\n  console.log('.set() is deprecated. Access using array indexes instead.')\n  return this.writeUInt8(v, offset)\n}\n\nfunction hexWrite (buf, string, offset, length) {\n  offset = Number(offset) || 0\n  var remaining = buf.length - offset\n  if (!length) {\n    length = remaining\n  } else {\n    length = Number(length)\n    if (length > remaining) {\n      length = remaining\n    }\n  }\n\n  // must be an even number of digits\n  var strLen = string.length\n  if (strLen % 2 !== 0) throw new Error('Invalid hex string')\n\n  if (length > strLen / 2) {\n    length = strLen / 2\n  }\n  for (var i = 0; i < length; i++) {\n    var parsed = parseInt(string.substr(i * 2, 2), 16)\n    if (isNaN(parsed)) throw new Error('Invalid hex string')\n    buf[offset + i] = parsed\n  }\n  return i\n}\n\nfunction utf8Write (buf, string, offset, length) {\n  return blitBuffer(utf8ToBytes(string, buf.length - offset), buf, offset, length)\n}\n\nfunction asciiWrite (buf, string, offset, length) {\n  return blitBuffer(asciiToBytes(string), buf, offset, length)\n}\n\nfunction binaryWrite (buf, string, offset, length) {\n  return asciiWrite(buf, string, offset, length)\n}\n\nfunction base64Write (buf, string, offset, length) {\n  return blitBuffer(base64ToBytes(string), buf, offset, length)\n}\n\nfunction ucs2Write (buf, string, offset, length) {\n  return blitBuffer(utf16leToBytes(string, buf.length - offset), buf, offset, length)\n}\n\nBuffer.prototype.write = function write (string, offset, length, encoding) {\n  // Buffer#write(string)\n  if (offset === undefined) {\n    encoding = 'utf8'\n    length = this.length\n    offset = 0\n  // Buffer#write(string, encoding)\n  } else if (length === undefined && typeof offset === 'string') {\n    encoding = offset\n    length = this.length\n    offset = 0\n  // Buffer#write(string, offset[, length][, encoding])\n  } else if (isFinite(offset)) {\n    offset = offset | 0\n    if (isFinite(length)) {\n      length = length | 0\n      if (encoding === undefined) encoding = 'utf8'\n    } else {\n      encoding = length\n      length = undefined\n    }\n  // legacy write(string, encoding, offset, length) - remove in v0.13\n  } else {\n    var swap = encoding\n    encoding = offset\n    offset = length | 0\n    length = swap\n  }\n\n  var remaining = this.length - offset\n  if (length === undefined || length > remaining) length = remaining\n\n  if ((string.length > 0 && (length < 0 || offset < 0)) || offset > this.length) {\n    throw new RangeError('attempt to write outside buffer bounds')\n  }\n\n  if (!encoding) encoding = 'utf8'\n\n  var loweredCase = false\n  for (;;) {\n    switch (encoding) {\n      case 'hex':\n        return hexWrite(this, string, offset, length)\n\n      case 'utf8':\n      case 'utf-8':\n        return utf8Write(this, string, offset, length)\n\n      case 'ascii':\n        return asciiWrite(this, string, offset, length)\n\n      case 'binary':\n        return binaryWrite(this, string, offset, length)\n\n      case 'base64':\n        // Warning: maxLength not taken into account in base64Write\n        return base64Write(this, string, offset, length)\n\n      case 'ucs2':\n      case 'ucs-2':\n      case 'utf16le':\n      case 'utf-16le':\n        return ucs2Write(this, string, offset, length)\n\n      default:\n        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)\n        encoding = ('' + encoding).toLowerCase()\n        loweredCase = true\n    }\n  }\n}\n\nBuffer.prototype.toJSON = function toJSON () {\n  return {\n    type: 'Buffer',\n    data: Array.prototype.slice.call(this._arr || this, 0)\n  }\n}\n\nfunction base64Slice (buf, start, end) {\n  if (start === 0 && end === buf.length) {\n    return base64.fromByteArray(buf)\n  } else {\n    return base64.fromByteArray(buf.slice(start, end))\n  }\n}\n\nfunction utf8Slice (buf, start, end) {\n  end = Math.min(buf.length, end)\n  var res = []\n\n  var i = start\n  while (i < end) {\n    var firstByte = buf[i]\n    var codePoint = null\n    var bytesPerSequence = (firstByte > 0xEF) ? 4\n      : (firstByte > 0xDF) ? 3\n      : (firstByte > 0xBF) ? 2\n      : 1\n\n    if (i + bytesPerSequence <= end) {\n      var secondByte, thirdByte, fourthByte, tempCodePoint\n\n      switch (bytesPerSequence) {\n        case 1:\n          if (firstByte < 0x80) {\n            codePoint = firstByte\n          }\n          break\n        case 2:\n          secondByte = buf[i + 1]\n          if ((secondByte & 0xC0) === 0x80) {\n            tempCodePoint = (firstByte & 0x1F) << 0x6 | (secondByte & 0x3F)\n            if (tempCodePoint > 0x7F) {\n              codePoint = tempCodePoint\n            }\n          }\n          break\n        case 3:\n          secondByte = buf[i + 1]\n          thirdByte = buf[i + 2]\n          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80) {\n            tempCodePoint = (firstByte & 0xF) << 0xC | (secondByte & 0x3F) << 0x6 | (thirdByte & 0x3F)\n            if (tempCodePoint > 0x7FF && (tempCodePoint < 0xD800 || tempCodePoint > 0xDFFF)) {\n              codePoint = tempCodePoint\n            }\n          }\n          break\n        case 4:\n          secondByte = buf[i + 1]\n          thirdByte = buf[i + 2]\n          fourthByte = buf[i + 3]\n          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80 && (fourthByte & 0xC0) === 0x80) {\n            tempCodePoint = (firstByte & 0xF) << 0x12 | (secondByte & 0x3F) << 0xC | (thirdByte & 0x3F) << 0x6 | (fourthByte & 0x3F)\n            if (tempCodePoint > 0xFFFF && tempCodePoint < 0x110000) {\n              codePoint = tempCodePoint\n            }\n          }\n      }\n    }\n\n    if (codePoint === null) {\n      // we did not generate a valid codePoint so insert a\n      // replacement char (U+FFFD) and advance only 1 byte\n      codePoint = 0xFFFD\n      bytesPerSequence = 1\n    } else if (codePoint > 0xFFFF) {\n      // encode to utf16 (surrogate pair dance)\n      codePoint -= 0x10000\n      res.push(codePoint >>> 10 & 0x3FF | 0xD800)\n      codePoint = 0xDC00 | codePoint & 0x3FF\n    }\n\n    res.push(codePoint)\n    i += bytesPerSequence\n  }\n\n  return decodeCodePointsArray(res)\n}\n\n// Based on http://stackoverflow.com/a/22747272/680742, the browser with\n// the lowest limit is Chrome, with 0x10000 args.\n// We go 1 magnitude less, for safety\nvar MAX_ARGUMENTS_LENGTH = 0x1000\n\nfunction decodeCodePointsArray (codePoints) {\n  var len = codePoints.length\n  if (len <= MAX_ARGUMENTS_LENGTH) {\n    return String.fromCharCode.apply(String, codePoints) // avoid extra slice()\n  }\n\n  // Decode in chunks to avoid \"call stack size exceeded\".\n  var res = ''\n  var i = 0\n  while (i < len) {\n    res += String.fromCharCode.apply(\n      String,\n      codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH)\n    )\n  }\n  return res\n}\n\nfunction asciiSlice (buf, start, end) {\n  var ret = ''\n  end = Math.min(buf.length, end)\n\n  for (var i = start; i < end; i++) {\n    ret += String.fromCharCode(buf[i] & 0x7F)\n  }\n  return ret\n}\n\nfunction binarySlice (buf, start, end) {\n  var ret = ''\n  end = Math.min(buf.length, end)\n\n  for (var i = start; i < end; i++) {\n    ret += String.fromCharCode(buf[i])\n  }\n  return ret\n}\n\nfunction hexSlice (buf, start, end) {\n  var len = buf.length\n\n  if (!start || start < 0) start = 0\n  if (!end || end < 0 || end > len) end = len\n\n  var out = ''\n  for (var i = start; i < end; i++) {\n    out += toHex(buf[i])\n  }\n  return out\n}\n\nfunction utf16leSlice (buf, start, end) {\n  var bytes = buf.slice(start, end)\n  var res = ''\n  for (var i = 0; i < bytes.length; i += 2) {\n    res += String.fromCharCode(bytes[i] + bytes[i + 1] * 256)\n  }\n  return res\n}\n\nBuffer.prototype.slice = function slice (start, end) {\n  var len = this.length\n  start = ~~start\n  end = end === undefined ? len : ~~end\n\n  if (start < 0) {\n    start += len\n    if (start < 0) start = 0\n  } else if (start > len) {\n    start = len\n  }\n\n  if (end < 0) {\n    end += len\n    if (end < 0) end = 0\n  } else if (end > len) {\n    end = len\n  }\n\n  if (end < start) end = start\n\n  var newBuf\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    newBuf = Buffer._augment(this.subarray(start, end))\n  } else {\n    var sliceLen = end - start\n    newBuf = new Buffer(sliceLen, undefined)\n    for (var i = 0; i < sliceLen; i++) {\n      newBuf[i] = this[i + start]\n    }\n  }\n\n  if (newBuf.length) newBuf.parent = this.parent || this\n\n  return newBuf\n}\n\n/*\n * Need to make sure that buffer isn't trying to write out of bounds.\n */\nfunction checkOffset (offset, ext, length) {\n  if ((offset % 1) !== 0 || offset < 0) throw new RangeError('offset is not uint')\n  if (offset + ext > length) throw new RangeError('Trying to access beyond buffer length')\n}\n\nBuffer.prototype.readUIntLE = function readUIntLE (offset, byteLength, noAssert) {\n  offset = offset | 0\n  byteLength = byteLength | 0\n  if (!noAssert) checkOffset(offset, byteLength, this.length)\n\n  var val = this[offset]\n  var mul = 1\n  var i = 0\n  while (++i < byteLength && (mul *= 0x100)) {\n    val += this[offset + i] * mul\n  }\n\n  return val\n}\n\nBuffer.prototype.readUIntBE = function readUIntBE (offset, byteLength, noAssert) {\n  offset = offset | 0\n  byteLength = byteLength | 0\n  if (!noAssert) {\n    checkOffset(offset, byteLength, this.length)\n  }\n\n  var val = this[offset + --byteLength]\n  var mul = 1\n  while (byteLength > 0 && (mul *= 0x100)) {\n    val += this[offset + --byteLength] * mul\n  }\n\n  return val\n}\n\nBuffer.prototype.readUInt8 = function readUInt8 (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 1, this.length)\n  return this[offset]\n}\n\nBuffer.prototype.readUInt16LE = function readUInt16LE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 2, this.length)\n  return this[offset] | (this[offset + 1] << 8)\n}\n\nBuffer.prototype.readUInt16BE = function readUInt16BE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 2, this.length)\n  return (this[offset] << 8) | this[offset + 1]\n}\n\nBuffer.prototype.readUInt32LE = function readUInt32LE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 4, this.length)\n\n  return ((this[offset]) |\n      (this[offset + 1] << 8) |\n      (this[offset + 2] << 16)) +\n      (this[offset + 3] * 0x1000000)\n}\n\nBuffer.prototype.readUInt32BE = function readUInt32BE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 4, this.length)\n\n  return (this[offset] * 0x1000000) +\n    ((this[offset + 1] << 16) |\n    (this[offset + 2] << 8) |\n    this[offset + 3])\n}\n\nBuffer.prototype.readIntLE = function readIntLE (offset, byteLength, noAssert) {\n  offset = offset | 0\n  byteLength = byteLength | 0\n  if (!noAssert) checkOffset(offset, byteLength, this.length)\n\n  var val = this[offset]\n  var mul = 1\n  var i = 0\n  while (++i < byteLength && (mul *= 0x100)) {\n    val += this[offset + i] * mul\n  }\n  mul *= 0x80\n\n  if (val >= mul) val -= Math.pow(2, 8 * byteLength)\n\n  return val\n}\n\nBuffer.prototype.readIntBE = function readIntBE (offset, byteLength, noAssert) {\n  offset = offset | 0\n  byteLength = byteLength | 0\n  if (!noAssert) checkOffset(offset, byteLength, this.length)\n\n  var i = byteLength\n  var mul = 1\n  var val = this[offset + --i]\n  while (i > 0 && (mul *= 0x100)) {\n    val += this[offset + --i] * mul\n  }\n  mul *= 0x80\n\n  if (val >= mul) val -= Math.pow(2, 8 * byteLength)\n\n  return val\n}\n\nBuffer.prototype.readInt8 = function readInt8 (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 1, this.length)\n  if (!(this[offset] & 0x80)) return (this[offset])\n  return ((0xff - this[offset] + 1) * -1)\n}\n\nBuffer.prototype.readInt16LE = function readInt16LE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 2, this.length)\n  var val = this[offset] | (this[offset + 1] << 8)\n  return (val & 0x8000) ? val | 0xFFFF0000 : val\n}\n\nBuffer.prototype.readInt16BE = function readInt16BE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 2, this.length)\n  var val = this[offset + 1] | (this[offset] << 8)\n  return (val & 0x8000) ? val | 0xFFFF0000 : val\n}\n\nBuffer.prototype.readInt32LE = function readInt32LE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 4, this.length)\n\n  return (this[offset]) |\n    (this[offset + 1] << 8) |\n    (this[offset + 2] << 16) |\n    (this[offset + 3] << 24)\n}\n\nBuffer.prototype.readInt32BE = function readInt32BE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 4, this.length)\n\n  return (this[offset] << 24) |\n    (this[offset + 1] << 16) |\n    (this[offset + 2] << 8) |\n    (this[offset + 3])\n}\n\nBuffer.prototype.readFloatLE = function readFloatLE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 4, this.length)\n  return ieee754.read(this, offset, true, 23, 4)\n}\n\nBuffer.prototype.readFloatBE = function readFloatBE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 4, this.length)\n  return ieee754.read(this, offset, false, 23, 4)\n}\n\nBuffer.prototype.readDoubleLE = function readDoubleLE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 8, this.length)\n  return ieee754.read(this, offset, true, 52, 8)\n}\n\nBuffer.prototype.readDoubleBE = function readDoubleBE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 8, this.length)\n  return ieee754.read(this, offset, false, 52, 8)\n}\n\nfunction checkInt (buf, value, offset, ext, max, min) {\n  if (!Buffer.isBuffer(buf)) throw new TypeError('buffer must be a Buffer instance')\n  if (value > max || value < min) throw new RangeError('value is out of bounds')\n  if (offset + ext > buf.length) throw new RangeError('index out of range')\n}\n\nBuffer.prototype.writeUIntLE = function writeUIntLE (value, offset, byteLength, noAssert) {\n  value = +value\n  offset = offset | 0\n  byteLength = byteLength | 0\n  if (!noAssert) checkInt(this, value, offset, byteLength, Math.pow(2, 8 * byteLength), 0)\n\n  var mul = 1\n  var i = 0\n  this[offset] = value & 0xFF\n  while (++i < byteLength && (mul *= 0x100)) {\n    this[offset + i] = (value / mul) & 0xFF\n  }\n\n  return offset + byteLength\n}\n\nBuffer.prototype.writeUIntBE = function writeUIntBE (value, offset, byteLength, noAssert) {\n  value = +value\n  offset = offset | 0\n  byteLength = byteLength | 0\n  if (!noAssert) checkInt(this, value, offset, byteLength, Math.pow(2, 8 * byteLength), 0)\n\n  var i = byteLength - 1\n  var mul = 1\n  this[offset + i] = value & 0xFF\n  while (--i >= 0 && (mul *= 0x100)) {\n    this[offset + i] = (value / mul) & 0xFF\n  }\n\n  return offset + byteLength\n}\n\nBuffer.prototype.writeUInt8 = function writeUInt8 (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 1, 0xff, 0)\n  if (!Buffer.TYPED_ARRAY_SUPPORT) value = Math.floor(value)\n  this[offset] = (value & 0xff)\n  return offset + 1\n}\n\nfunction objectWriteUInt16 (buf, value, offset, littleEndian) {\n  if (value < 0) value = 0xffff + value + 1\n  for (var i = 0, j = Math.min(buf.length - offset, 2); i < j; i++) {\n    buf[offset + i] = (value & (0xff << (8 * (littleEndian ? i : 1 - i)))) >>>\n      (littleEndian ? i : 1 - i) * 8\n  }\n}\n\nBuffer.prototype.writeUInt16LE = function writeUInt16LE (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    this[offset] = (value & 0xff)\n    this[offset + 1] = (value >>> 8)\n  } else {\n    objectWriteUInt16(this, value, offset, true)\n  }\n  return offset + 2\n}\n\nBuffer.prototype.writeUInt16BE = function writeUInt16BE (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    this[offset] = (value >>> 8)\n    this[offset + 1] = (value & 0xff)\n  } else {\n    objectWriteUInt16(this, value, offset, false)\n  }\n  return offset + 2\n}\n\nfunction objectWriteUInt32 (buf, value, offset, littleEndian) {\n  if (value < 0) value = 0xffffffff + value + 1\n  for (var i = 0, j = Math.min(buf.length - offset, 4); i < j; i++) {\n    buf[offset + i] = (value >>> (littleEndian ? i : 3 - i) * 8) & 0xff\n  }\n}\n\nBuffer.prototype.writeUInt32LE = function writeUInt32LE (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    this[offset + 3] = (value >>> 24)\n    this[offset + 2] = (value >>> 16)\n    this[offset + 1] = (value >>> 8)\n    this[offset] = (value & 0xff)\n  } else {\n    objectWriteUInt32(this, value, offset, true)\n  }\n  return offset + 4\n}\n\nBuffer.prototype.writeUInt32BE = function writeUInt32BE (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    this[offset] = (value >>> 24)\n    this[offset + 1] = (value >>> 16)\n    this[offset + 2] = (value >>> 8)\n    this[offset + 3] = (value & 0xff)\n  } else {\n    objectWriteUInt32(this, value, offset, false)\n  }\n  return offset + 4\n}\n\nBuffer.prototype.writeIntLE = function writeIntLE (value, offset, byteLength, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) {\n    var limit = Math.pow(2, 8 * byteLength - 1)\n\n    checkInt(this, value, offset, byteLength, limit - 1, -limit)\n  }\n\n  var i = 0\n  var mul = 1\n  var sub = value < 0 ? 1 : 0\n  this[offset] = value & 0xFF\n  while (++i < byteLength && (mul *= 0x100)) {\n    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF\n  }\n\n  return offset + byteLength\n}\n\nBuffer.prototype.writeIntBE = function writeIntBE (value, offset, byteLength, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) {\n    var limit = Math.pow(2, 8 * byteLength - 1)\n\n    checkInt(this, value, offset, byteLength, limit - 1, -limit)\n  }\n\n  var i = byteLength - 1\n  var mul = 1\n  var sub = value < 0 ? 1 : 0\n  this[offset + i] = value & 0xFF\n  while (--i >= 0 && (mul *= 0x100)) {\n    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF\n  }\n\n  return offset + byteLength\n}\n\nBuffer.prototype.writeInt8 = function writeInt8 (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 1, 0x7f, -0x80)\n  if (!Buffer.TYPED_ARRAY_SUPPORT) value = Math.floor(value)\n  if (value < 0) value = 0xff + value + 1\n  this[offset] = (value & 0xff)\n  return offset + 1\n}\n\nBuffer.prototype.writeInt16LE = function writeInt16LE (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    this[offset] = (value & 0xff)\n    this[offset + 1] = (value >>> 8)\n  } else {\n    objectWriteUInt16(this, value, offset, true)\n  }\n  return offset + 2\n}\n\nBuffer.prototype.writeInt16BE = function writeInt16BE (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    this[offset] = (value >>> 8)\n    this[offset + 1] = (value & 0xff)\n  } else {\n    objectWriteUInt16(this, value, offset, false)\n  }\n  return offset + 2\n}\n\nBuffer.prototype.writeInt32LE = function writeInt32LE (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    this[offset] = (value & 0xff)\n    this[offset + 1] = (value >>> 8)\n    this[offset + 2] = (value >>> 16)\n    this[offset + 3] = (value >>> 24)\n  } else {\n    objectWriteUInt32(this, value, offset, true)\n  }\n  return offset + 4\n}\n\nBuffer.prototype.writeInt32BE = function writeInt32BE (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)\n  if (value < 0) value = 0xffffffff + value + 1\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    this[offset] = (value >>> 24)\n    this[offset + 1] = (value >>> 16)\n    this[offset + 2] = (value >>> 8)\n    this[offset + 3] = (value & 0xff)\n  } else {\n    objectWriteUInt32(this, value, offset, false)\n  }\n  return offset + 4\n}\n\nfunction checkIEEE754 (buf, value, offset, ext, max, min) {\n  if (value > max || value < min) throw new RangeError('value is out of bounds')\n  if (offset + ext > buf.length) throw new RangeError('index out of range')\n  if (offset < 0) throw new RangeError('index out of range')\n}\n\nfunction writeFloat (buf, value, offset, littleEndian, noAssert) {\n  if (!noAssert) {\n    checkIEEE754(buf, value, offset, 4, 3.4028234663852886e+38, -3.4028234663852886e+38)\n  }\n  ieee754.write(buf, value, offset, littleEndian, 23, 4)\n  return offset + 4\n}\n\nBuffer.prototype.writeFloatLE = function writeFloatLE (value, offset, noAssert) {\n  return writeFloat(this, value, offset, true, noAssert)\n}\n\nBuffer.prototype.writeFloatBE = function writeFloatBE (value, offset, noAssert) {\n  return writeFloat(this, value, offset, false, noAssert)\n}\n\nfunction writeDouble (buf, value, offset, littleEndian, noAssert) {\n  if (!noAssert) {\n    checkIEEE754(buf, value, offset, 8, 1.7976931348623157E+308, -1.7976931348623157E+308)\n  }\n  ieee754.write(buf, value, offset, littleEndian, 52, 8)\n  return offset + 8\n}\n\nBuffer.prototype.writeDoubleLE = function writeDoubleLE (value, offset, noAssert) {\n  return writeDouble(this, value, offset, true, noAssert)\n}\n\nBuffer.prototype.writeDoubleBE = function writeDoubleBE (value, offset, noAssert) {\n  return writeDouble(this, value, offset, false, noAssert)\n}\n\n// copy(targetBuffer, targetStart=0, sourceStart=0, sourceEnd=buffer.length)\nBuffer.prototype.copy = function copy (target, targetStart, start, end) {\n  if (!start) start = 0\n  if (!end && end !== 0) end = this.length\n  if (targetStart >= target.length) targetStart = target.length\n  if (!targetStart) targetStart = 0\n  if (end > 0 && end < start) end = start\n\n  // Copy 0 bytes; we're done\n  if (end === start) return 0\n  if (target.length === 0 || this.length === 0) return 0\n\n  // Fatal error conditions\n  if (targetStart < 0) {\n    throw new RangeError('targetStart out of bounds')\n  }\n  if (start < 0 || start >= this.length) throw new RangeError('sourceStart out of bounds')\n  if (end < 0) throw new RangeError('sourceEnd out of bounds')\n\n  // Are we oob?\n  if (end > this.length) end = this.length\n  if (target.length - targetStart < end - start) {\n    end = target.length - targetStart + start\n  }\n\n  var len = end - start\n  var i\n\n  if (this === target && start < targetStart && targetStart < end) {\n    // descending copy from end\n    for (i = len - 1; i >= 0; i--) {\n      target[i + targetStart] = this[i + start]\n    }\n  } else if (len < 1000 || !Buffer.TYPED_ARRAY_SUPPORT) {\n    // ascending copy from start\n    for (i = 0; i < len; i++) {\n      target[i + targetStart] = this[i + start]\n    }\n  } else {\n    target._set(this.subarray(start, start + len), targetStart)\n  }\n\n  return len\n}\n\n// fill(value, start=0, end=buffer.length)\nBuffer.prototype.fill = function fill (value, start, end) {\n  if (!value) value = 0\n  if (!start) start = 0\n  if (!end) end = this.length\n\n  if (end < start) throw new RangeError('end < start')\n\n  // Fill 0 bytes; we're done\n  if (end === start) return\n  if (this.length === 0) return\n\n  if (start < 0 || start >= this.length) throw new RangeError('start out of bounds')\n  if (end < 0 || end > this.length) throw new RangeError('end out of bounds')\n\n  var i\n  if (typeof value === 'number') {\n    for (i = start; i < end; i++) {\n      this[i] = value\n    }\n  } else {\n    var bytes = utf8ToBytes(value.toString())\n    var len = bytes.length\n    for (i = start; i < end; i++) {\n      this[i] = bytes[i % len]\n    }\n  }\n\n  return this\n}\n\n/**\n * Creates a new `ArrayBuffer` with the *copied* memory of the buffer instance.\n * Added in Node 0.12. Only available in browsers that support ArrayBuffer.\n */\nBuffer.prototype.toArrayBuffer = function toArrayBuffer () {\n  if (typeof Uint8Array !== 'undefined') {\n    if (Buffer.TYPED_ARRAY_SUPPORT) {\n      return (new Buffer(this)).buffer\n    } else {\n      var buf = new Uint8Array(this.length)\n      for (var i = 0, len = buf.length; i < len; i += 1) {\n        buf[i] = this[i]\n      }\n      return buf.buffer\n    }\n  } else {\n    throw new TypeError('Buffer.toArrayBuffer not supported in this browser')\n  }\n}\n\n// HELPER FUNCTIONS\n// ================\n\nvar BP = Buffer.prototype\n\n/**\n * Augment a Uint8Array *instance* (not the Uint8Array class!) with Buffer methods\n */\nBuffer._augment = function _augment (arr) {\n  arr.constructor = Buffer\n  arr._isBuffer = true\n\n  // save reference to original Uint8Array set method before overwriting\n  arr._set = arr.set\n\n  // deprecated\n  arr.get = BP.get\n  arr.set = BP.set\n\n  arr.write = BP.write\n  arr.toString = BP.toString\n  arr.toLocaleString = BP.toString\n  arr.toJSON = BP.toJSON\n  arr.equals = BP.equals\n  arr.compare = BP.compare\n  arr.indexOf = BP.indexOf\n  arr.copy = BP.copy\n  arr.slice = BP.slice\n  arr.readUIntLE = BP.readUIntLE\n  arr.readUIntBE = BP.readUIntBE\n  arr.readUInt8 = BP.readUInt8\n  arr.readUInt16LE = BP.readUInt16LE\n  arr.readUInt16BE = BP.readUInt16BE\n  arr.readUInt32LE = BP.readUInt32LE\n  arr.readUInt32BE = BP.readUInt32BE\n  arr.readIntLE = BP.readIntLE\n  arr.readIntBE = BP.readIntBE\n  arr.readInt8 = BP.readInt8\n  arr.readInt16LE = BP.readInt16LE\n  arr.readInt16BE = BP.readInt16BE\n  arr.readInt32LE = BP.readInt32LE\n  arr.readInt32BE = BP.readInt32BE\n  arr.readFloatLE = BP.readFloatLE\n  arr.readFloatBE = BP.readFloatBE\n  arr.readDoubleLE = BP.readDoubleLE\n  arr.readDoubleBE = BP.readDoubleBE\n  arr.writeUInt8 = BP.writeUInt8\n  arr.writeUIntLE = BP.writeUIntLE\n  arr.writeUIntBE = BP.writeUIntBE\n  arr.writeUInt16LE = BP.writeUInt16LE\n  arr.writeUInt16BE = BP.writeUInt16BE\n  arr.writeUInt32LE = BP.writeUInt32LE\n  arr.writeUInt32BE = BP.writeUInt32BE\n  arr.writeIntLE = BP.writeIntLE\n  arr.writeIntBE = BP.writeIntBE\n  arr.writeInt8 = BP.writeInt8\n  arr.writeInt16LE = BP.writeInt16LE\n  arr.writeInt16BE = BP.writeInt16BE\n  arr.writeInt32LE = BP.writeInt32LE\n  arr.writeInt32BE = BP.writeInt32BE\n  arr.writeFloatLE = BP.writeFloatLE\n  arr.writeFloatBE = BP.writeFloatBE\n  arr.writeDoubleLE = BP.writeDoubleLE\n  arr.writeDoubleBE = BP.writeDoubleBE\n  arr.fill = BP.fill\n  arr.inspect = BP.inspect\n  arr.toArrayBuffer = BP.toArrayBuffer\n\n  return arr\n}\n\nvar INVALID_BASE64_RE = /[^+\\/0-9A-Za-z-_]/g\n\nfunction base64clean (str) {\n  // Node strips out invalid characters like \\n and \\t from the string, base64-js does not\n  str = stringtrim(str).replace(INVALID_BASE64_RE, '')\n  // Node converts strings with length < 2 to ''\n  if (str.length < 2) return ''\n  // Node allows for non-padded base64 strings (missing trailing ===), base64-js does not\n  while (str.length % 4 !== 0) {\n    str = str + '='\n  }\n  return str\n}\n\nfunction stringtrim (str) {\n  if (str.trim) return str.trim()\n  return str.replace(/^\\s+|\\s+$/g, '')\n}\n\nfunction toHex (n) {\n  if (n < 16) return '0' + n.toString(16)\n  return n.toString(16)\n}\n\nfunction utf8ToBytes (string, units) {\n  units = units || Infinity\n  var codePoint\n  var length = string.length\n  var leadSurrogate = null\n  var bytes = []\n\n  for (var i = 0; i < length; i++) {\n    codePoint = string.charCodeAt(i)\n\n    // is surrogate component\n    if (codePoint > 0xD7FF && codePoint < 0xE000) {\n      // last char was a lead\n      if (!leadSurrogate) {\n        // no lead yet\n        if (codePoint > 0xDBFF) {\n          // unexpected trail\n          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)\n          continue\n        } else if (i + 1 === length) {\n          // unpaired lead\n          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)\n          continue\n        }\n\n        // valid lead\n        leadSurrogate = codePoint\n\n        continue\n      }\n\n      // 2 leads in a row\n      if (codePoint < 0xDC00) {\n        if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)\n        leadSurrogate = codePoint\n        continue\n      }\n\n      // valid surrogate pair\n      codePoint = (leadSurrogate - 0xD800 << 10 | codePoint - 0xDC00) + 0x10000\n    } else if (leadSurrogate) {\n      // valid bmp char, but last char was a lead\n      if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)\n    }\n\n    leadSurrogate = null\n\n    // encode utf8\n    if (codePoint < 0x80) {\n      if ((units -= 1) < 0) break\n      bytes.push(codePoint)\n    } else if (codePoint < 0x800) {\n      if ((units -= 2) < 0) break\n      bytes.push(\n        codePoint >> 0x6 | 0xC0,\n        codePoint & 0x3F | 0x80\n      )\n    } else if (codePoint < 0x10000) {\n      if ((units -= 3) < 0) break\n      bytes.push(\n        codePoint >> 0xC | 0xE0,\n        codePoint >> 0x6 & 0x3F | 0x80,\n        codePoint & 0x3F | 0x80\n      )\n    } else if (codePoint < 0x110000) {\n      if ((units -= 4) < 0) break\n      bytes.push(\n        codePoint >> 0x12 | 0xF0,\n        codePoint >> 0xC & 0x3F | 0x80,\n        codePoint >> 0x6 & 0x3F | 0x80,\n        codePoint & 0x3F | 0x80\n      )\n    } else {\n      throw new Error('Invalid code point')\n    }\n  }\n\n  return bytes\n}\n\nfunction asciiToBytes (str) {\n  var byteArray = []\n  for (var i = 0; i < str.length; i++) {\n    // Node's code seems to be doing this and not & 0x7F..\n    byteArray.push(str.charCodeAt(i) & 0xFF)\n  }\n  return byteArray\n}\n\nfunction utf16leToBytes (str, units) {\n  var c, hi, lo\n  var byteArray = []\n  for (var i = 0; i < str.length; i++) {\n    if ((units -= 2) < 0) break\n\n    c = str.charCodeAt(i)\n    hi = c >> 8\n    lo = c % 256\n    byteArray.push(lo)\n    byteArray.push(hi)\n  }\n\n  return byteArray\n}\n\nfunction base64ToBytes (str) {\n  return base64.toByteArray(base64clean(str))\n}\n\nfunction blitBuffer (src, dst, offset, length) {\n  for (var i = 0; i < length; i++) {\n    if ((i + offset >= dst.length) || (i >= src.length)) break\n    dst[i + offset] = src[i]\n  }\n  return i\n}\n\n}).call(this,typeof global !== \"undefined\" ? global : typeof self !== \"undefined\" ? self : typeof window !== \"undefined\" ? window : {})\n\n},{\"base64-js\":4,\"ieee754\":5,\"isarray\":6}],4:[function(require,module,exports){\nvar lookup = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';\n\n;(function (exports) {\n\t'use strict';\n\n  var Arr = (typeof Uint8Array !== 'undefined')\n    ? Uint8Array\n    : Array\n\n\tvar PLUS   = '+'.charCodeAt(0)\n\tvar SLASH  = '/'.charCodeAt(0)\n\tvar NUMBER = '0'.charCodeAt(0)\n\tvar LOWER  = 'a'.charCodeAt(0)\n\tvar UPPER  = 'A'.charCodeAt(0)\n\tvar PLUS_URL_SAFE = '-'.charCodeAt(0)\n\tvar SLASH_URL_SAFE = '_'.charCodeAt(0)\n\n\tfunction decode (elt) {\n\t\tvar code = elt.charCodeAt(0)\n\t\tif (code === PLUS ||\n\t\t    code === PLUS_URL_SAFE)\n\t\t\treturn 62 // '+'\n\t\tif (code === SLASH ||\n\t\t    code === SLASH_URL_SAFE)\n\t\t\treturn 63 // '/'\n\t\tif (code < NUMBER)\n\t\t\treturn -1 //no match\n\t\tif (code < NUMBER + 10)\n\t\t\treturn code - NUMBER + 26 + 26\n\t\tif (code < UPPER + 26)\n\t\t\treturn code - UPPER\n\t\tif (code < LOWER + 26)\n\t\t\treturn code - LOWER + 26\n\t}\n\n\tfunction b64ToByteArray (b64) {\n\t\tvar i, j, l, tmp, placeHolders, arr\n\n\t\tif (b64.length % 4 > 0) {\n\t\t\tthrow new Error('Invalid string. Length must be a multiple of 4')\n\t\t}\n\n\t\t// the number of equal signs (place holders)\n\t\t// if there are two placeholders, than the two characters before it\n\t\t// represent one byte\n\t\t// if there is only one, then the three characters before it represent 2 bytes\n\t\t// this is just a cheap hack to not do indexOf twice\n\t\tvar len = b64.length\n\t\tplaceHolders = '=' === b64.charAt(len - 2) ? 2 : '=' === b64.charAt(len - 1) ? 1 : 0\n\n\t\t// base64 is 4/3 + up to two characters of the original data\n\t\tarr = new Arr(b64.length * 3 / 4 - placeHolders)\n\n\t\t// if there are placeholders, only get up to the last complete 4 chars\n\t\tl = placeHolders > 0 ? b64.length - 4 : b64.length\n\n\t\tvar L = 0\n\n\t\tfunction push (v) {\n\t\t\tarr[L++] = v\n\t\t}\n\n\t\tfor (i = 0, j = 0; i < l; i += 4, j += 3) {\n\t\t\ttmp = (decode(b64.charAt(i)) << 18) | (decode(b64.charAt(i + 1)) << 12) | (decode(b64.charAt(i + 2)) << 6) | decode(b64.charAt(i + 3))\n\t\t\tpush((tmp & 0xFF0000) >> 16)\n\t\t\tpush((tmp & 0xFF00) >> 8)\n\t\t\tpush(tmp & 0xFF)\n\t\t}\n\n\t\tif (placeHolders === 2) {\n\t\t\ttmp = (decode(b64.charAt(i)) << 2) | (decode(b64.charAt(i + 1)) >> 4)\n\t\t\tpush(tmp & 0xFF)\n\t\t} else if (placeHolders === 1) {\n\t\t\ttmp = (decode(b64.charAt(i)) << 10) | (decode(b64.charAt(i + 1)) << 4) | (decode(b64.charAt(i + 2)) >> 2)\n\t\t\tpush((tmp >> 8) & 0xFF)\n\t\t\tpush(tmp & 0xFF)\n\t\t}\n\n\t\treturn arr\n\t}\n\n\tfunction uint8ToBase64 (uint8) {\n\t\tvar i,\n\t\t\textraBytes = uint8.length % 3, // if we have 1 byte left, pad 2 bytes\n\t\t\toutput = \"\",\n\t\t\ttemp, length\n\n\t\tfunction encode (num) {\n\t\t\treturn lookup.charAt(num)\n\t\t}\n\n\t\tfunction tripletToBase64 (num) {\n\t\t\treturn encode(num >> 18 & 0x3F) + encode(num >> 12 & 0x3F) + encode(num >> 6 & 0x3F) + encode(num & 0x3F)\n\t\t}\n\n\t\t// go through the array every three bytes, we'll deal with trailing stuff later\n\t\tfor (i = 0, length = uint8.length - extraBytes; i < length; i += 3) {\n\t\t\ttemp = (uint8[i] << 16) + (uint8[i + 1] << 8) + (uint8[i + 2])\n\t\t\toutput += tripletToBase64(temp)\n\t\t}\n\n\t\t// pad the end with zeros, but make sure to not forget the extra bytes\n\t\tswitch (extraBytes) {\n\t\t\tcase 1:\n\t\t\t\ttemp = uint8[uint8.length - 1]\n\t\t\t\toutput += encode(temp >> 2)\n\t\t\t\toutput += encode((temp << 4) & 0x3F)\n\t\t\t\toutput += '=='\n\t\t\t\tbreak\n\t\t\tcase 2:\n\t\t\t\ttemp = (uint8[uint8.length - 2] << 8) + (uint8[uint8.length - 1])\n\t\t\t\toutput += encode(temp >> 10)\n\t\t\t\toutput += encode((temp >> 4) & 0x3F)\n\t\t\t\toutput += encode((temp << 2) & 0x3F)\n\t\t\t\toutput += '='\n\t\t\t\tbreak\n\t\t}\n\n\t\treturn output\n\t}\n\n\texports.toByteArray = b64ToByteArray\n\texports.fromByteArray = uint8ToBase64\n}(typeof exports === 'undefined' ? (this.base64js = {}) : exports))\n\n},{}],5:[function(require,module,exports){\nexports.read = function (buffer, offset, isLE, mLen, nBytes) {\n  var e, m\n  var eLen = nBytes * 8 - mLen - 1\n  var eMax = (1 << eLen) - 1\n  var eBias = eMax >> 1\n  var nBits = -7\n  var i = isLE ? (nBytes - 1) : 0\n  var d = isLE ? -1 : 1\n  var s = buffer[offset + i]\n\n  i += d\n\n  e = s & ((1 << (-nBits)) - 1)\n  s >>= (-nBits)\n  nBits += eLen\n  for (; nBits > 0; e = e * 256 + buffer[offset + i], i += d, nBits -= 8) {}\n\n  m = e & ((1 << (-nBits)) - 1)\n  e >>= (-nBits)\n  nBits += mLen\n  for (; nBits > 0; m = m * 256 + buffer[offset + i], i += d, nBits -= 8) {}\n\n  if (e === 0) {\n    e = 1 - eBias\n  } else if (e === eMax) {\n    return m ? NaN : ((s ? -1 : 1) * Infinity)\n  } else {\n    m = m + Math.pow(2, mLen)\n    e = e - eBias\n  }\n  return (s ? -1 : 1) * m * Math.pow(2, e - mLen)\n}\n\nexports.write = function (buffer, value, offset, isLE, mLen, nBytes) {\n  var e, m, c\n  var eLen = nBytes * 8 - mLen - 1\n  var eMax = (1 << eLen) - 1\n  var eBias = eMax >> 1\n  var rt = (mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0)\n  var i = isLE ? 0 : (nBytes - 1)\n  var d = isLE ? 1 : -1\n  var s = value < 0 || (value === 0 && 1 / value < 0) ? 1 : 0\n\n  value = Math.abs(value)\n\n  if (isNaN(value) || value === Infinity) {\n    m = isNaN(value) ? 1 : 0\n    e = eMax\n  } else {\n    e = Math.floor(Math.log(value) / Math.LN2)\n    if (value * (c = Math.pow(2, -e)) < 1) {\n      e--\n      c *= 2\n    }\n    if (e + eBias >= 1) {\n      value += rt / c\n    } else {\n      value += rt * Math.pow(2, 1 - eBias)\n    }\n    if (value * c >= 2) {\n      e++\n      c /= 2\n    }\n\n    if (e + eBias >= eMax) {\n      m = 0\n      e = eMax\n    } else if (e + eBias >= 1) {\n      m = (value * c - 1) * Math.pow(2, mLen)\n      e = e + eBias\n    } else {\n      m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen)\n      e = 0\n    }\n  }\n\n  for (; mLen >= 8; buffer[offset + i] = m & 0xff, i += d, m /= 256, mLen -= 8) {}\n\n  e = (e << mLen) | m\n  eLen += mLen\n  for (; eLen > 0; buffer[offset + i] = e & 0xff, i += d, e /= 256, eLen -= 8) {}\n\n  buffer[offset + i - d] |= s * 128\n}\n\n},{}],6:[function(require,module,exports){\nvar toString = {}.toString;\n\nmodule.exports = Array.isArray || function (arr) {\n  return toString.call(arr) == '[object Array]';\n};\n\n},{}],7:[function(require,module,exports){\n// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\nfunction EventEmitter() {\n  this._events = this._events || {};\n  this._maxListeners = this._maxListeners || undefined;\n}\nmodule.exports = EventEmitter;\n\n// Backwards-compat with node 0.10.x\nEventEmitter.EventEmitter = EventEmitter;\n\nEventEmitter.prototype._events = undefined;\nEventEmitter.prototype._maxListeners = undefined;\n\n// By default EventEmitters will print a warning if more than 10 listeners are\n// added to it. This is a useful default which helps finding memory leaks.\nEventEmitter.defaultMaxListeners = 10;\n\n// Obviously not all Emitters should be limited to 10. This function allows\n// that to be increased. Set to zero for unlimited.\nEventEmitter.prototype.setMaxListeners = function(n) {\n  if (!isNumber(n) || n < 0 || isNaN(n))\n    throw TypeError('n must be a positive number');\n  this._maxListeners = n;\n  return this;\n};\n\nEventEmitter.prototype.emit = function(type) {\n  var er, handler, len, args, i, listeners;\n\n  if (!this._events)\n    this._events = {};\n\n  // If there is no 'error' event listener then throw.\n  if (type === 'error') {\n    if (!this._events.error ||\n        (isObject(this._events.error) && !this._events.error.length)) {\n      er = arguments[1];\n      if (er instanceof Error) {\n        throw er; // Unhandled 'error' event\n      }\n      throw TypeError('Uncaught, unspecified \"error\" event.');\n    }\n  }\n\n  handler = this._events[type];\n\n  if (isUndefined(handler))\n    return false;\n\n  if (isFunction(handler)) {\n    switch (arguments.length) {\n      // fast cases\n      case 1:\n        handler.call(this);\n        break;\n      case 2:\n        handler.call(this, arguments[1]);\n        break;\n      case 3:\n        handler.call(this, arguments[1], arguments[2]);\n        break;\n      // slower\n      default:\n        args = Array.prototype.slice.call(arguments, 1);\n        handler.apply(this, args);\n    }\n  } else if (isObject(handler)) {\n    args = Array.prototype.slice.call(arguments, 1);\n    listeners = handler.slice();\n    len = listeners.length;\n    for (i = 0; i < len; i++)\n      listeners[i].apply(this, args);\n  }\n\n  return true;\n};\n\nEventEmitter.prototype.addListener = function(type, listener) {\n  var m;\n\n  if (!isFunction(listener))\n    throw TypeError('listener must be a function');\n\n  if (!this._events)\n    this._events = {};\n\n  // To avoid recursion in the case that type === \"newListener\"! Before\n  // adding it to the listeners, first emit \"newListener\".\n  if (this._events.newListener)\n    this.emit('newListener', type,\n              isFunction(listener.listener) ?\n              listener.listener : listener);\n\n  if (!this._events[type])\n    // Optimize the case of one listener. Don't need the extra array object.\n    this._events[type] = listener;\n  else if (isObject(this._events[type]))\n    // If we've already got an array, just append.\n    this._events[type].push(listener);\n  else\n    // Adding the second element, need to change to array.\n    this._events[type] = [this._events[type], listener];\n\n  // Check for listener leak\n  if (isObject(this._events[type]) && !this._events[type].warned) {\n    if (!isUndefined(this._maxListeners)) {\n      m = this._maxListeners;\n    } else {\n      m = EventEmitter.defaultMaxListeners;\n    }\n\n    if (m && m > 0 && this._events[type].length > m) {\n      this._events[type].warned = true;\n      console.error('(node) warning: possible EventEmitter memory ' +\n                    'leak detected. %d listeners added. ' +\n                    'Use emitter.setMaxListeners() to increase limit.',\n                    this._events[type].length);\n      if (typeof console.trace === 'function') {\n        // not supported in IE 10\n        console.trace();\n      }\n    }\n  }\n\n  return this;\n};\n\nEventEmitter.prototype.on = EventEmitter.prototype.addListener;\n\nEventEmitter.prototype.once = function(type, listener) {\n  if (!isFunction(listener))\n    throw TypeError('listener must be a function');\n\n  var fired = false;\n\n  function g() {\n    this.removeListener(type, g);\n\n    if (!fired) {\n      fired = true;\n      listener.apply(this, arguments);\n    }\n  }\n\n  g.listener = listener;\n  this.on(type, g);\n\n  return this;\n};\n\n// emits a 'removeListener' event iff the listener was removed\nEventEmitter.prototype.removeListener = function(type, listener) {\n  var list, position, length, i;\n\n  if (!isFunction(listener))\n    throw TypeError('listener must be a function');\n\n  if (!this._events || !this._events[type])\n    return this;\n\n  list = this._events[type];\n  length = list.length;\n  position = -1;\n\n  if (list === listener ||\n      (isFunction(list.listener) && list.listener === listener)) {\n    delete this._events[type];\n    if (this._events.removeListener)\n      this.emit('removeListener', type, listener);\n\n  } else if (isObject(list)) {\n    for (i = length; i-- > 0;) {\n      if (list[i] === listener ||\n          (list[i].listener && list[i].listener === listener)) {\n        position = i;\n        break;\n      }\n    }\n\n    if (position < 0)\n      return this;\n\n    if (list.length === 1) {\n      list.length = 0;\n      delete this._events[type];\n    } else {\n      list.splice(position, 1);\n    }\n\n    if (this._events.removeListener)\n      this.emit('removeListener', type, listener);\n  }\n\n  return this;\n};\n\nEventEmitter.prototype.removeAllListeners = function(type) {\n  var key, listeners;\n\n  if (!this._events)\n    return this;\n\n  // not listening for removeListener, no need to emit\n  if (!this._events.removeListener) {\n    if (arguments.length === 0)\n      this._events = {};\n    else if (this._events[type])\n      delete this._events[type];\n    return this;\n  }\n\n  // emit removeListener for all listeners on all events\n  if (arguments.length === 0) {\n    for (key in this._events) {\n      if (key === 'removeListener') continue;\n      this.removeAllListeners(key);\n    }\n    this.removeAllListeners('removeListener');\n    this._events = {};\n    return this;\n  }\n\n  listeners = this._events[type];\n\n  if (isFunction(listeners)) {\n    this.removeListener(type, listeners);\n  } else if (listeners) {\n    // LIFO order\n    while (listeners.length)\n      this.removeListener(type, listeners[listeners.length - 1]);\n  }\n  delete this._events[type];\n\n  return this;\n};\n\nEventEmitter.prototype.listeners = function(type) {\n  var ret;\n  if (!this._events || !this._events[type])\n    ret = [];\n  else if (isFunction(this._events[type]))\n    ret = [this._events[type]];\n  else\n    ret = this._events[type].slice();\n  return ret;\n};\n\nEventEmitter.prototype.listenerCount = function(type) {\n  if (this._events) {\n    var evlistener = this._events[type];\n\n    if (isFunction(evlistener))\n      return 1;\n    else if (evlistener)\n      return evlistener.length;\n  }\n  return 0;\n};\n\nEventEmitter.listenerCount = function(emitter, type) {\n  return emitter.listenerCount(type);\n};\n\nfunction isFunction(arg) {\n  return typeof arg === 'function';\n}\n\nfunction isNumber(arg) {\n  return typeof arg === 'number';\n}\n\nfunction isObject(arg) {\n  return typeof arg === 'object' && arg !== null;\n}\n\nfunction isUndefined(arg) {\n  return arg === void 0;\n}\n\n},{}],8:[function(require,module,exports){\nvar http = require('http');\n\nvar https = module.exports;\n\nfor (var key in http) {\n    if (http.hasOwnProperty(key)) https[key] = http[key];\n};\n\nhttps.request = function (params, cb) {\n    if (!params) params = {};\n    params.scheme = 'https';\n    params.protocol = 'https:';\n    return http.request.call(this, params, cb);\n}\n\n},{\"http\":31}],9:[function(require,module,exports){\nif (typeof Object.create === 'function') {\n  // implementation from standard node.js 'util' module\n  module.exports = function inherits(ctor, superCtor) {\n    ctor.super_ = superCtor\n    ctor.prototype = Object.create(superCtor.prototype, {\n      constructor: {\n        value: ctor,\n        enumerable: false,\n        writable: true,\n        configurable: true\n      }\n    });\n  };\n} else {\n  // old school shim for old browsers\n  module.exports = function inherits(ctor, superCtor) {\n    ctor.super_ = superCtor\n    var TempCtor = function () {}\n    TempCtor.prototype = superCtor.prototype\n    ctor.prototype = new TempCtor()\n    ctor.prototype.constructor = ctor\n  }\n}\n\n},{}],10:[function(require,module,exports){\n/**\n * Determine if an object is Buffer\n *\n * Author:   Feross Aboukhadijeh <feross@feross.org> <http://feross.org>\n * License:  MIT\n *\n * `npm install is-buffer`\n */\n\nmodule.exports = function (obj) {\n  return !!(obj != null &&\n    (obj._isBuffer || // For Safari 5-7 (missing Object.prototype.constructor)\n      (obj.constructor &&\n      typeof obj.constructor.isBuffer === 'function' &&\n      obj.constructor.isBuffer(obj))\n    ))\n}\n\n},{}],11:[function(require,module,exports){\nmodule.exports = Array.isArray || function (arr) {\n  return Object.prototype.toString.call(arr) == '[object Array]';\n};\n\n},{}],12:[function(require,module,exports){\n// shim for using process in browser\n\nvar process = module.exports = {};\nvar queue = [];\nvar draining = false;\nvar currentQueue;\nvar queueIndex = -1;\n\nfunction cleanUpNextTick() {\n    draining = false;\n    if (currentQueue.length) {\n        queue = currentQueue.concat(queue);\n    } else {\n        queueIndex = -1;\n    }\n    if (queue.length) {\n        drainQueue();\n    }\n}\n\nfunction drainQueue() {\n    if (draining) {\n        return;\n    }\n    var timeout = setTimeout(cleanUpNextTick);\n    draining = true;\n\n    var len = queue.length;\n    while(len) {\n        currentQueue = queue;\n        queue = [];\n        while (++queueIndex < len) {\n            if (currentQueue) {\n                currentQueue[queueIndex].run();\n            }\n        }\n        queueIndex = -1;\n        len = queue.length;\n    }\n    currentQueue = null;\n    draining = false;\n    clearTimeout(timeout);\n}\n\nprocess.nextTick = function (fun) {\n    var args = new Array(arguments.length - 1);\n    if (arguments.length > 1) {\n        for (var i = 1; i < arguments.length; i++) {\n            args[i - 1] = arguments[i];\n        }\n    }\n    queue.push(new Item(fun, args));\n    if (queue.length === 1 && !draining) {\n        setTimeout(drainQueue, 0);\n    }\n};\n\n// v8 likes predictible objects\nfunction Item(fun, array) {\n    this.fun = fun;\n    this.array = array;\n}\nItem.prototype.run = function () {\n    this.fun.apply(null, this.array);\n};\nprocess.title = 'browser';\nprocess.browser = true;\nprocess.env = {};\nprocess.argv = [];\nprocess.version = ''; // empty string to avoid regexp issues\nprocess.versions = {};\n\nfunction noop() {}\n\nprocess.on = noop;\nprocess.addListener = noop;\nprocess.once = noop;\nprocess.off = noop;\nprocess.removeListener = noop;\nprocess.removeAllListeners = noop;\nprocess.emit = noop;\n\nprocess.binding = function (name) {\n    throw new Error('process.binding is not supported');\n};\n\nprocess.cwd = function () { return '/' };\nprocess.chdir = function (dir) {\n    throw new Error('process.chdir is not supported');\n};\nprocess.umask = function() { return 0; };\n\n},{}],13:[function(require,module,exports){\n(function (global){\n/*! https://mths.be/punycode v1.4.0 by @mathias */\n;(function(root) {\n\n\t/** Detect free variables */\n\tvar freeExports = typeof exports == 'object' && exports &&\n\t\t!exports.nodeType && exports;\n\tvar freeModule = typeof module == 'object' && module &&\n\t\t!module.nodeType && module;\n\tvar freeGlobal = typeof global == 'object' && global;\n\tif (\n\t\tfreeGlobal.global === freeGlobal ||\n\t\tfreeGlobal.window === freeGlobal ||\n\t\tfreeGlobal.self === freeGlobal\n\t) {\n\t\troot = freeGlobal;\n\t}\n\n\t/**\n\t * The `punycode` object.\n\t * @name punycode\n\t * @type Object\n\t */\n\tvar punycode,\n\n\t/** Highest positive signed 32-bit float value */\n\tmaxInt = 2147483647, // aka. 0x7FFFFFFF or 2^31-1\n\n\t/** Bootstring parameters */\n\tbase = 36,\n\ttMin = 1,\n\ttMax = 26,\n\tskew = 38,\n\tdamp = 700,\n\tinitialBias = 72,\n\tinitialN = 128, // 0x80\n\tdelimiter = '-', // '\\x2D'\n\n\t/** Regular expressions */\n\tregexPunycode = /^xn--/,\n\tregexNonASCII = /[^\\x20-\\x7E]/, // unprintable ASCII chars + non-ASCII chars\n\tregexSeparators = /[\\x2E\\u3002\\uFF0E\\uFF61]/g, // RFC 3490 separators\n\n\t/** Error messages */\n\terrors = {\n\t\t'overflow': 'Overflow: input needs wider integers to process',\n\t\t'not-basic': 'Illegal input >= 0x80 (not a basic code point)',\n\t\t'invalid-input': 'Invalid input'\n\t},\n\n\t/** Convenience shortcuts */\n\tbaseMinusTMin = base - tMin,\n\tfloor = Math.floor,\n\tstringFromCharCode = String.fromCharCode,\n\n\t/** Temporary variable */\n\tkey;\n\n\t/*--------------------------------------------------------------------------*/\n\n\t/**\n\t * A generic error utility function.\n\t * @private\n\t * @param {String} type The error type.\n\t * @returns {Error} Throws a `RangeError` with the applicable error message.\n\t */\n\tfunction error(type) {\n\t\tthrow new RangeError(errors[type]);\n\t}\n\n\t/**\n\t * A generic `Array#map` utility function.\n\t * @private\n\t * @param {Array} array The array to iterate over.\n\t * @param {Function} callback The function that gets called for every array\n\t * item.\n\t * @returns {Array} A new array of values returned by the callback function.\n\t */\n\tfunction map(array, fn) {\n\t\tvar length = array.length;\n\t\tvar result = [];\n\t\twhile (length--) {\n\t\t\tresult[length] = fn(array[length]);\n\t\t}\n\t\treturn result;\n\t}\n\n\t/**\n\t * A simple `Array#map`-like wrapper to work with domain name strings or email\n\t * addresses.\n\t * @private\n\t * @param {String} domain The domain name or email address.\n\t * @param {Function} callback The function that gets called for every\n\t * character.\n\t * @returns {Array} A new string of characters returned by the callback\n\t * function.\n\t */\n\tfunction mapDomain(string, fn) {\n\t\tvar parts = string.split('@');\n\t\tvar result = '';\n\t\tif (parts.length > 1) {\n\t\t\t// In email addresses, only the domain name should be punycoded. Leave\n\t\t\t// the local part (i.e. everything up to `@`) intact.\n\t\t\tresult = parts[0] + '@';\n\t\t\tstring = parts[1];\n\t\t}\n\t\t// Avoid `split(regex)` for IE8 compatibility. See #17.\n\t\tstring = string.replace(regexSeparators, '\\x2E');\n\t\tvar labels = string.split('.');\n\t\tvar encoded = map(labels, fn).join('.');\n\t\treturn result + encoded;\n\t}\n\n\t/**\n\t * Creates an array containing the numeric code points of each Unicode\n\t * character in the string. While JavaScript uses UCS-2 internally,\n\t * this function will convert a pair of surrogate halves (each of which\n\t * UCS-2 exposes as separate characters) into a single code point,\n\t * matching UTF-16.\n\t * @see `punycode.ucs2.encode`\n\t * @see <https://mathiasbynens.be/notes/javascript-encoding>\n\t * @memberOf punycode.ucs2\n\t * @name decode\n\t * @param {String} string The Unicode input string (UCS-2).\n\t * @returns {Array} The new array of code points.\n\t */\n\tfunction ucs2decode(string) {\n\t\tvar output = [],\n\t\t    counter = 0,\n\t\t    length = string.length,\n\t\t    value,\n\t\t    extra;\n\t\twhile (counter < length) {\n\t\t\tvalue = string.charCodeAt(counter++);\n\t\t\tif (value >= 0xD800 && value <= 0xDBFF && counter < length) {\n\t\t\t\t// high surrogate, and there is a next character\n\t\t\t\textra = string.charCodeAt(counter++);\n\t\t\t\tif ((extra & 0xFC00) == 0xDC00) { // low surrogate\n\t\t\t\t\toutput.push(((value & 0x3FF) << 10) + (extra & 0x3FF) + 0x10000);\n\t\t\t\t} else {\n\t\t\t\t\t// unmatched surrogate; only append this code unit, in case the next\n\t\t\t\t\t// code unit is the high surrogate of a surrogate pair\n\t\t\t\t\toutput.push(value);\n\t\t\t\t\tcounter--;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\toutput.push(value);\n\t\t\t}\n\t\t}\n\t\treturn output;\n\t}\n\n\t/**\n\t * Creates a string based on an array of numeric code points.\n\t * @see `punycode.ucs2.decode`\n\t * @memberOf punycode.ucs2\n\t * @name encode\n\t * @param {Array} codePoints The array of numeric code points.\n\t * @returns {String} The new Unicode string (UCS-2).\n\t */\n\tfunction ucs2encode(array) {\n\t\treturn map(array, function(value) {\n\t\t\tvar output = '';\n\t\t\tif (value > 0xFFFF) {\n\t\t\t\tvalue -= 0x10000;\n\t\t\t\toutput += stringFromCharCode(value >>> 10 & 0x3FF | 0xD800);\n\t\t\t\tvalue = 0xDC00 | value & 0x3FF;\n\t\t\t}\n\t\t\toutput += stringFromCharCode(value);\n\t\t\treturn output;\n\t\t}).join('');\n\t}\n\n\t/**\n\t * Converts a basic code point into a digit/integer.\n\t * @see `digitToBasic()`\n\t * @private\n\t * @param {Number} codePoint The basic numeric code point value.\n\t * @returns {Number} The numeric value of a basic code point (for use in\n\t * representing integers) in the range `0` to `base - 1`, or `base` if\n\t * the code point does not represent a value.\n\t */\n\tfunction basicToDigit(codePoint) {\n\t\tif (codePoint - 48 < 10) {\n\t\t\treturn codePoint - 22;\n\t\t}\n\t\tif (codePoint - 65 < 26) {\n\t\t\treturn codePoint - 65;\n\t\t}\n\t\tif (codePoint - 97 < 26) {\n\t\t\treturn codePoint - 97;\n\t\t}\n\t\treturn base;\n\t}\n\n\t/**\n\t * Converts a digit/integer into a basic code point.\n\t * @see `basicToDigit()`\n\t * @private\n\t * @param {Number} digit The numeric value of a basic code point.\n\t * @returns {Number} The basic code point whose value (when used for\n\t * representing integers) is `digit`, which needs to be in the range\n\t * `0` to `base - 1`. If `flag` is non-zero, the uppercase form is\n\t * used; else, the lowercase form is used. The behavior is undefined\n\t * if `flag` is non-zero and `digit` has no uppercase form.\n\t */\n\tfunction digitToBasic(digit, flag) {\n\t\t//  0..25 map to ASCII a..z or A..Z\n\t\t// 26..35 map to ASCII 0..9\n\t\treturn digit + 22 + 75 * (digit < 26) - ((flag != 0) << 5);\n\t}\n\n\t/**\n\t * Bias adaptation function as per section 3.4 of RFC 3492.\n\t * https://tools.ietf.org/html/rfc3492#section-3.4\n\t * @private\n\t */\n\tfunction adapt(delta, numPoints, firstTime) {\n\t\tvar k = 0;\n\t\tdelta = firstTime ? floor(delta / damp) : delta >> 1;\n\t\tdelta += floor(delta / numPoints);\n\t\tfor (/* no initialization */; delta > baseMinusTMin * tMax >> 1; k += base) {\n\t\t\tdelta = floor(delta / baseMinusTMin);\n\t\t}\n\t\treturn floor(k + (baseMinusTMin + 1) * delta / (delta + skew));\n\t}\n\n\t/**\n\t * Converts a Punycode string of ASCII-only symbols to a string of Unicode\n\t * symbols.\n\t * @memberOf punycode\n\t * @param {String} input The Punycode string of ASCII-only symbols.\n\t * @returns {String} The resulting string of Unicode symbols.\n\t */\n\tfunction decode(input) {\n\t\t// Don't use UCS-2\n\t\tvar output = [],\n\t\t    inputLength = input.length,\n\t\t    out,\n\t\t    i = 0,\n\t\t    n = initialN,\n\t\t    bias = initialBias,\n\t\t    basic,\n\t\t    j,\n\t\t    index,\n\t\t    oldi,\n\t\t    w,\n\t\t    k,\n\t\t    digit,\n\t\t    t,\n\t\t    /** Cached calculation results */\n\t\t    baseMinusT;\n\n\t\t// Handle the basic code points: let `basic` be the number of input code\n\t\t// points before the last delimiter, or `0` if there is none, then copy\n\t\t// the first basic code points to the output.\n\n\t\tbasic = input.lastIndexOf(delimiter);\n\t\tif (basic < 0) {\n\t\t\tbasic = 0;\n\t\t}\n\n\t\tfor (j = 0; j < basic; ++j) {\n\t\t\t// if it's not a basic code point\n\t\t\tif (input.charCodeAt(j) >= 0x80) {\n\t\t\t\terror('not-basic');\n\t\t\t}\n\t\t\toutput.push(input.charCodeAt(j));\n\t\t}\n\n\t\t// Main decoding loop: start just after the last delimiter if any basic code\n\t\t// points were copied; start at the beginning otherwise.\n\n\t\tfor (index = basic > 0 ? basic + 1 : 0; index < inputLength; /* no final expression */) {\n\n\t\t\t// `index` is the index of the next character to be consumed.\n\t\t\t// Decode a generalized variable-length integer into `delta`,\n\t\t\t// which gets added to `i`. The overflow checking is easier\n\t\t\t// if we increase `i` as we go, then subtract off its starting\n\t\t\t// value at the end to obtain `delta`.\n\t\t\tfor (oldi = i, w = 1, k = base; /* no condition */; k += base) {\n\n\t\t\t\tif (index >= inputLength) {\n\t\t\t\t\terror('invalid-input');\n\t\t\t\t}\n\n\t\t\t\tdigit = basicToDigit(input.charCodeAt(index++));\n\n\t\t\t\tif (digit >= base || digit > floor((maxInt - i) / w)) {\n\t\t\t\t\terror('overflow');\n\t\t\t\t}\n\n\t\t\t\ti += digit * w;\n\t\t\t\tt = k <= bias ? tMin : (k >= bias + tMax ? tMax : k - bias);\n\n\t\t\t\tif (digit < t) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\tbaseMinusT = base - t;\n\t\t\t\tif (w > floor(maxInt / baseMinusT)) {\n\t\t\t\t\terror('overflow');\n\t\t\t\t}\n\n\t\t\t\tw *= baseMinusT;\n\n\t\t\t}\n\n\t\t\tout = output.length + 1;\n\t\t\tbias = adapt(i - oldi, out, oldi == 0);\n\n\t\t\t// `i` was supposed to wrap around from `out` to `0`,\n\t\t\t// incrementing `n` each time, so we'll fix that now:\n\t\t\tif (floor(i / out) > maxInt - n) {\n\t\t\t\terror('overflow');\n\t\t\t}\n\n\t\t\tn += floor(i / out);\n\t\t\ti %= out;\n\n\t\t\t// Insert `n` at position `i` of the output\n\t\t\toutput.splice(i++, 0, n);\n\n\t\t}\n\n\t\treturn ucs2encode(output);\n\t}\n\n\t/**\n\t * Converts a string of Unicode symbols (e.g. a domain name label) to a\n\t * Punycode string of ASCII-only symbols.\n\t * @memberOf punycode\n\t * @param {String} input The string of Unicode symbols.\n\t * @returns {String} The resulting Punycode string of ASCII-only symbols.\n\t */\n\tfunction encode(input) {\n\t\tvar n,\n\t\t    delta,\n\t\t    handledCPCount,\n\t\t    basicLength,\n\t\t    bias,\n\t\t    j,\n\t\t    m,\n\t\t    q,\n\t\t    k,\n\t\t    t,\n\t\t    currentValue,\n\t\t    output = [],\n\t\t    /** `inputLength` will hold the number of code points in `input`. */\n\t\t    inputLength,\n\t\t    /** Cached calculation results */\n\t\t    handledCPCountPlusOne,\n\t\t    baseMinusT,\n\t\t    qMinusT;\n\n\t\t// Convert the input in UCS-2 to Unicode\n\t\tinput = ucs2decode(input);\n\n\t\t// Cache the length\n\t\tinputLength = input.length;\n\n\t\t// Initialize the state\n\t\tn = initialN;\n\t\tdelta = 0;\n\t\tbias = initialBias;\n\n\t\t// Handle the basic code points\n\t\tfor (j = 0; j < inputLength; ++j) {\n\t\t\tcurrentValue = input[j];\n\t\t\tif (currentValue < 0x80) {\n\t\t\t\toutput.push(stringFromCharCode(currentValue));\n\t\t\t}\n\t\t}\n\n\t\thandledCPCount = basicLength = output.length;\n\n\t\t// `handledCPCount` is the number of code points that have been handled;\n\t\t// `basicLength` is the number of basic code points.\n\n\t\t// Finish the basic string - if it is not empty - with a delimiter\n\t\tif (basicLength) {\n\t\t\toutput.push(delimiter);\n\t\t}\n\n\t\t// Main encoding loop:\n\t\twhile (handledCPCount < inputLength) {\n\n\t\t\t// All non-basic code points < n have been handled already. Find the next\n\t\t\t// larger one:\n\t\t\tfor (m = maxInt, j = 0; j < inputLength; ++j) {\n\t\t\t\tcurrentValue = input[j];\n\t\t\t\tif (currentValue >= n && currentValue < m) {\n\t\t\t\t\tm = currentValue;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Increase `delta` enough to advance the decoder's <n,i> state to <m,0>,\n\t\t\t// but guard against overflow\n\t\t\thandledCPCountPlusOne = handledCPCount + 1;\n\t\t\tif (m - n > floor((maxInt - delta) / handledCPCountPlusOne)) {\n\t\t\t\terror('overflow');\n\t\t\t}\n\n\t\t\tdelta += (m - n) * handledCPCountPlusOne;\n\t\t\tn = m;\n\n\t\t\tfor (j = 0; j < inputLength; ++j) {\n\t\t\t\tcurrentValue = input[j];\n\n\t\t\t\tif (currentValue < n && ++delta > maxInt) {\n\t\t\t\t\terror('overflow');\n\t\t\t\t}\n\n\t\t\t\tif (currentValue == n) {\n\t\t\t\t\t// Represent delta as a generalized variable-length integer\n\t\t\t\t\tfor (q = delta, k = base; /* no condition */; k += base) {\n\t\t\t\t\t\tt = k <= bias ? tMin : (k >= bias + tMax ? tMax : k - bias);\n\t\t\t\t\t\tif (q < t) {\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tqMinusT = q - t;\n\t\t\t\t\t\tbaseMinusT = base - t;\n\t\t\t\t\t\toutput.push(\n\t\t\t\t\t\t\tstringFromCharCode(digitToBasic(t + qMinusT % baseMinusT, 0))\n\t\t\t\t\t\t);\n\t\t\t\t\t\tq = floor(qMinusT / baseMinusT);\n\t\t\t\t\t}\n\n\t\t\t\t\toutput.push(stringFromCharCode(digitToBasic(q, 0)));\n\t\t\t\t\tbias = adapt(delta, handledCPCountPlusOne, handledCPCount == basicLength);\n\t\t\t\t\tdelta = 0;\n\t\t\t\t\t++handledCPCount;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t++delta;\n\t\t\t++n;\n\n\t\t}\n\t\treturn output.join('');\n\t}\n\n\t/**\n\t * Converts a Punycode string representing a domain name or an email address\n\t * to Unicode. Only the Punycoded parts of the input will be converted, i.e.\n\t * it doesn't matter if you call it on a string that has already been\n\t * converted to Unicode.\n\t * @memberOf punycode\n\t * @param {String} input The Punycoded domain name or email address to\n\t * convert to Unicode.\n\t * @returns {String} The Unicode representation of the given Punycode\n\t * string.\n\t */\n\tfunction toUnicode(input) {\n\t\treturn mapDomain(input, function(string) {\n\t\t\treturn regexPunycode.test(string)\n\t\t\t\t? decode(string.slice(4).toLowerCase())\n\t\t\t\t: string;\n\t\t});\n\t}\n\n\t/**\n\t * Converts a Unicode string representing a domain name or an email address to\n\t * Punycode. Only the non-ASCII parts of the domain name will be converted,\n\t * i.e. it doesn't matter if you call it with a domain that's already in\n\t * ASCII.\n\t * @memberOf punycode\n\t * @param {String} input The domain name or email address to convert, as a\n\t * Unicode string.\n\t * @returns {String} The Punycode representation of the given domain name or\n\t * email address.\n\t */\n\tfunction toASCII(input) {\n\t\treturn mapDomain(input, function(string) {\n\t\t\treturn regexNonASCII.test(string)\n\t\t\t\t? 'xn--' + encode(string)\n\t\t\t\t: string;\n\t\t});\n\t}\n\n\t/*--------------------------------------------------------------------------*/\n\n\t/** Define the public API */\n\tpunycode = {\n\t\t/**\n\t\t * A string representing the current Punycode.js version number.\n\t\t * @memberOf punycode\n\t\t * @type String\n\t\t */\n\t\t'version': '1.3.2',\n\t\t/**\n\t\t * An object of methods to convert from JavaScript's internal character\n\t\t * representation (UCS-2) to Unicode code points, and back.\n\t\t * @see <https://mathiasbynens.be/notes/javascript-encoding>\n\t\t * @memberOf punycode\n\t\t * @type Object\n\t\t */\n\t\t'ucs2': {\n\t\t\t'decode': ucs2decode,\n\t\t\t'encode': ucs2encode\n\t\t},\n\t\t'decode': decode,\n\t\t'encode': encode,\n\t\t'toASCII': toASCII,\n\t\t'toUnicode': toUnicode\n\t};\n\n\t/** Expose `punycode` */\n\t// Some AMD build optimizers, like r.js, check for specific condition patterns\n\t// like the following:\n\tif (\n\t\ttypeof define == 'function' &&\n\t\ttypeof define.amd == 'object' &&\n\t\tdefine.amd\n\t) {\n\t\tdefine('punycode', function() {\n\t\t\treturn punycode;\n\t\t});\n\t} else if (freeExports && freeModule) {\n\t\tif (module.exports == freeExports) {\n\t\t\t// in Node.js, io.js, or RingoJS v0.8.0+\n\t\t\tfreeModule.exports = punycode;\n\t\t} else {\n\t\t\t// in Narwhal or RingoJS v0.7.0-\n\t\t\tfor (key in punycode) {\n\t\t\t\tpunycode.hasOwnProperty(key) && (freeExports[key] = punycode[key]);\n\t\t\t}\n\t\t}\n\t} else {\n\t\t// in Rhino or a web browser\n\t\troot.punycode = punycode;\n\t}\n\n}(this));\n\n}).call(this,typeof global !== \"undefined\" ? global : typeof self !== \"undefined\" ? self : typeof window !== \"undefined\" ? window : {})\n\n},{}],14:[function(require,module,exports){\n// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n'use strict';\n\n// If obj.hasOwnProperty has been overridden, then calling\n// obj.hasOwnProperty(prop) will break.\n// See: https://github.com/joyent/node/issues/1707\nfunction hasOwnProperty(obj, prop) {\n  return Object.prototype.hasOwnProperty.call(obj, prop);\n}\n\nmodule.exports = function(qs, sep, eq, options) {\n  sep = sep || '&';\n  eq = eq || '=';\n  var obj = {};\n\n  if (typeof qs !== 'string' || qs.length === 0) {\n    return obj;\n  }\n\n  var regexp = /\\+/g;\n  qs = qs.split(sep);\n\n  var maxKeys = 1000;\n  if (options && typeof options.maxKeys === 'number') {\n    maxKeys = options.maxKeys;\n  }\n\n  var len = qs.length;\n  // maxKeys <= 0 means that we should not limit keys count\n  if (maxKeys > 0 && len > maxKeys) {\n    len = maxKeys;\n  }\n\n  for (var i = 0; i < len; ++i) {\n    var x = qs[i].replace(regexp, '%20'),\n        idx = x.indexOf(eq),\n        kstr, vstr, k, v;\n\n    if (idx >= 0) {\n      kstr = x.substr(0, idx);\n      vstr = x.substr(idx + 1);\n    } else {\n      kstr = x;\n      vstr = '';\n    }\n\n    k = decodeURIComponent(kstr);\n    v = decodeURIComponent(vstr);\n\n    if (!hasOwnProperty(obj, k)) {\n      obj[k] = v;\n    } else if (isArray(obj[k])) {\n      obj[k].push(v);\n    } else {\n      obj[k] = [obj[k], v];\n    }\n  }\n\n  return obj;\n};\n\nvar isArray = Array.isArray || function (xs) {\n  return Object.prototype.toString.call(xs) === '[object Array]';\n};\n\n},{}],15:[function(require,module,exports){\n// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n'use strict';\n\nvar stringifyPrimitive = function(v) {\n  switch (typeof v) {\n    case 'string':\n      return v;\n\n    case 'boolean':\n      return v ? 'true' : 'false';\n\n    case 'number':\n      return isFinite(v) ? v : '';\n\n    default:\n      return '';\n  }\n};\n\nmodule.exports = function(obj, sep, eq, name) {\n  sep = sep || '&';\n  eq = eq || '=';\n  if (obj === null) {\n    obj = undefined;\n  }\n\n  if (typeof obj === 'object') {\n    return map(objectKeys(obj), function(k) {\n      var ks = encodeURIComponent(stringifyPrimitive(k)) + eq;\n      if (isArray(obj[k])) {\n        return map(obj[k], function(v) {\n          return ks + encodeURIComponent(stringifyPrimitive(v));\n        }).join(sep);\n      } else {\n        return ks + encodeURIComponent(stringifyPrimitive(obj[k]));\n      }\n    }).join(sep);\n\n  }\n\n  if (!name) return '';\n  return encodeURIComponent(stringifyPrimitive(name)) + eq +\n         encodeURIComponent(stringifyPrimitive(obj));\n};\n\nvar isArray = Array.isArray || function (xs) {\n  return Object.prototype.toString.call(xs) === '[object Array]';\n};\n\nfunction map (xs, f) {\n  if (xs.map) return xs.map(f);\n  var res = [];\n  for (var i = 0; i < xs.length; i++) {\n    res.push(f(xs[i], i));\n  }\n  return res;\n}\n\nvar objectKeys = Object.keys || function (obj) {\n  var res = [];\n  for (var key in obj) {\n    if (Object.prototype.hasOwnProperty.call(obj, key)) res.push(key);\n  }\n  return res;\n};\n\n},{}],16:[function(require,module,exports){\n'use strict';\n\nexports.decode = exports.parse = require('./decode');\nexports.encode = exports.stringify = require('./encode');\n\n},{\"./decode\":14,\"./encode\":15}],17:[function(require,module,exports){\nmodule.exports = require(\"./lib/_stream_duplex.js\")\n\n},{\"./lib/_stream_duplex.js\":18}],18:[function(require,module,exports){\n// a duplex stream is just a stream that is both readable and writable.\n// Since JS doesn't have multiple prototypal inheritance, this class\n// prototypally inherits from Readable, and then parasitically from\n// Writable.\n\n'use strict';\n\n/*<replacement>*/\nvar objectKeys = Object.keys || function (obj) {\n  var keys = [];\n  for (var key in obj) keys.push(key);\n  return keys;\n}\n/*</replacement>*/\n\n\nmodule.exports = Duplex;\n\n/*<replacement>*/\nvar processNextTick = require('process-nextick-args');\n/*</replacement>*/\n\n\n\n/*<replacement>*/\nvar util = require('core-util-is');\nutil.inherits = require('inherits');\n/*</replacement>*/\n\nvar Readable = require('./_stream_readable');\nvar Writable = require('./_stream_writable');\n\nutil.inherits(Duplex, Readable);\n\nvar keys = objectKeys(Writable.prototype);\nfor (var v = 0; v < keys.length; v++) {\n  var method = keys[v];\n  if (!Duplex.prototype[method])\n    Duplex.prototype[method] = Writable.prototype[method];\n}\n\nfunction Duplex(options) {\n  if (!(this instanceof Duplex))\n    return new Duplex(options);\n\n  Readable.call(this, options);\n  Writable.call(this, options);\n\n  if (options && options.readable === false)\n    this.readable = false;\n\n  if (options && options.writable === false)\n    this.writable = false;\n\n  this.allowHalfOpen = true;\n  if (options && options.allowHalfOpen === false)\n    this.allowHalfOpen = false;\n\n  this.once('end', onend);\n}\n\n// the no-half-open enforcer\nfunction onend() {\n  // if we allow half-open state, or if the writable side ended,\n  // then we're ok.\n  if (this.allowHalfOpen || this._writableState.ended)\n    return;\n\n  // no more data can be written.\n  // But allow more writes to happen in this tick.\n  processNextTick(onEndNT, this);\n}\n\nfunction onEndNT(self) {\n  self.end();\n}\n\nfunction forEach (xs, f) {\n  for (var i = 0, l = xs.length; i < l; i++) {\n    f(xs[i], i);\n  }\n}\n\n},{\"./_stream_readable\":20,\"./_stream_writable\":22,\"core-util-is\":23,\"inherits\":9,\"process-nextick-args\":24}],19:[function(require,module,exports){\n// a passthrough stream.\n// basically just the most minimal sort of Transform stream.\n// Every written chunk gets output as-is.\n\n'use strict';\n\nmodule.exports = PassThrough;\n\nvar Transform = require('./_stream_transform');\n\n/*<replacement>*/\nvar util = require('core-util-is');\nutil.inherits = require('inherits');\n/*</replacement>*/\n\nutil.inherits(PassThrough, Transform);\n\nfunction PassThrough(options) {\n  if (!(this instanceof PassThrough))\n    return new PassThrough(options);\n\n  Transform.call(this, options);\n}\n\nPassThrough.prototype._transform = function(chunk, encoding, cb) {\n  cb(null, chunk);\n};\n\n},{\"./_stream_transform\":21,\"core-util-is\":23,\"inherits\":9}],20:[function(require,module,exports){\n(function (process){\n'use strict';\n\nmodule.exports = Readable;\n\n/*<replacement>*/\nvar processNextTick = require('process-nextick-args');\n/*</replacement>*/\n\n\n/*<replacement>*/\nvar isArray = require('isarray');\n/*</replacement>*/\n\n\n/*<replacement>*/\nvar Buffer = require('buffer').Buffer;\n/*</replacement>*/\n\nReadable.ReadableState = ReadableState;\n\nvar EE = require('events');\n\n/*<replacement>*/\nvar EElistenerCount = function(emitter, type) {\n  return emitter.listeners(type).length;\n};\n/*</replacement>*/\n\n\n\n/*<replacement>*/\nvar Stream;\n(function (){try{\n  Stream = require('st' + 'ream');\n}catch(_){}finally{\n  if (!Stream)\n    Stream = require('events').EventEmitter;\n}}())\n/*</replacement>*/\n\nvar Buffer = require('buffer').Buffer;\n\n/*<replacement>*/\nvar util = require('core-util-is');\nutil.inherits = require('inherits');\n/*</replacement>*/\n\n\n\n/*<replacement>*/\nvar debugUtil = require('util');\nvar debug;\nif (debugUtil && debugUtil.debuglog) {\n  debug = debugUtil.debuglog('stream');\n} else {\n  debug = function () {};\n}\n/*</replacement>*/\n\nvar StringDecoder;\n\nutil.inherits(Readable, Stream);\n\nfunction ReadableState(options, stream) {\n  var Duplex = require('./_stream_duplex');\n\n  options = options || {};\n\n  // object stream flag. Used to make read(n) ignore n and to\n  // make all the buffer merging and length checks go away\n  this.objectMode = !!options.objectMode;\n\n  if (stream instanceof Duplex)\n    this.objectMode = this.objectMode || !!options.readableObjectMode;\n\n  // the point at which it stops calling _read() to fill the buffer\n  // Note: 0 is a valid value, means \"don't call _read preemptively ever\"\n  var hwm = options.highWaterMark;\n  var defaultHwm = this.objectMode ? 16 : 16 * 1024;\n  this.highWaterMark = (hwm || hwm === 0) ? hwm : defaultHwm;\n\n  // cast to ints.\n  this.highWaterMark = ~~this.highWaterMark;\n\n  this.buffer = [];\n  this.length = 0;\n  this.pipes = null;\n  this.pipesCount = 0;\n  this.flowing = null;\n  this.ended = false;\n  this.endEmitted = false;\n  this.reading = false;\n\n  // a flag to be able to tell if the onwrite cb is called immediately,\n  // or on a later tick.  We set this to true at first, because any\n  // actions that shouldn't happen until \"later\" should generally also\n  // not happen before the first write call.\n  this.sync = true;\n\n  // whenever we return null, then we set a flag to say\n  // that we're awaiting a 'readable' event emission.\n  this.needReadable = false;\n  this.emittedReadable = false;\n  this.readableListening = false;\n\n  // Crypto is kind of old and crusty.  Historically, its default string\n  // encoding is 'binary' so we have to make this configurable.\n  // Everything else in the universe uses 'utf8', though.\n  this.defaultEncoding = options.defaultEncoding || 'utf8';\n\n  // when piping, we only care about 'readable' events that happen\n  // after read()ing all the bytes and not getting any pushback.\n  this.ranOut = false;\n\n  // the number of writers that are awaiting a drain event in .pipe()s\n  this.awaitDrain = 0;\n\n  // if true, a maybeReadMore has been scheduled\n  this.readingMore = false;\n\n  this.decoder = null;\n  this.encoding = null;\n  if (options.encoding) {\n    if (!StringDecoder)\n      StringDecoder = require('string_decoder/').StringDecoder;\n    this.decoder = new StringDecoder(options.encoding);\n    this.encoding = options.encoding;\n  }\n}\n\nfunction Readable(options) {\n  var Duplex = require('./_stream_duplex');\n\n  if (!(this instanceof Readable))\n    return new Readable(options);\n\n  this._readableState = new ReadableState(options, this);\n\n  // legacy\n  this.readable = true;\n\n  if (options && typeof options.read === 'function')\n    this._read = options.read;\n\n  Stream.call(this);\n}\n\n// Manually shove something into the read() buffer.\n// This returns true if the highWaterMark has not been hit yet,\n// similar to how Writable.write() returns true if you should\n// write() some more.\nReadable.prototype.push = function(chunk, encoding) {\n  var state = this._readableState;\n\n  if (!state.objectMode && typeof chunk === 'string') {\n    encoding = encoding || state.defaultEncoding;\n    if (encoding !== state.encoding) {\n      chunk = new Buffer(chunk, encoding);\n      encoding = '';\n    }\n  }\n\n  return readableAddChunk(this, state, chunk, encoding, false);\n};\n\n// Unshift should *always* be something directly out of read()\nReadable.prototype.unshift = function(chunk) {\n  var state = this._readableState;\n  return readableAddChunk(this, state, chunk, '', true);\n};\n\nReadable.prototype.isPaused = function() {\n  return this._readableState.flowing === false;\n};\n\nfunction readableAddChunk(stream, state, chunk, encoding, addToFront) {\n  var er = chunkInvalid(state, chunk);\n  if (er) {\n    stream.emit('error', er);\n  } else if (chunk === null) {\n    state.reading = false;\n    onEofChunk(stream, state);\n  } else if (state.objectMode || chunk && chunk.length > 0) {\n    if (state.ended && !addToFront) {\n      var e = new Error('stream.push() after EOF');\n      stream.emit('error', e);\n    } else if (state.endEmitted && addToFront) {\n      var e = new Error('stream.unshift() after end event');\n      stream.emit('error', e);\n    } else {\n      if (state.decoder && !addToFront && !encoding)\n        chunk = state.decoder.write(chunk);\n\n      if (!addToFront)\n        state.reading = false;\n\n      // if we want the data now, just emit it.\n      if (state.flowing && state.length === 0 && !state.sync) {\n        stream.emit('data', chunk);\n        stream.read(0);\n      } else {\n        // update the buffer info.\n        state.length += state.objectMode ? 1 : chunk.length;\n        if (addToFront)\n          state.buffer.unshift(chunk);\n        else\n          state.buffer.push(chunk);\n\n        if (state.needReadable)\n          emitReadable(stream);\n      }\n\n      maybeReadMore(stream, state);\n    }\n  } else if (!addToFront) {\n    state.reading = false;\n  }\n\n  return needMoreData(state);\n}\n\n\n// if it's past the high water mark, we can push in some more.\n// Also, if we have no data yet, we can stand some\n// more bytes.  This is to work around cases where hwm=0,\n// such as the repl.  Also, if the push() triggered a\n// readable event, and the user called read(largeNumber) such that\n// needReadable was set, then we ought to push more, so that another\n// 'readable' event will be triggered.\nfunction needMoreData(state) {\n  return !state.ended &&\n         (state.needReadable ||\n          state.length < state.highWaterMark ||\n          state.length === 0);\n}\n\n// backwards compatibility.\nReadable.prototype.setEncoding = function(enc) {\n  if (!StringDecoder)\n    StringDecoder = require('string_decoder/').StringDecoder;\n  this._readableState.decoder = new StringDecoder(enc);\n  this._readableState.encoding = enc;\n  return this;\n};\n\n// Don't raise the hwm > 8MB\nvar MAX_HWM = 0x800000;\nfunction computeNewHighWaterMark(n) {\n  if (n >= MAX_HWM) {\n    n = MAX_HWM;\n  } else {\n    // Get the next highest power of 2\n    n--;\n    n |= n >>> 1;\n    n |= n >>> 2;\n    n |= n >>> 4;\n    n |= n >>> 8;\n    n |= n >>> 16;\n    n++;\n  }\n  return n;\n}\n\nfunction howMuchToRead(n, state) {\n  if (state.length === 0 && state.ended)\n    return 0;\n\n  if (state.objectMode)\n    return n === 0 ? 0 : 1;\n\n  if (n === null || isNaN(n)) {\n    // only flow one buffer at a time\n    if (state.flowing && state.buffer.length)\n      return state.buffer[0].length;\n    else\n      return state.length;\n  }\n\n  if (n <= 0)\n    return 0;\n\n  // If we're asking for more than the target buffer level,\n  // then raise the water mark.  Bump up to the next highest\n  // power of 2, to prevent increasing it excessively in tiny\n  // amounts.\n  if (n > state.highWaterMark)\n    state.highWaterMark = computeNewHighWaterMark(n);\n\n  // don't have that much.  return null, unless we've ended.\n  if (n > state.length) {\n    if (!state.ended) {\n      state.needReadable = true;\n      return 0;\n    } else {\n      return state.length;\n    }\n  }\n\n  return n;\n}\n\n// you can override either this method, or the async _read(n) below.\nReadable.prototype.read = function(n) {\n  debug('read', n);\n  var state = this._readableState;\n  var nOrig = n;\n\n  if (typeof n !== 'number' || n > 0)\n    state.emittedReadable = false;\n\n  // if we're doing read(0) to trigger a readable event, but we\n  // already have a bunch of data in the buffer, then just trigger\n  // the 'readable' event and move on.\n  if (n === 0 &&\n      state.needReadable &&\n      (state.length >= state.highWaterMark || state.ended)) {\n    debug('read: emitReadable', state.length, state.ended);\n    if (state.length === 0 && state.ended)\n      endReadable(this);\n    else\n      emitReadable(this);\n    return null;\n  }\n\n  n = howMuchToRead(n, state);\n\n  // if we've ended, and we're now clear, then finish it up.\n  if (n === 0 && state.ended) {\n    if (state.length === 0)\n      endReadable(this);\n    return null;\n  }\n\n  // All the actual chunk generation logic needs to be\n  // *below* the call to _read.  The reason is that in certain\n  // synthetic stream cases, such as passthrough streams, _read\n  // may be a completely synchronous operation which may change\n  // the state of the read buffer, providing enough data when\n  // before there was *not* enough.\n  //\n  // So, the steps are:\n  // 1. Figure out what the state of things will be after we do\n  // a read from the buffer.\n  //\n  // 2. If that resulting state will trigger a _read, then call _read.\n  // Note that this may be asynchronous, or synchronous.  Yes, it is\n  // deeply ugly to write APIs this way, but that still doesn't mean\n  // that the Readable class should behave improperly, as streams are\n  // designed to be sync/async agnostic.\n  // Take note if the _read call is sync or async (ie, if the read call\n  // has returned yet), so that we know whether or not it's safe to emit\n  // 'readable' etc.\n  //\n  // 3. Actually pull the requested chunks out of the buffer and return.\n\n  // if we need a readable event, then we need to do some reading.\n  var doRead = state.needReadable;\n  debug('need readable', doRead);\n\n  // if we currently have less than the highWaterMark, then also read some\n  if (state.length === 0 || state.length - n < state.highWaterMark) {\n    doRead = true;\n    debug('length less than watermark', doRead);\n  }\n\n  // however, if we've ended, then there's no point, and if we're already\n  // reading, then it's unnecessary.\n  if (state.ended || state.reading) {\n    doRead = false;\n    debug('reading or ended', doRead);\n  }\n\n  if (doRead) {\n    debug('do read');\n    state.reading = true;\n    state.sync = true;\n    // if the length is currently zero, then we *need* a readable event.\n    if (state.length === 0)\n      state.needReadable = true;\n    // call internal read method\n    this._read(state.highWaterMark);\n    state.sync = false;\n  }\n\n  // If _read pushed data synchronously, then `reading` will be false,\n  // and we need to re-evaluate how much data we can return to the user.\n  if (doRead && !state.reading)\n    n = howMuchToRead(nOrig, state);\n\n  var ret;\n  if (n > 0)\n    ret = fromList(n, state);\n  else\n    ret = null;\n\n  if (ret === null) {\n    state.needReadable = true;\n    n = 0;\n  }\n\n  state.length -= n;\n\n  // If we have nothing in the buffer, then we want to know\n  // as soon as we *do* get something into the buffer.\n  if (state.length === 0 && !state.ended)\n    state.needReadable = true;\n\n  // If we tried to read() past the EOF, then emit end on the next tick.\n  if (nOrig !== n && state.ended && state.length === 0)\n    endReadable(this);\n\n  if (ret !== null)\n    this.emit('data', ret);\n\n  return ret;\n};\n\nfunction chunkInvalid(state, chunk) {\n  var er = null;\n  if (!(Buffer.isBuffer(chunk)) &&\n      typeof chunk !== 'string' &&\n      chunk !== null &&\n      chunk !== undefined &&\n      !state.objectMode) {\n    er = new TypeError('Invalid non-string/buffer chunk');\n  }\n  return er;\n}\n\n\nfunction onEofChunk(stream, state) {\n  if (state.ended) return;\n  if (state.decoder) {\n    var chunk = state.decoder.end();\n    if (chunk && chunk.length) {\n      state.buffer.push(chunk);\n      state.length += state.objectMode ? 1 : chunk.length;\n    }\n  }\n  state.ended = true;\n\n  // emit 'readable' now to make sure it gets picked up.\n  emitReadable(stream);\n}\n\n// Don't emit readable right away in sync mode, because this can trigger\n// another read() call => stack overflow.  This way, it might trigger\n// a nextTick recursion warning, but that's not so bad.\nfunction emitReadable(stream) {\n  var state = stream._readableState;\n  state.needReadable = false;\n  if (!state.emittedReadable) {\n    debug('emitReadable', state.flowing);\n    state.emittedReadable = true;\n    if (state.sync)\n      processNextTick(emitReadable_, stream);\n    else\n      emitReadable_(stream);\n  }\n}\n\nfunction emitReadable_(stream) {\n  debug('emit readable');\n  stream.emit('readable');\n  flow(stream);\n}\n\n\n// at this point, the user has presumably seen the 'readable' event,\n// and called read() to consume some data.  that may have triggered\n// in turn another _read(n) call, in which case reading = true if\n// it's in progress.\n// However, if we're not ended, or reading, and the length < hwm,\n// then go ahead and try to read some more preemptively.\nfunction maybeReadMore(stream, state) {\n  if (!state.readingMore) {\n    state.readingMore = true;\n    processNextTick(maybeReadMore_, stream, state);\n  }\n}\n\nfunction maybeReadMore_(stream, state) {\n  var len = state.length;\n  while (!state.reading && !state.flowing && !state.ended &&\n         state.length < state.highWaterMark) {\n    debug('maybeReadMore read 0');\n    stream.read(0);\n    if (len === state.length)\n      // didn't get any data, stop spinning.\n      break;\n    else\n      len = state.length;\n  }\n  state.readingMore = false;\n}\n\n// abstract method.  to be overridden in specific implementation classes.\n// call cb(er, data) where data is <= n in length.\n// for virtual (non-string, non-buffer) streams, \"length\" is somewhat\n// arbitrary, and perhaps not very meaningful.\nReadable.prototype._read = function(n) {\n  this.emit('error', new Error('not implemented'));\n};\n\nReadable.prototype.pipe = function(dest, pipeOpts) {\n  var src = this;\n  var state = this._readableState;\n\n  switch (state.pipesCount) {\n    case 0:\n      state.pipes = dest;\n      break;\n    case 1:\n      state.pipes = [state.pipes, dest];\n      break;\n    default:\n      state.pipes.push(dest);\n      break;\n  }\n  state.pipesCount += 1;\n  debug('pipe count=%d opts=%j', state.pipesCount, pipeOpts);\n\n  var doEnd = (!pipeOpts || pipeOpts.end !== false) &&\n              dest !== process.stdout &&\n              dest !== process.stderr;\n\n  var endFn = doEnd ? onend : cleanup;\n  if (state.endEmitted)\n    processNextTick(endFn);\n  else\n    src.once('end', endFn);\n\n  dest.on('unpipe', onunpipe);\n  function onunpipe(readable) {\n    debug('onunpipe');\n    if (readable === src) {\n      cleanup();\n    }\n  }\n\n  function onend() {\n    debug('onend');\n    dest.end();\n  }\n\n  // when the dest drains, it reduces the awaitDrain counter\n  // on the source.  This would be more elegant with a .once()\n  // handler in flow(), but adding and removing repeatedly is\n  // too slow.\n  var ondrain = pipeOnDrain(src);\n  dest.on('drain', ondrain);\n\n  var cleanedUp = false;\n  function cleanup() {\n    debug('cleanup');\n    // cleanup event handlers once the pipe is broken\n    dest.removeListener('close', onclose);\n    dest.removeListener('finish', onfinish);\n    dest.removeListener('drain', ondrain);\n    dest.removeListener('error', onerror);\n    dest.removeListener('unpipe', onunpipe);\n    src.removeListener('end', onend);\n    src.removeListener('end', cleanup);\n    src.removeListener('data', ondata);\n\n    cleanedUp = true;\n\n    // if the reader is waiting for a drain event from this\n    // specific writer, then it would cause it to never start\n    // flowing again.\n    // So, if this is awaiting a drain, then we just call it now.\n    // If we don't know, then assume that we are waiting for one.\n    if (state.awaitDrain &&\n        (!dest._writableState || dest._writableState.needDrain))\n      ondrain();\n  }\n\n  src.on('data', ondata);\n  function ondata(chunk) {\n    debug('ondata');\n    var ret = dest.write(chunk);\n    if (false === ret) {\n      // If the user unpiped during `dest.write()`, it is possible\n      // to get stuck in a permanently paused state if that write\n      // also returned false.\n      if (state.pipesCount === 1 &&\n          state.pipes[0] === dest &&\n          src.listenerCount('data') === 1 &&\n          !cleanedUp) {\n        debug('false write response, pause', src._readableState.awaitDrain);\n        src._readableState.awaitDrain++;\n      }\n      src.pause();\n    }\n  }\n\n  // if the dest has an error, then stop piping into it.\n  // however, don't suppress the throwing behavior for this.\n  function onerror(er) {\n    debug('onerror', er);\n    unpipe();\n    dest.removeListener('error', onerror);\n    if (EElistenerCount(dest, 'error') === 0)\n      dest.emit('error', er);\n  }\n  // This is a brutally ugly hack to make sure that our error handler\n  // is attached before any userland ones.  NEVER DO THIS.\n  if (!dest._events || !dest._events.error)\n    dest.on('error', onerror);\n  else if (isArray(dest._events.error))\n    dest._events.error.unshift(onerror);\n  else\n    dest._events.error = [onerror, dest._events.error];\n\n\n  // Both close and finish should trigger unpipe, but only once.\n  function onclose() {\n    dest.removeListener('finish', onfinish);\n    unpipe();\n  }\n  dest.once('close', onclose);\n  function onfinish() {\n    debug('onfinish');\n    dest.removeListener('close', onclose);\n    unpipe();\n  }\n  dest.once('finish', onfinish);\n\n  function unpipe() {\n    debug('unpipe');\n    src.unpipe(dest);\n  }\n\n  // tell the dest that it's being piped to\n  dest.emit('pipe', src);\n\n  // start the flow if it hasn't been started already.\n  if (!state.flowing) {\n    debug('pipe resume');\n    src.resume();\n  }\n\n  return dest;\n};\n\nfunction pipeOnDrain(src) {\n  return function() {\n    var state = src._readableState;\n    debug('pipeOnDrain', state.awaitDrain);\n    if (state.awaitDrain)\n      state.awaitDrain--;\n    if (state.awaitDrain === 0 && EElistenerCount(src, 'data')) {\n      state.flowing = true;\n      flow(src);\n    }\n  };\n}\n\n\nReadable.prototype.unpipe = function(dest) {\n  var state = this._readableState;\n\n  // if we're not piping anywhere, then do nothing.\n  if (state.pipesCount === 0)\n    return this;\n\n  // just one destination.  most common case.\n  if (state.pipesCount === 1) {\n    // passed in one, but it's not the right one.\n    if (dest && dest !== state.pipes)\n      return this;\n\n    if (!dest)\n      dest = state.pipes;\n\n    // got a match.\n    state.pipes = null;\n    state.pipesCount = 0;\n    state.flowing = false;\n    if (dest)\n      dest.emit('unpipe', this);\n    return this;\n  }\n\n  // slow case. multiple pipe destinations.\n\n  if (!dest) {\n    // remove all.\n    var dests = state.pipes;\n    var len = state.pipesCount;\n    state.pipes = null;\n    state.pipesCount = 0;\n    state.flowing = false;\n\n    for (var i = 0; i < len; i++)\n      dests[i].emit('unpipe', this);\n    return this;\n  }\n\n  // try to find the right one.\n  var i = indexOf(state.pipes, dest);\n  if (i === -1)\n    return this;\n\n  state.pipes.splice(i, 1);\n  state.pipesCount -= 1;\n  if (state.pipesCount === 1)\n    state.pipes = state.pipes[0];\n\n  dest.emit('unpipe', this);\n\n  return this;\n};\n\n// set up data events if they are asked for\n// Ensure readable listeners eventually get something\nReadable.prototype.on = function(ev, fn) {\n  var res = Stream.prototype.on.call(this, ev, fn);\n\n  // If listening to data, and it has not explicitly been paused,\n  // then call resume to start the flow of data on the next tick.\n  if (ev === 'data' && false !== this._readableState.flowing) {\n    this.resume();\n  }\n\n  if (ev === 'readable' && this.readable) {\n    var state = this._readableState;\n    if (!state.readableListening) {\n      state.readableListening = true;\n      state.emittedReadable = false;\n      state.needReadable = true;\n      if (!state.reading) {\n        processNextTick(nReadingNextTick, this);\n      } else if (state.length) {\n        emitReadable(this, state);\n      }\n    }\n  }\n\n  return res;\n};\nReadable.prototype.addListener = Readable.prototype.on;\n\nfunction nReadingNextTick(self) {\n  debug('readable nexttick read 0');\n  self.read(0);\n}\n\n// pause() and resume() are remnants of the legacy readable stream API\n// If the user uses them, then switch into old mode.\nReadable.prototype.resume = function() {\n  var state = this._readableState;\n  if (!state.flowing) {\n    debug('resume');\n    state.flowing = true;\n    resume(this, state);\n  }\n  return this;\n};\n\nfunction resume(stream, state) {\n  if (!state.resumeScheduled) {\n    state.resumeScheduled = true;\n    processNextTick(resume_, stream, state);\n  }\n}\n\nfunction resume_(stream, state) {\n  if (!state.reading) {\n    debug('resume read 0');\n    stream.read(0);\n  }\n\n  state.resumeScheduled = false;\n  stream.emit('resume');\n  flow(stream);\n  if (state.flowing && !state.reading)\n    stream.read(0);\n}\n\nReadable.prototype.pause = function() {\n  debug('call pause flowing=%j', this._readableState.flowing);\n  if (false !== this._readableState.flowing) {\n    debug('pause');\n    this._readableState.flowing = false;\n    this.emit('pause');\n  }\n  return this;\n};\n\nfunction flow(stream) {\n  var state = stream._readableState;\n  debug('flow', state.flowing);\n  if (state.flowing) {\n    do {\n      var chunk = stream.read();\n    } while (null !== chunk && state.flowing);\n  }\n}\n\n// wrap an old-style stream as the async data source.\n// This is *not* part of the readable stream interface.\n// It is an ugly unfortunate mess of history.\nReadable.prototype.wrap = function(stream) {\n  var state = this._readableState;\n  var paused = false;\n\n  var self = this;\n  stream.on('end', function() {\n    debug('wrapped end');\n    if (state.decoder && !state.ended) {\n      var chunk = state.decoder.end();\n      if (chunk && chunk.length)\n        self.push(chunk);\n    }\n\n    self.push(null);\n  });\n\n  stream.on('data', function(chunk) {\n    debug('wrapped data');\n    if (state.decoder)\n      chunk = state.decoder.write(chunk);\n\n    // don't skip over falsy values in objectMode\n    if (state.objectMode && (chunk === null || chunk === undefined))\n      return;\n    else if (!state.objectMode && (!chunk || !chunk.length))\n      return;\n\n    var ret = self.push(chunk);\n    if (!ret) {\n      paused = true;\n      stream.pause();\n    }\n  });\n\n  // proxy all the other methods.\n  // important when wrapping filters and duplexes.\n  for (var i in stream) {\n    if (this[i] === undefined && typeof stream[i] === 'function') {\n      this[i] = function(method) { return function() {\n        return stream[method].apply(stream, arguments);\n      }; }(i);\n    }\n  }\n\n  // proxy certain important events.\n  var events = ['error', 'close', 'destroy', 'pause', 'resume'];\n  forEach(events, function(ev) {\n    stream.on(ev, self.emit.bind(self, ev));\n  });\n\n  // when we try to consume some more bytes, simply unpause the\n  // underlying stream.\n  self._read = function(n) {\n    debug('wrapped _read', n);\n    if (paused) {\n      paused = false;\n      stream.resume();\n    }\n  };\n\n  return self;\n};\n\n\n// exposed for testing purposes only.\nReadable._fromList = fromList;\n\n// Pluck off n bytes from an array of buffers.\n// Length is the combined lengths of all the buffers in the list.\nfunction fromList(n, state) {\n  var list = state.buffer;\n  var length = state.length;\n  var stringMode = !!state.decoder;\n  var objectMode = !!state.objectMode;\n  var ret;\n\n  // nothing in the list, definitely empty.\n  if (list.length === 0)\n    return null;\n\n  if (length === 0)\n    ret = null;\n  else if (objectMode)\n    ret = list.shift();\n  else if (!n || n >= length) {\n    // read it all, truncate the array.\n    if (stringMode)\n      ret = list.join('');\n    else if (list.length === 1)\n      ret = list[0];\n    else\n      ret = Buffer.concat(list, length);\n    list.length = 0;\n  } else {\n    // read just some of it.\n    if (n < list[0].length) {\n      // just take a part of the first list item.\n      // slice is the same for buffers and strings.\n      var buf = list[0];\n      ret = buf.slice(0, n);\n      list[0] = buf.slice(n);\n    } else if (n === list[0].length) {\n      // first list is a perfect match\n      ret = list.shift();\n    } else {\n      // complex case.\n      // we have enough to cover it, but it spans past the first buffer.\n      if (stringMode)\n        ret = '';\n      else\n        ret = new Buffer(n);\n\n      var c = 0;\n      for (var i = 0, l = list.length; i < l && c < n; i++) {\n        var buf = list[0];\n        var cpy = Math.min(n - c, buf.length);\n\n        if (stringMode)\n          ret += buf.slice(0, cpy);\n        else\n          buf.copy(ret, c, 0, cpy);\n\n        if (cpy < buf.length)\n          list[0] = buf.slice(cpy);\n        else\n          list.shift();\n\n        c += cpy;\n      }\n    }\n  }\n\n  return ret;\n}\n\nfunction endReadable(stream) {\n  var state = stream._readableState;\n\n  // If we get here before consuming all the bytes, then that is a\n  // bug in node.  Should never happen.\n  if (state.length > 0)\n    throw new Error('endReadable called on non-empty stream');\n\n  if (!state.endEmitted) {\n    state.ended = true;\n    processNextTick(endReadableNT, state, stream);\n  }\n}\n\nfunction endReadableNT(state, stream) {\n  // Check that we didn't get one last unshift.\n  if (!state.endEmitted && state.length === 0) {\n    state.endEmitted = true;\n    stream.readable = false;\n    stream.emit('end');\n  }\n}\n\nfunction forEach (xs, f) {\n  for (var i = 0, l = xs.length; i < l; i++) {\n    f(xs[i], i);\n  }\n}\n\nfunction indexOf (xs, x) {\n  for (var i = 0, l = xs.length; i < l; i++) {\n    if (xs[i] === x) return i;\n  }\n  return -1;\n}\n\n}).call(this,require('_process'))\n\n},{\"./_stream_duplex\":18,\"_process\":12,\"buffer\":3,\"core-util-is\":23,\"events\":7,\"inherits\":9,\"isarray\":11,\"process-nextick-args\":24,\"string_decoder/\":36,\"util\":2}],21:[function(require,module,exports){\n// a transform stream is a readable/writable stream where you do\n// something with the data.  Sometimes it's called a \"filter\",\n// but that's not a great name for it, since that implies a thing where\n// some bits pass through, and others are simply ignored.  (That would\n// be a valid example of a transform, of course.)\n//\n// While the output is causally related to the input, it's not a\n// necessarily symmetric or synchronous transformation.  For example,\n// a zlib stream might take multiple plain-text writes(), and then\n// emit a single compressed chunk some time in the future.\n//\n// Here's how this works:\n//\n// The Transform stream has all the aspects of the readable and writable\n// stream classes.  When you write(chunk), that calls _write(chunk,cb)\n// internally, and returns false if there's a lot of pending writes\n// buffered up.  When you call read(), that calls _read(n) until\n// there's enough pending readable data buffered up.\n//\n// In a transform stream, the written data is placed in a buffer.  When\n// _read(n) is called, it transforms the queued up data, calling the\n// buffered _write cb's as it consumes chunks.  If consuming a single\n// written chunk would result in multiple output chunks, then the first\n// outputted bit calls the readcb, and subsequent chunks just go into\n// the read buffer, and will cause it to emit 'readable' if necessary.\n//\n// This way, back-pressure is actually determined by the reading side,\n// since _read has to be called to start processing a new chunk.  However,\n// a pathological inflate type of transform can cause excessive buffering\n// here.  For example, imagine a stream where every byte of input is\n// interpreted as an integer from 0-255, and then results in that many\n// bytes of output.  Writing the 4 bytes {ff,ff,ff,ff} would result in\n// 1kb of data being output.  In this case, you could write a very small\n// amount of input, and end up with a very large amount of output.  In\n// such a pathological inflating mechanism, there'd be no way to tell\n// the system to stop doing the transform.  A single 4MB write could\n// cause the system to run out of memory.\n//\n// However, even in such a pathological case, only a single written chunk\n// would be consumed, and then the rest would wait (un-transformed) until\n// the results of the previous transformed chunk were consumed.\n\n'use strict';\n\nmodule.exports = Transform;\n\nvar Duplex = require('./_stream_duplex');\n\n/*<replacement>*/\nvar util = require('core-util-is');\nutil.inherits = require('inherits');\n/*</replacement>*/\n\nutil.inherits(Transform, Duplex);\n\n\nfunction TransformState(stream) {\n  this.afterTransform = function(er, data) {\n    return afterTransform(stream, er, data);\n  };\n\n  this.needTransform = false;\n  this.transforming = false;\n  this.writecb = null;\n  this.writechunk = null;\n}\n\nfunction afterTransform(stream, er, data) {\n  var ts = stream._transformState;\n  ts.transforming = false;\n\n  var cb = ts.writecb;\n\n  if (!cb)\n    return stream.emit('error', new Error('no writecb in Transform class'));\n\n  ts.writechunk = null;\n  ts.writecb = null;\n\n  if (data !== null && data !== undefined)\n    stream.push(data);\n\n  if (cb)\n    cb(er);\n\n  var rs = stream._readableState;\n  rs.reading = false;\n  if (rs.needReadable || rs.length < rs.highWaterMark) {\n    stream._read(rs.highWaterMark);\n  }\n}\n\n\nfunction Transform(options) {\n  if (!(this instanceof Transform))\n    return new Transform(options);\n\n  Duplex.call(this, options);\n\n  this._transformState = new TransformState(this);\n\n  // when the writable side finishes, then flush out anything remaining.\n  var stream = this;\n\n  // start out asking for a readable event once data is transformed.\n  this._readableState.needReadable = true;\n\n  // we have implemented the _read method, and done the other things\n  // that Readable wants before the first _read call, so unset the\n  // sync guard flag.\n  this._readableState.sync = false;\n\n  if (options) {\n    if (typeof options.transform === 'function')\n      this._transform = options.transform;\n\n    if (typeof options.flush === 'function')\n      this._flush = options.flush;\n  }\n\n  this.once('prefinish', function() {\n    if (typeof this._flush === 'function')\n      this._flush(function(er) {\n        done(stream, er);\n      });\n    else\n      done(stream);\n  });\n}\n\nTransform.prototype.push = function(chunk, encoding) {\n  this._transformState.needTransform = false;\n  return Duplex.prototype.push.call(this, chunk, encoding);\n};\n\n// This is the part where you do stuff!\n// override this function in implementation classes.\n// 'chunk' is an input chunk.\n//\n// Call `push(newChunk)` to pass along transformed output\n// to the readable side.  You may call 'push' zero or more times.\n//\n// Call `cb(err)` when you are done with this chunk.  If you pass\n// an error, then that'll put the hurt on the whole operation.  If you\n// never call cb(), then you'll never get another chunk.\nTransform.prototype._transform = function(chunk, encoding, cb) {\n  throw new Error('not implemented');\n};\n\nTransform.prototype._write = function(chunk, encoding, cb) {\n  var ts = this._transformState;\n  ts.writecb = cb;\n  ts.writechunk = chunk;\n  ts.writeencoding = encoding;\n  if (!ts.transforming) {\n    var rs = this._readableState;\n    if (ts.needTransform ||\n        rs.needReadable ||\n        rs.length < rs.highWaterMark)\n      this._read(rs.highWaterMark);\n  }\n};\n\n// Doesn't matter what the args are here.\n// _transform does all the work.\n// That we got here means that the readable side wants more data.\nTransform.prototype._read = function(n) {\n  var ts = this._transformState;\n\n  if (ts.writechunk !== null && ts.writecb && !ts.transforming) {\n    ts.transforming = true;\n    this._transform(ts.writechunk, ts.writeencoding, ts.afterTransform);\n  } else {\n    // mark that we need a transform, so that any data that comes in\n    // will get processed, now that we've asked for it.\n    ts.needTransform = true;\n  }\n};\n\n\nfunction done(stream, er) {\n  if (er)\n    return stream.emit('error', er);\n\n  // if there's nothing in the write buffer, then that means\n  // that nothing more will ever be provided\n  var ws = stream._writableState;\n  var ts = stream._transformState;\n\n  if (ws.length)\n    throw new Error('calling transform done when ws.length != 0');\n\n  if (ts.transforming)\n    throw new Error('calling transform done when still transforming');\n\n  return stream.push(null);\n}\n\n},{\"./_stream_duplex\":18,\"core-util-is\":23,\"inherits\":9}],22:[function(require,module,exports){\n// A bit simpler than readable streams.\n// Implement an async ._write(chunk, encoding, cb), and it'll handle all\n// the drain event emission and buffering.\n\n'use strict';\n\nmodule.exports = Writable;\n\n/*<replacement>*/\nvar processNextTick = require('process-nextick-args');\n/*</replacement>*/\n\n\n/*<replacement>*/\nvar Buffer = require('buffer').Buffer;\n/*</replacement>*/\n\nWritable.WritableState = WritableState;\n\n\n/*<replacement>*/\nvar util = require('core-util-is');\nutil.inherits = require('inherits');\n/*</replacement>*/\n\n\n/*<replacement>*/\nvar internalUtil = {\n  deprecate: require('util-deprecate')\n};\n/*</replacement>*/\n\n\n\n/*<replacement>*/\nvar Stream;\n(function (){try{\n  Stream = require('st' + 'ream');\n}catch(_){}finally{\n  if (!Stream)\n    Stream = require('events').EventEmitter;\n}}())\n/*</replacement>*/\n\nvar Buffer = require('buffer').Buffer;\n\nutil.inherits(Writable, Stream);\n\nfunction nop() {}\n\nfunction WriteReq(chunk, encoding, cb) {\n  this.chunk = chunk;\n  this.encoding = encoding;\n  this.callback = cb;\n  this.next = null;\n}\n\nfunction WritableState(options, stream) {\n  var Duplex = require('./_stream_duplex');\n\n  options = options || {};\n\n  // object stream flag to indicate whether or not this stream\n  // contains buffers or objects.\n  this.objectMode = !!options.objectMode;\n\n  if (stream instanceof Duplex)\n    this.objectMode = this.objectMode || !!options.writableObjectMode;\n\n  // the point at which write() starts returning false\n  // Note: 0 is a valid value, means that we always return false if\n  // the entire buffer is not flushed immediately on write()\n  var hwm = options.highWaterMark;\n  var defaultHwm = this.objectMode ? 16 : 16 * 1024;\n  this.highWaterMark = (hwm || hwm === 0) ? hwm : defaultHwm;\n\n  // cast to ints.\n  this.highWaterMark = ~~this.highWaterMark;\n\n  this.needDrain = false;\n  // at the start of calling end()\n  this.ending = false;\n  // when end() has been called, and returned\n  this.ended = false;\n  // when 'finish' is emitted\n  this.finished = false;\n\n  // should we decode strings into buffers before passing to _write?\n  // this is here so that some node-core streams can optimize string\n  // handling at a lower level.\n  var noDecode = options.decodeStrings === false;\n  this.decodeStrings = !noDecode;\n\n  // Crypto is kind of old and crusty.  Historically, its default string\n  // encoding is 'binary' so we have to make this configurable.\n  // Everything else in the universe uses 'utf8', though.\n  this.defaultEncoding = options.defaultEncoding || 'utf8';\n\n  // not an actual buffer we keep track of, but a measurement\n  // of how much we're waiting to get pushed to some underlying\n  // socket or file.\n  this.length = 0;\n\n  // a flag to see when we're in the middle of a write.\n  this.writing = false;\n\n  // when true all writes will be buffered until .uncork() call\n  this.corked = 0;\n\n  // a flag to be able to tell if the onwrite cb is called immediately,\n  // or on a later tick.  We set this to true at first, because any\n  // actions that shouldn't happen until \"later\" should generally also\n  // not happen before the first write call.\n  this.sync = true;\n\n  // a flag to know if we're processing previously buffered items, which\n  // may call the _write() callback in the same tick, so that we don't\n  // end up in an overlapped onwrite situation.\n  this.bufferProcessing = false;\n\n  // the callback that's passed to _write(chunk,cb)\n  this.onwrite = function(er) {\n    onwrite(stream, er);\n  };\n\n  // the callback that the user supplies to write(chunk,encoding,cb)\n  this.writecb = null;\n\n  // the amount that is being written when _write is called.\n  this.writelen = 0;\n\n  this.bufferedRequest = null;\n  this.lastBufferedRequest = null;\n\n  // number of pending user-supplied write callbacks\n  // this must be 0 before 'finish' can be emitted\n  this.pendingcb = 0;\n\n  // emit prefinish if the only thing we're waiting for is _write cbs\n  // This is relevant for synchronous Transform streams\n  this.prefinished = false;\n\n  // True if the error was already emitted and should not be thrown again\n  this.errorEmitted = false;\n}\n\nWritableState.prototype.getBuffer = function writableStateGetBuffer() {\n  var current = this.bufferedRequest;\n  var out = [];\n  while (current) {\n    out.push(current);\n    current = current.next;\n  }\n  return out;\n};\n\n(function (){try {\nObject.defineProperty(WritableState.prototype, 'buffer', {\n  get: internalUtil.deprecate(function() {\n    return this.getBuffer();\n  }, '_writableState.buffer is deprecated. Use _writableState.getBuffer ' +\n     'instead.')\n});\n}catch(_){}}());\n\n\nfunction Writable(options) {\n  var Duplex = require('./_stream_duplex');\n\n  // Writable ctor is applied to Duplexes, though they're not\n  // instanceof Writable, they're instanceof Readable.\n  if (!(this instanceof Writable) && !(this instanceof Duplex))\n    return new Writable(options);\n\n  this._writableState = new WritableState(options, this);\n\n  // legacy.\n  this.writable = true;\n\n  if (options) {\n    if (typeof options.write === 'function')\n      this._write = options.write;\n\n    if (typeof options.writev === 'function')\n      this._writev = options.writev;\n  }\n\n  Stream.call(this);\n}\n\n// Otherwise people can pipe Writable streams, which is just wrong.\nWritable.prototype.pipe = function() {\n  this.emit('error', new Error('Cannot pipe. Not readable.'));\n};\n\n\nfunction writeAfterEnd(stream, cb) {\n  var er = new Error('write after end');\n  // TODO: defer error events consistently everywhere, not just the cb\n  stream.emit('error', er);\n  processNextTick(cb, er);\n}\n\n// If we get something that is not a buffer, string, null, or undefined,\n// and we're not in objectMode, then that's an error.\n// Otherwise stream chunks are all considered to be of length=1, and the\n// watermarks determine how many objects to keep in the buffer, rather than\n// how many bytes or characters.\nfunction validChunk(stream, state, chunk, cb) {\n  var valid = true;\n\n  if (!(Buffer.isBuffer(chunk)) &&\n      typeof chunk !== 'string' &&\n      chunk !== null &&\n      chunk !== undefined &&\n      !state.objectMode) {\n    var er = new TypeError('Invalid non-string/buffer chunk');\n    stream.emit('error', er);\n    processNextTick(cb, er);\n    valid = false;\n  }\n  return valid;\n}\n\nWritable.prototype.write = function(chunk, encoding, cb) {\n  var state = this._writableState;\n  var ret = false;\n\n  if (typeof encoding === 'function') {\n    cb = encoding;\n    encoding = null;\n  }\n\n  if (Buffer.isBuffer(chunk))\n    encoding = 'buffer';\n  else if (!encoding)\n    encoding = state.defaultEncoding;\n\n  if (typeof cb !== 'function')\n    cb = nop;\n\n  if (state.ended)\n    writeAfterEnd(this, cb);\n  else if (validChunk(this, state, chunk, cb)) {\n    state.pendingcb++;\n    ret = writeOrBuffer(this, state, chunk, encoding, cb);\n  }\n\n  return ret;\n};\n\nWritable.prototype.cork = function() {\n  var state = this._writableState;\n\n  state.corked++;\n};\n\nWritable.prototype.uncork = function() {\n  var state = this._writableState;\n\n  if (state.corked) {\n    state.corked--;\n\n    if (!state.writing &&\n        !state.corked &&\n        !state.finished &&\n        !state.bufferProcessing &&\n        state.bufferedRequest)\n      clearBuffer(this, state);\n  }\n};\n\nWritable.prototype.setDefaultEncoding = function setDefaultEncoding(encoding) {\n  // node::ParseEncoding() requires lower case.\n  if (typeof encoding === 'string')\n    encoding = encoding.toLowerCase();\n  if (!(['hex', 'utf8', 'utf-8', 'ascii', 'binary', 'base64',\n'ucs2', 'ucs-2','utf16le', 'utf-16le', 'raw']\n.indexOf((encoding + '').toLowerCase()) > -1))\n    throw new TypeError('Unknown encoding: ' + encoding);\n  this._writableState.defaultEncoding = encoding;\n};\n\nfunction decodeChunk(state, chunk, encoding) {\n  if (!state.objectMode &&\n      state.decodeStrings !== false &&\n      typeof chunk === 'string') {\n    chunk = new Buffer(chunk, encoding);\n  }\n  return chunk;\n}\n\n// if we're already writing something, then just put this\n// in the queue, and wait our turn.  Otherwise, call _write\n// If we return false, then we need a drain event, so set that flag.\nfunction writeOrBuffer(stream, state, chunk, encoding, cb) {\n  chunk = decodeChunk(state, chunk, encoding);\n\n  if (Buffer.isBuffer(chunk))\n    encoding = 'buffer';\n  var len = state.objectMode ? 1 : chunk.length;\n\n  state.length += len;\n\n  var ret = state.length < state.highWaterMark;\n  // we must ensure that previous needDrain will not be reset to false.\n  if (!ret)\n    state.needDrain = true;\n\n  if (state.writing || state.corked) {\n    var last = state.lastBufferedRequest;\n    state.lastBufferedRequest = new WriteReq(chunk, encoding, cb);\n    if (last) {\n      last.next = state.lastBufferedRequest;\n    } else {\n      state.bufferedRequest = state.lastBufferedRequest;\n    }\n  } else {\n    doWrite(stream, state, false, len, chunk, encoding, cb);\n  }\n\n  return ret;\n}\n\nfunction doWrite(stream, state, writev, len, chunk, encoding, cb) {\n  state.writelen = len;\n  state.writecb = cb;\n  state.writing = true;\n  state.sync = true;\n  if (writev)\n    stream._writev(chunk, state.onwrite);\n  else\n    stream._write(chunk, encoding, state.onwrite);\n  state.sync = false;\n}\n\nfunction onwriteError(stream, state, sync, er, cb) {\n  --state.pendingcb;\n  if (sync)\n    processNextTick(cb, er);\n  else\n    cb(er);\n\n  stream._writableState.errorEmitted = true;\n  stream.emit('error', er);\n}\n\nfunction onwriteStateUpdate(state) {\n  state.writing = false;\n  state.writecb = null;\n  state.length -= state.writelen;\n  state.writelen = 0;\n}\n\nfunction onwrite(stream, er) {\n  var state = stream._writableState;\n  var sync = state.sync;\n  var cb = state.writecb;\n\n  onwriteStateUpdate(state);\n\n  if (er)\n    onwriteError(stream, state, sync, er, cb);\n  else {\n    // Check if we're actually ready to finish, but don't emit yet\n    var finished = needFinish(state);\n\n    if (!finished &&\n        !state.corked &&\n        !state.bufferProcessing &&\n        state.bufferedRequest) {\n      clearBuffer(stream, state);\n    }\n\n    if (sync) {\n      processNextTick(afterWrite, stream, state, finished, cb);\n    } else {\n      afterWrite(stream, state, finished, cb);\n    }\n  }\n}\n\nfunction afterWrite(stream, state, finished, cb) {\n  if (!finished)\n    onwriteDrain(stream, state);\n  state.pendingcb--;\n  cb();\n  finishMaybe(stream, state);\n}\n\n// Must force callback to be called on nextTick, so that we don't\n// emit 'drain' before the write() consumer gets the 'false' return\n// value, and has a chance to attach a 'drain' listener.\nfunction onwriteDrain(stream, state) {\n  if (state.length === 0 && state.needDrain) {\n    state.needDrain = false;\n    stream.emit('drain');\n  }\n}\n\n\n// if there's something in the buffer waiting, then process it\nfunction clearBuffer(stream, state) {\n  state.bufferProcessing = true;\n  var entry = state.bufferedRequest;\n\n  if (stream._writev && entry && entry.next) {\n    // Fast case, write everything using _writev()\n    var buffer = [];\n    var cbs = [];\n    while (entry) {\n      cbs.push(entry.callback);\n      buffer.push(entry);\n      entry = entry.next;\n    }\n\n    // count the one we are adding, as well.\n    // TODO(isaacs) clean this up\n    state.pendingcb++;\n    state.lastBufferedRequest = null;\n    doWrite(stream, state, true, state.length, buffer, '', function(err) {\n      for (var i = 0; i < cbs.length; i++) {\n        state.pendingcb--;\n        cbs[i](err);\n      }\n    });\n\n    // Clear buffer\n  } else {\n    // Slow case, write chunks one-by-one\n    while (entry) {\n      var chunk = entry.chunk;\n      var encoding = entry.encoding;\n      var cb = entry.callback;\n      var len = state.objectMode ? 1 : chunk.length;\n\n      doWrite(stream, state, false, len, chunk, encoding, cb);\n      entry = entry.next;\n      // if we didn't call the onwrite immediately, then\n      // it means that we need to wait until it does.\n      // also, that means that the chunk and cb are currently\n      // being processed, so move the buffer counter past them.\n      if (state.writing) {\n        break;\n      }\n    }\n\n    if (entry === null)\n      state.lastBufferedRequest = null;\n  }\n  state.bufferedRequest = entry;\n  state.bufferProcessing = false;\n}\n\nWritable.prototype._write = function(chunk, encoding, cb) {\n  cb(new Error('not implemented'));\n};\n\nWritable.prototype._writev = null;\n\nWritable.prototype.end = function(chunk, encoding, cb) {\n  var state = this._writableState;\n\n  if (typeof chunk === 'function') {\n    cb = chunk;\n    chunk = null;\n    encoding = null;\n  } else if (typeof encoding === 'function') {\n    cb = encoding;\n    encoding = null;\n  }\n\n  if (chunk !== null && chunk !== undefined)\n    this.write(chunk, encoding);\n\n  // .end() fully uncorks\n  if (state.corked) {\n    state.corked = 1;\n    this.uncork();\n  }\n\n  // ignore unnecessary end() calls.\n  if (!state.ending && !state.finished)\n    endWritable(this, state, cb);\n};\n\n\nfunction needFinish(state) {\n  return (state.ending &&\n          state.length === 0 &&\n          state.bufferedRequest === null &&\n          !state.finished &&\n          !state.writing);\n}\n\nfunction prefinish(stream, state) {\n  if (!state.prefinished) {\n    state.prefinished = true;\n    stream.emit('prefinish');\n  }\n}\n\nfunction finishMaybe(stream, state) {\n  var need = needFinish(state);\n  if (need) {\n    if (state.pendingcb === 0) {\n      prefinish(stream, state);\n      state.finished = true;\n      stream.emit('finish');\n    } else {\n      prefinish(stream, state);\n    }\n  }\n  return need;\n}\n\nfunction endWritable(stream, state, cb) {\n  state.ending = true;\n  finishMaybe(stream, state);\n  if (cb) {\n    if (state.finished)\n      processNextTick(cb);\n    else\n      stream.once('finish', cb);\n  }\n  state.ended = true;\n}\n\n},{\"./_stream_duplex\":18,\"buffer\":3,\"core-util-is\":23,\"events\":7,\"inherits\":9,\"process-nextick-args\":24,\"util-deprecate\":25}],23:[function(require,module,exports){\n(function (Buffer){\n// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n// NOTE: These type checking functions intentionally don't use `instanceof`\n// because it is fragile and can be easily faked with `Object.create()`.\n\nfunction isArray(arg) {\n  if (Array.isArray) {\n    return Array.isArray(arg);\n  }\n  return objectToString(arg) === '[object Array]';\n}\nexports.isArray = isArray;\n\nfunction isBoolean(arg) {\n  return typeof arg === 'boolean';\n}\nexports.isBoolean = isBoolean;\n\nfunction isNull(arg) {\n  return arg === null;\n}\nexports.isNull = isNull;\n\nfunction isNullOrUndefined(arg) {\n  return arg == null;\n}\nexports.isNullOrUndefined = isNullOrUndefined;\n\nfunction isNumber(arg) {\n  return typeof arg === 'number';\n}\nexports.isNumber = isNumber;\n\nfunction isString(arg) {\n  return typeof arg === 'string';\n}\nexports.isString = isString;\n\nfunction isSymbol(arg) {\n  return typeof arg === 'symbol';\n}\nexports.isSymbol = isSymbol;\n\nfunction isUndefined(arg) {\n  return arg === void 0;\n}\nexports.isUndefined = isUndefined;\n\nfunction isRegExp(re) {\n  return objectToString(re) === '[object RegExp]';\n}\nexports.isRegExp = isRegExp;\n\nfunction isObject(arg) {\n  return typeof arg === 'object' && arg !== null;\n}\nexports.isObject = isObject;\n\nfunction isDate(d) {\n  return objectToString(d) === '[object Date]';\n}\nexports.isDate = isDate;\n\nfunction isError(e) {\n  return (objectToString(e) === '[object Error]' || e instanceof Error);\n}\nexports.isError = isError;\n\nfunction isFunction(arg) {\n  return typeof arg === 'function';\n}\nexports.isFunction = isFunction;\n\nfunction isPrimitive(arg) {\n  return arg === null ||\n         typeof arg === 'boolean' ||\n         typeof arg === 'number' ||\n         typeof arg === 'string' ||\n         typeof arg === 'symbol' ||  // ES6 symbol\n         typeof arg === 'undefined';\n}\nexports.isPrimitive = isPrimitive;\n\nexports.isBuffer = Buffer.isBuffer;\n\nfunction objectToString(o) {\n  return Object.prototype.toString.call(o);\n}\n\n}).call(this,{\"isBuffer\":require(\"../../../../insert-module-globals/node_modules/is-buffer/index.js\")})\n\n},{\"../../../../insert-module-globals/node_modules/is-buffer/index.js\":10}],24:[function(require,module,exports){\n(function (process){\n'use strict';\n\nif (!process.version ||\n    process.version.indexOf('v0.') === 0 ||\n    process.version.indexOf('v1.') === 0 && process.version.indexOf('v1.8.') !== 0) {\n  module.exports = nextTick;\n} else {\n  module.exports = process.nextTick;\n}\n\nfunction nextTick(fn) {\n  var args = new Array(arguments.length - 1);\n  var i = 0;\n  while (i < args.length) {\n    args[i++] = arguments[i];\n  }\n  process.nextTick(function afterTick() {\n    fn.apply(null, args);\n  });\n}\n\n}).call(this,require('_process'))\n\n},{\"_process\":12}],25:[function(require,module,exports){\n(function (global){\n\n/**\n * Module exports.\n */\n\nmodule.exports = deprecate;\n\n/**\n * Mark that a method should not be used.\n * Returns a modified function which warns once by default.\n *\n * If `localStorage.noDeprecation = true` is set, then it is a no-op.\n *\n * If `localStorage.throwDeprecation = true` is set, then deprecated functions\n * will throw an Error when invoked.\n *\n * If `localStorage.traceDeprecation = true` is set, then deprecated functions\n * will invoke `console.trace()` instead of `console.error()`.\n *\n * @param {Function} fn - the function to deprecate\n * @param {String} msg - the string to print to the console when `fn` is invoked\n * @returns {Function} a new \"deprecated\" version of `fn`\n * @api public\n */\n\nfunction deprecate (fn, msg) {\n  if (config('noDeprecation')) {\n    return fn;\n  }\n\n  var warned = false;\n  function deprecated() {\n    if (!warned) {\n      if (config('throwDeprecation')) {\n        throw new Error(msg);\n      } else if (config('traceDeprecation')) {\n        console.trace(msg);\n      } else {\n        console.warn(msg);\n      }\n      warned = true;\n    }\n    return fn.apply(this, arguments);\n  }\n\n  return deprecated;\n}\n\n/**\n * Checks `localStorage` for boolean values for the given `name`.\n *\n * @param {String} name\n * @returns {Boolean}\n * @api private\n */\n\nfunction config (name) {\n  // accessing global.localStorage can trigger a DOMException in sandboxed iframes\n  try {\n    if (!global.localStorage) return false;\n  } catch (_) {\n    return false;\n  }\n  var val = global.localStorage[name];\n  if (null == val) return false;\n  return String(val).toLowerCase() === 'true';\n}\n\n}).call(this,typeof global !== \"undefined\" ? global : typeof self !== \"undefined\" ? self : typeof window !== \"undefined\" ? window : {})\n\n},{}],26:[function(require,module,exports){\nmodule.exports = require(\"./lib/_stream_passthrough.js\")\n\n},{\"./lib/_stream_passthrough.js\":19}],27:[function(require,module,exports){\nvar Stream = (function (){\n  try {\n    return require('st' + 'ream'); // hack to fix a circular dependency issue when used with browserify\n  } catch(_){}\n}());\nexports = module.exports = require('./lib/_stream_readable.js');\nexports.Stream = Stream || exports;\nexports.Readable = exports;\nexports.Writable = require('./lib/_stream_writable.js');\nexports.Duplex = require('./lib/_stream_duplex.js');\nexports.Transform = require('./lib/_stream_transform.js');\nexports.PassThrough = require('./lib/_stream_passthrough.js');\n\n},{\"./lib/_stream_duplex.js\":18,\"./lib/_stream_passthrough.js\":19,\"./lib/_stream_readable.js\":20,\"./lib/_stream_transform.js\":21,\"./lib/_stream_writable.js\":22}],28:[function(require,module,exports){\nmodule.exports = require(\"./lib/_stream_transform.js\")\n\n},{\"./lib/_stream_transform.js\":21}],29:[function(require,module,exports){\nmodule.exports = require(\"./lib/_stream_writable.js\")\n\n},{\"./lib/_stream_writable.js\":22}],30:[function(require,module,exports){\n// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\nmodule.exports = Stream;\n\nvar EE = require('events').EventEmitter;\nvar inherits = require('inherits');\n\ninherits(Stream, EE);\nStream.Readable = require('readable-stream/readable.js');\nStream.Writable = require('readable-stream/writable.js');\nStream.Duplex = require('readable-stream/duplex.js');\nStream.Transform = require('readable-stream/transform.js');\nStream.PassThrough = require('readable-stream/passthrough.js');\n\n// Backwards-compat with node 0.4.x\nStream.Stream = Stream;\n\n\n\n// old-style streams.  Note that the pipe method (the only relevant\n// part of this class) is overridden in the Readable class.\n\nfunction Stream() {\n  EE.call(this);\n}\n\nStream.prototype.pipe = function(dest, options) {\n  var source = this;\n\n  function ondata(chunk) {\n    if (dest.writable) {\n      if (false === dest.write(chunk) && source.pause) {\n        source.pause();\n      }\n    }\n  }\n\n  source.on('data', ondata);\n\n  function ondrain() {\n    if (source.readable && source.resume) {\n      source.resume();\n    }\n  }\n\n  dest.on('drain', ondrain);\n\n  // If the 'end' option is not supplied, dest.end() will be called when\n  // source gets the 'end' or 'close' events.  Only dest.end() once.\n  if (!dest._isStdio && (!options || options.end !== false)) {\n    source.on('end', onend);\n    source.on('close', onclose);\n  }\n\n  var didOnEnd = false;\n  function onend() {\n    if (didOnEnd) return;\n    didOnEnd = true;\n\n    dest.end();\n  }\n\n\n  function onclose() {\n    if (didOnEnd) return;\n    didOnEnd = true;\n\n    if (typeof dest.destroy === 'function') dest.destroy();\n  }\n\n  // don't leave dangling pipes when there are errors.\n  function onerror(er) {\n    cleanup();\n    if (EE.listenerCount(this, 'error') === 0) {\n      throw er; // Unhandled stream error in pipe.\n    }\n  }\n\n  source.on('error', onerror);\n  dest.on('error', onerror);\n\n  // remove all the event listeners that were added.\n  function cleanup() {\n    source.removeListener('data', ondata);\n    dest.removeListener('drain', ondrain);\n\n    source.removeListener('end', onend);\n    source.removeListener('close', onclose);\n\n    source.removeListener('error', onerror);\n    dest.removeListener('error', onerror);\n\n    source.removeListener('end', cleanup);\n    source.removeListener('close', cleanup);\n\n    dest.removeListener('close', cleanup);\n  }\n\n  source.on('end', cleanup);\n  source.on('close', cleanup);\n\n  dest.on('close', cleanup);\n\n  dest.emit('pipe', source);\n\n  // Allow for unix-like usage: A.pipe(B).pipe(C)\n  return dest;\n};\n\n},{\"events\":7,\"inherits\":9,\"readable-stream/duplex.js\":17,\"readable-stream/passthrough.js\":26,\"readable-stream/readable.js\":27,\"readable-stream/transform.js\":28,\"readable-stream/writable.js\":29}],31:[function(require,module,exports){\nvar ClientRequest = require('./lib/request')\nvar extend = require('xtend')\nvar statusCodes = require('builtin-status-codes')\nvar url = require('url')\n\nvar http = exports\n\nhttp.request = function (opts, cb) {\n\tif (typeof opts === 'string')\n\t\topts = url.parse(opts)\n\telse\n\t\topts = extend(opts)\n\n\tvar protocol = opts.protocol || ''\n\tvar host = opts.hostname || opts.host\n\tvar port = opts.port\n\tvar path = opts.path || '/'\n\n\t// Necessary for IPv6 addresses\n\tif (host && host.indexOf(':') !== -1)\n\t\thost = '[' + host + ']'\n\n\t// This may be a relative url. The browser should always be able to interpret it correctly.\n\topts.url = (host ? (protocol + '//' + host) : '') + (port ? ':' + port : '') + path\n\topts.method = (opts.method || 'GET').toUpperCase()\n\topts.headers = opts.headers || {}\n\n\t// Also valid opts.auth, opts.mode\n\n\tvar req = new ClientRequest(opts)\n\tif (cb)\n\t\treq.on('response', cb)\n\treturn req\n}\n\nhttp.get = function get (opts, cb) {\n\tvar req = http.request(opts, cb)\n\treq.end()\n\treturn req\n}\n\nhttp.Agent = function () {}\nhttp.Agent.defaultMaxSockets = 4\n\nhttp.STATUS_CODES = statusCodes\n\nhttp.METHODS = [\n\t'CHECKOUT',\n\t'CONNECT',\n\t'COPY',\n\t'DELETE',\n\t'GET',\n\t'HEAD',\n\t'LOCK',\n\t'M-SEARCH',\n\t'MERGE',\n\t'MKACTIVITY',\n\t'MKCOL',\n\t'MOVE',\n\t'NOTIFY',\n\t'OPTIONS',\n\t'PATCH',\n\t'POST',\n\t'PROPFIND',\n\t'PROPPATCH',\n\t'PURGE',\n\t'PUT',\n\t'REPORT',\n\t'SEARCH',\n\t'SUBSCRIBE',\n\t'TRACE',\n\t'UNLOCK',\n\t'UNSUBSCRIBE'\n]\n},{\"./lib/request\":33,\"builtin-status-codes\":35,\"url\":37,\"xtend\":39}],32:[function(require,module,exports){\n(function (global){\nexports.fetch = isFunction(global.fetch) && isFunction(global.ReadableByteStream)\n\nexports.blobConstructor = false\ntry {\n\tnew Blob([new ArrayBuffer(1)])\n\texports.blobConstructor = true\n} catch (e) {}\n\nvar xhr = new global.XMLHttpRequest()\n// If location.host is empty, e.g. if this page/worker was loaded\n// from a Blob, then use example.com to avoid an error\nxhr.open('GET', global.location.host ? '/' : 'https://example.com')\n\nfunction checkTypeSupport (type) {\n\ttry {\n\t\txhr.responseType = type\n\t\treturn xhr.responseType === type\n\t} catch (e) {}\n\treturn false\n}\n\n// For some strange reason, Safari 7.0 reports typeof global.ArrayBuffer === 'object'.\n// Safari 7.1 appears to have fixed this bug.\nvar haveArrayBuffer = typeof global.ArrayBuffer !== 'undefined'\nvar haveSlice = haveArrayBuffer && isFunction(global.ArrayBuffer.prototype.slice)\n\nexports.arraybuffer = haveArrayBuffer && checkTypeSupport('arraybuffer')\n// These next two tests unavoidably show warnings in Chrome. Since fetch will always\n// be used if it's available, just return false for these to avoid the warnings.\nexports.msstream = !exports.fetch && haveSlice && checkTypeSupport('ms-stream')\nexports.mozchunkedarraybuffer = !exports.fetch && haveArrayBuffer &&\n\tcheckTypeSupport('moz-chunked-arraybuffer')\nexports.overrideMimeType = isFunction(xhr.overrideMimeType)\nexports.vbArray = isFunction(global.VBArray)\n\nfunction isFunction (value) {\n  return typeof value === 'function'\n}\n\nxhr = null // Help gc\n\n}).call(this,typeof global !== \"undefined\" ? global : typeof self !== \"undefined\" ? self : typeof window !== \"undefined\" ? window : {})\n\n},{}],33:[function(require,module,exports){\n(function (process,global,Buffer){\n// var Base64 = require('Base64')\nvar capability = require('./capability')\nvar inherits = require('inherits')\nvar response = require('./response')\nvar stream = require('stream')\n\nvar IncomingMessage = response.IncomingMessage\nvar rStates = response.readyStates\n\nfunction decideMode (preferBinary) {\n\tif (capability.fetch) {\n\t\treturn 'fetch'\n\t} else if (capability.mozchunkedarraybuffer) {\n\t\treturn 'moz-chunked-arraybuffer'\n\t} else if (capability.msstream) {\n\t\treturn 'ms-stream'\n\t} else if (capability.arraybuffer && preferBinary) {\n\t\treturn 'arraybuffer'\n\t} else if (capability.vbArray && preferBinary) {\n\t\treturn 'text:vbarray'\n\t} else {\n\t\treturn 'text'\n\t}\n}\n\nvar ClientRequest = module.exports = function (opts) {\n\tvar self = this\n\tstream.Writable.call(self)\n\n\tself._opts = opts\n\tself._body = []\n\tself._headers = {}\n\tif (opts.auth)\n\t\tself.setHeader('Authorization', 'Basic ' + new Buffer(opts.auth).toString('base64'))\n\tObject.keys(opts.headers).forEach(function (name) {\n\t\tself.setHeader(name, opts.headers[name])\n\t})\n\n\tvar preferBinary\n\tif (opts.mode === 'prefer-streaming') {\n\t\t// If streaming is a high priority but binary compatibility and\n\t\t// the accuracy of the 'content-type' header aren't\n\t\tpreferBinary = false\n\t} else if (opts.mode === 'allow-wrong-content-type') {\n\t\t// If streaming is more important than preserving the 'content-type' header\n\t\tpreferBinary = !capability.overrideMimeType\n\t} else if (!opts.mode || opts.mode === 'default' || opts.mode === 'prefer-fast') {\n\t\t// Use binary if text streaming may corrupt data or the content-type header, or for speed\n\t\tpreferBinary = true\n\t} else {\n\t\tthrow new Error('Invalid value for opts.mode')\n\t}\n\tself._mode = decideMode(preferBinary)\n\n\tself.on('finish', function () {\n\t\tself._onFinish()\n\t})\n}\n\ninherits(ClientRequest, stream.Writable)\n\nClientRequest.prototype.setHeader = function (name, value) {\n\tvar self = this\n\tvar lowerName = name.toLowerCase()\n\t// This check is not necessary, but it prevents warnings from browsers about setting unsafe\n\t// headers. To be honest I'm not entirely sure hiding these warnings is a good thing, but\n\t// http-browserify did it, so I will too.\n\tif (unsafeHeaders.indexOf(lowerName) !== -1)\n\t\treturn\n\n\tself._headers[lowerName] = {\n\t\tname: name,\n\t\tvalue: value\n\t}\n}\n\nClientRequest.prototype.getHeader = function (name) {\n\tvar self = this\n\treturn self._headers[name.toLowerCase()].value\n}\n\nClientRequest.prototype.removeHeader = function (name) {\n\tvar self = this\n\tdelete self._headers[name.toLowerCase()]\n}\n\nClientRequest.prototype._onFinish = function () {\n\tvar self = this\n\n\tif (self._destroyed)\n\t\treturn\n\tvar opts = self._opts\n\n\tvar headersObj = self._headers\n\tvar body\n\tif (opts.method === 'POST' || opts.method === 'PUT' || opts.method === 'PATCH') {\n\t\tif (capability.blobConstructor) {\n\t\t\tbody = new global.Blob(self._body.map(function (buffer) {\n\t\t\t\treturn buffer.toArrayBuffer()\n\t\t\t}), {\n\t\t\t\ttype: (headersObj['content-type'] || {}).value || ''\n\t\t\t})\n\t\t} else {\n\t\t\t// get utf8 string\n\t\t\tbody = Buffer.concat(self._body).toString()\n\t\t}\n\t}\n\n\tif (self._mode === 'fetch') {\n\t\tvar headers = Object.keys(headersObj).map(function (name) {\n\t\t\treturn [headersObj[name].name, headersObj[name].value]\n\t\t})\n\n\t\tglobal.fetch(self._opts.url, {\n\t\t\tmethod: self._opts.method,\n\t\t\theaders: headers,\n\t\t\tbody: body,\n\t\t\tmode: 'cors',\n\t\t\tcredentials: opts.withCredentials ? 'include' : 'same-origin'\n\t\t}).then(function (response) {\n\t\t\tself._fetchResponse = response\n\t\t\tself._connect()\n\t\t}, function (reason) {\n\t\t\tself.emit('error', reason)\n\t\t})\n\t} else {\n\t\tvar xhr = self._xhr = new global.XMLHttpRequest()\n\t\ttry {\n\t\t\txhr.open(self._opts.method, self._opts.url, true)\n\t\t} catch (err) {\n\t\t\tprocess.nextTick(function () {\n\t\t\t\tself.emit('error', err)\n\t\t\t})\n\t\t\treturn\n\t\t}\n\n\t\t// Can't set responseType on really old browsers\n\t\tif ('responseType' in xhr)\n\t\t\txhr.responseType = self._mode.split(':')[0]\n\n\t\tif ('withCredentials' in xhr)\n\t\t\txhr.withCredentials = !!opts.withCredentials\n\n\t\tif (self._mode === 'text' && 'overrideMimeType' in xhr)\n\t\t\txhr.overrideMimeType('text/plain; charset=x-user-defined')\n\n\t\tObject.keys(headersObj).forEach(function (name) {\n\t\t\txhr.setRequestHeader(headersObj[name].name, headersObj[name].value)\n\t\t})\n\n\t\tself._response = null\n\t\txhr.onreadystatechange = function () {\n\t\t\tswitch (xhr.readyState) {\n\t\t\t\tcase rStates.LOADING:\n\t\t\t\tcase rStates.DONE:\n\t\t\t\t\tself._onXHRProgress()\n\t\t\t\t\tbreak\n\t\t\t}\n\t\t}\n\t\t// Necessary for streaming in Firefox, since xhr.response is ONLY defined\n\t\t// in onprogress, not in onreadystatechange with xhr.readyState = 3\n\t\tif (self._mode === 'moz-chunked-arraybuffer') {\n\t\t\txhr.onprogress = function () {\n\t\t\t\tself._onXHRProgress()\n\t\t\t}\n\t\t}\n\n\t\txhr.onerror = function () {\n\t\t\tif (self._destroyed)\n\t\t\t\treturn\n\t\t\tself.emit('error', new Error('XHR error'))\n\t\t}\n\n\t\ttry {\n\t\t\txhr.send(body)\n\t\t} catch (err) {\n\t\t\tprocess.nextTick(function () {\n\t\t\t\tself.emit('error', err)\n\t\t\t})\n\t\t\treturn\n\t\t}\n\t}\n}\n\n/**\n * Checks if xhr.status is readable. Even though the spec says it should\n * be available in readyState 3, accessing it throws an exception in IE8\n */\nfunction statusValid (xhr) {\n\ttry {\n\t\treturn (xhr.status !== null)\n\t} catch (e) {\n\t\treturn false\n\t}\n}\n\nClientRequest.prototype._onXHRProgress = function () {\n\tvar self = this\n\n\tif (!statusValid(self._xhr) || self._destroyed)\n\t\treturn\n\n\tif (!self._response)\n\t\tself._connect()\n\n\tself._response._onXHRProgress()\n}\n\nClientRequest.prototype._connect = function () {\n\tvar self = this\n\n\tif (self._destroyed)\n\t\treturn\n\n\tself._response = new IncomingMessage(self._xhr, self._fetchResponse, self._mode)\n\tself.emit('response', self._response)\n}\n\nClientRequest.prototype._write = function (chunk, encoding, cb) {\n\tvar self = this\n\n\tself._body.push(chunk)\n\tcb()\n}\n\nClientRequest.prototype.abort = ClientRequest.prototype.destroy = function () {\n\tvar self = this\n\tself._destroyed = true\n\tif (self._response)\n\t\tself._response._destroyed = true\n\tif (self._xhr)\n\t\tself._xhr.abort()\n\t// Currently, there isn't a way to truly abort a fetch.\n\t// If you like bikeshedding, see https://github.com/whatwg/fetch/issues/27\n}\n\nClientRequest.prototype.end = function (data, encoding, cb) {\n\tvar self = this\n\tif (typeof data === 'function') {\n\t\tcb = data\n\t\tdata = undefined\n\t}\n\n\tstream.Writable.prototype.end.call(self, data, encoding, cb)\n}\n\nClientRequest.prototype.flushHeaders = function () {}\nClientRequest.prototype.setTimeout = function () {}\nClientRequest.prototype.setNoDelay = function () {}\nClientRequest.prototype.setSocketKeepAlive = function () {}\n\n// Taken from http://www.w3.org/TR/XMLHttpRequest/#the-setrequestheader%28%29-method\nvar unsafeHeaders = [\n\t'accept-charset',\n\t'accept-encoding',\n\t'access-control-request-headers',\n\t'access-control-request-method',\n\t'connection',\n\t'content-length',\n\t'cookie',\n\t'cookie2',\n\t'date',\n\t'dnt',\n\t'expect',\n\t'host',\n\t'keep-alive',\n\t'origin',\n\t'referer',\n\t'te',\n\t'trailer',\n\t'transfer-encoding',\n\t'upgrade',\n\t'user-agent',\n\t'via'\n]\n\n}).call(this,require('_process'),typeof global !== \"undefined\" ? global : typeof self !== \"undefined\" ? self : typeof window !== \"undefined\" ? window : {},require(\"buffer\").Buffer)\n\n},{\"./capability\":32,\"./response\":34,\"_process\":12,\"buffer\":3,\"inherits\":9,\"stream\":30}],34:[function(require,module,exports){\n(function (process,global,Buffer){\nvar capability = require('./capability')\nvar inherits = require('inherits')\nvar stream = require('stream')\n\nvar rStates = exports.readyStates = {\n\tUNSENT: 0,\n\tOPENED: 1,\n\tHEADERS_RECEIVED: 2,\n\tLOADING: 3,\n\tDONE: 4\n}\n\nvar IncomingMessage = exports.IncomingMessage = function (xhr, response, mode) {\n\tvar self = this\n\tstream.Readable.call(self)\n\n\tself._mode = mode\n\tself.headers = {}\n\tself.rawHeaders = []\n\tself.trailers = {}\n\tself.rawTrailers = []\n\n\t// Fake the 'close' event, but only once 'end' fires\n\tself.on('end', function () {\n\t\t// The nextTick is necessary to prevent the 'request' module from causing an infinite loop\n\t\tprocess.nextTick(function () {\n\t\t\tself.emit('close')\n\t\t})\n\t})\n\n\tif (mode === 'fetch') {\n\t\tself._fetchResponse = response\n\n\t\tself.statusCode = response.status\n\t\tself.statusMessage = response.statusText\n\t\t// backwards compatible version of for (<item> of <iterable>):\n\t\t// for (var <item>,_i,_it = <iterable>[Symbol.iterator](); <item> = (_i = _it.next()).value,!_i.done;)\n\t\tfor (var header, _i, _it = response.headers[Symbol.iterator](); header = (_i = _it.next()).value, !_i.done;) {\n\t\t\tself.headers[header[0].toLowerCase()] = header[1]\n\t\t\tself.rawHeaders.push(header[0], header[1])\n\t\t}\n\n\t\t// TODO: this doesn't respect backpressure. Once WritableStream is available, this can be fixed\n\t\tvar reader = response.body.getReader()\n\t\tfunction read () {\n\t\t\treader.read().then(function (result) {\n\t\t\t\tif (self._destroyed)\n\t\t\t\t\treturn\n\t\t\t\tif (result.done) {\n\t\t\t\t\tself.push(null)\n\t\t\t\t\treturn\n\t\t\t\t}\n\t\t\t\tself.push(new Buffer(result.value))\n\t\t\t\tread()\n\t\t\t})\n\t\t}\n\t\tread()\n\n\t} else {\n\t\tself._xhr = xhr\n\t\tself._pos = 0\n\n\t\tself.statusCode = xhr.status\n\t\tself.statusMessage = xhr.statusText\n\t\tvar headers = xhr.getAllResponseHeaders().split(/\\r?\\n/)\n\t\theaders.forEach(function (header) {\n\t\t\tvar matches = header.match(/^([^:]+):\\s*(.*)/)\n\t\t\tif (matches) {\n\t\t\t\tvar key = matches[1].toLowerCase()\n\t\t\t\tif (self.headers[key] !== undefined)\n\t\t\t\t\tself.headers[key] += ', ' + matches[2]\n\t\t\t\telse\n\t\t\t\t\tself.headers[key] = matches[2]\n\t\t\t\tself.rawHeaders.push(matches[1], matches[2])\n\t\t\t}\n\t\t})\n\n\t\tself._charset = 'x-user-defined'\n\t\tif (!capability.overrideMimeType) {\n\t\t\tvar mimeType = self.rawHeaders['mime-type']\n\t\t\tif (mimeType) {\n\t\t\t\tvar charsetMatch = mimeType.match(/;\\s*charset=([^;])(;|$)/)\n\t\t\t\tif (charsetMatch) {\n\t\t\t\t\tself._charset = charsetMatch[1].toLowerCase()\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (!self._charset)\n\t\t\t\tself._charset = 'utf-8' // best guess\n\t\t}\n\t}\n}\n\ninherits(IncomingMessage, stream.Readable)\n\nIncomingMessage.prototype._read = function () {}\n\nIncomingMessage.prototype._onXHRProgress = function () {\n\tvar self = this\n\n\tvar xhr = self._xhr\n\n\tvar response = null\n\tswitch (self._mode) {\n\t\tcase 'text:vbarray': // For IE9\n\t\t\tif (xhr.readyState !== rStates.DONE)\n\t\t\t\tbreak\n\t\t\ttry {\n\t\t\t\t// This fails in IE8\n\t\t\t\tresponse = new global.VBArray(xhr.responseBody).toArray()\n\t\t\t} catch (e) {}\n\t\t\tif (response !== null) {\n\t\t\t\tself.push(new Buffer(response))\n\t\t\t\tbreak\n\t\t\t}\n\t\t\t// Falls through in IE8\t\n\t\tcase 'text':\n\t\t\ttry { // This will fail when readyState = 3 in IE9. Switch mode and wait for readyState = 4\n\t\t\t\tresponse = xhr.responseText\n\t\t\t} catch (e) {\n\t\t\t\tself._mode = 'text:vbarray'\n\t\t\t\tbreak\n\t\t\t}\n\t\t\tif (response.length > self._pos) {\n\t\t\t\tvar newData = response.substr(self._pos)\n\t\t\t\tif (self._charset === 'x-user-defined') {\n\t\t\t\t\tvar buffer = new Buffer(newData.length)\n\t\t\t\t\tfor (var i = 0; i < newData.length; i++)\n\t\t\t\t\t\tbuffer[i] = newData.charCodeAt(i) & 0xff\n\n\t\t\t\t\tself.push(buffer)\n\t\t\t\t} else {\n\t\t\t\t\tself.push(newData, self._charset)\n\t\t\t\t}\n\t\t\t\tself._pos = response.length\n\t\t\t}\n\t\t\tbreak\n\t\tcase 'arraybuffer':\n\t\t\tif (xhr.readyState !== rStates.DONE)\n\t\t\t\tbreak\n\t\t\tresponse = xhr.response\n\t\t\tself.push(new Buffer(new Uint8Array(response)))\n\t\t\tbreak\n\t\tcase 'moz-chunked-arraybuffer': // take whole\n\t\t\tresponse = xhr.response\n\t\t\tif (xhr.readyState !== rStates.LOADING || !response)\n\t\t\t\tbreak\n\t\t\tself.push(new Buffer(new Uint8Array(response)))\n\t\t\tbreak\n\t\tcase 'ms-stream':\n\t\t\tresponse = xhr.response\n\t\t\tif (xhr.readyState !== rStates.LOADING)\n\t\t\t\tbreak\n\t\t\tvar reader = new global.MSStreamReader()\n\t\t\treader.onprogress = function () {\n\t\t\t\tif (reader.result.byteLength > self._pos) {\n\t\t\t\t\tself.push(new Buffer(new Uint8Array(reader.result.slice(self._pos))))\n\t\t\t\t\tself._pos = reader.result.byteLength\n\t\t\t\t}\n\t\t\t}\n\t\t\treader.onload = function () {\n\t\t\t\tself.push(null)\n\t\t\t}\n\t\t\t// reader.onerror = ??? // TODO: this\n\t\t\treader.readAsArrayBuffer(response)\n\t\t\tbreak\n\t}\n\n\t// The ms-stream case handles end separately in reader.onload()\n\tif (self._xhr.readyState === rStates.DONE && self._mode !== 'ms-stream') {\n\t\tself.push(null)\n\t}\n}\n\n}).call(this,require('_process'),typeof global !== \"undefined\" ? global : typeof self !== \"undefined\" ? self : typeof window !== \"undefined\" ? window : {},require(\"buffer\").Buffer)\n\n},{\"./capability\":32,\"_process\":12,\"buffer\":3,\"inherits\":9,\"stream\":30}],35:[function(require,module,exports){\nmodule.exports = {\n  \"100\": \"Continue\",\n  \"101\": \"Switching Protocols\",\n  \"102\": \"Processing\",\n  \"200\": \"OK\",\n  \"201\": \"Created\",\n  \"202\": \"Accepted\",\n  \"203\": \"Non-Authoritative Information\",\n  \"204\": \"No Content\",\n  \"205\": \"Reset Content\",\n  \"206\": \"Partial Content\",\n  \"207\": \"Multi-Status\",\n  \"300\": \"Multiple Choices\",\n  \"301\": \"Moved Permanently\",\n  \"302\": \"Moved Temporarily\",\n  \"303\": \"See Other\",\n  \"304\": \"Not Modified\",\n  \"305\": \"Use Proxy\",\n  \"307\": \"Temporary Redirect\",\n  \"308\": \"Permanent Redirect\",\n  \"400\": \"Bad Request\",\n  \"401\": \"Unauthorized\",\n  \"402\": \"Payment Required\",\n  \"403\": \"Forbidden\",\n  \"404\": \"Not Found\",\n  \"405\": \"Method Not Allowed\",\n  \"406\": \"Not Acceptable\",\n  \"407\": \"Proxy Authentication Required\",\n  \"408\": \"Request Time-out\",\n  \"409\": \"Conflict\",\n  \"410\": \"Gone\",\n  \"411\": \"Length Required\",\n  \"412\": \"Precondition Failed\",\n  \"413\": \"Request Entity Too Large\",\n  \"414\": \"Request-URI Too Large\",\n  \"415\": \"Unsupported Media Type\",\n  \"416\": \"Requested Range Not Satisfiable\",\n  \"417\": \"Expectation Failed\",\n  \"418\": \"I'm a teapot\",\n  \"422\": \"Unprocessable Entity\",\n  \"423\": \"Locked\",\n  \"424\": \"Failed Dependency\",\n  \"425\": \"Unordered Collection\",\n  \"426\": \"Upgrade Required\",\n  \"428\": \"Precondition Required\",\n  \"429\": \"Too Many Requests\",\n  \"431\": \"Request Header Fields Too Large\",\n  \"500\": \"Internal Server Error\",\n  \"501\": \"Not Implemented\",\n  \"502\": \"Bad Gateway\",\n  \"503\": \"Service Unavailable\",\n  \"504\": \"Gateway Time-out\",\n  \"505\": \"HTTP Version Not Supported\",\n  \"506\": \"Variant Also Negotiates\",\n  \"507\": \"Insufficient Storage\",\n  \"509\": \"Bandwidth Limit Exceeded\",\n  \"510\": \"Not Extended\",\n  \"511\": \"Network Authentication Required\"\n}\n\n},{}],36:[function(require,module,exports){\n// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\nvar Buffer = require('buffer').Buffer;\n\nvar isBufferEncoding = Buffer.isEncoding\n  || function(encoding) {\n       switch (encoding && encoding.toLowerCase()) {\n         case 'hex': case 'utf8': case 'utf-8': case 'ascii': case 'binary': case 'base64': case 'ucs2': case 'ucs-2': case 'utf16le': case 'utf-16le': case 'raw': return true;\n         default: return false;\n       }\n     }\n\n\nfunction assertEncoding(encoding) {\n  if (encoding && !isBufferEncoding(encoding)) {\n    throw new Error('Unknown encoding: ' + encoding);\n  }\n}\n\n// StringDecoder provides an interface for efficiently splitting a series of\n// buffers into a series of JS strings without breaking apart multi-byte\n// characters. CESU-8 is handled as part of the UTF-8 encoding.\n//\n// @TODO Handling all encodings inside a single object makes it very difficult\n// to reason about this code, so it should be split up in the future.\n// @TODO There should be a utf8-strict encoding that rejects invalid UTF-8 code\n// points as used by CESU-8.\nvar StringDecoder = exports.StringDecoder = function(encoding) {\n  this.encoding = (encoding || 'utf8').toLowerCase().replace(/[-_]/, '');\n  assertEncoding(encoding);\n  switch (this.encoding) {\n    case 'utf8':\n      // CESU-8 represents each of Surrogate Pair by 3-bytes\n      this.surrogateSize = 3;\n      break;\n    case 'ucs2':\n    case 'utf16le':\n      // UTF-16 represents each of Surrogate Pair by 2-bytes\n      this.surrogateSize = 2;\n      this.detectIncompleteChar = utf16DetectIncompleteChar;\n      break;\n    case 'base64':\n      // Base-64 stores 3 bytes in 4 chars, and pads the remainder.\n      this.surrogateSize = 3;\n      this.detectIncompleteChar = base64DetectIncompleteChar;\n      break;\n    default:\n      this.write = passThroughWrite;\n      return;\n  }\n\n  // Enough space to store all bytes of a single character. UTF-8 needs 4\n  // bytes, but CESU-8 may require up to 6 (3 bytes per surrogate).\n  this.charBuffer = new Buffer(6);\n  // Number of bytes received for the current incomplete multi-byte character.\n  this.charReceived = 0;\n  // Number of bytes expected for the current incomplete multi-byte character.\n  this.charLength = 0;\n};\n\n\n// write decodes the given buffer and returns it as JS string that is\n// guaranteed to not contain any partial multi-byte characters. Any partial\n// character found at the end of the buffer is buffered up, and will be\n// returned when calling write again with the remaining bytes.\n//\n// Note: Converting a Buffer containing an orphan surrogate to a String\n// currently works, but converting a String to a Buffer (via `new Buffer`, or\n// Buffer#write) will replace incomplete surrogates with the unicode\n// replacement character. See https://codereview.chromium.org/121173009/ .\nStringDecoder.prototype.write = function(buffer) {\n  var charStr = '';\n  // if our last write ended with an incomplete multibyte character\n  while (this.charLength) {\n    // determine how many remaining bytes this buffer has to offer for this char\n    var available = (buffer.length >= this.charLength - this.charReceived) ?\n        this.charLength - this.charReceived :\n        buffer.length;\n\n    // add the new bytes to the char buffer\n    buffer.copy(this.charBuffer, this.charReceived, 0, available);\n    this.charReceived += available;\n\n    if (this.charReceived < this.charLength) {\n      // still not enough chars in this buffer? wait for more ...\n      return '';\n    }\n\n    // remove bytes belonging to the current character from the buffer\n    buffer = buffer.slice(available, buffer.length);\n\n    // get the character that was split\n    charStr = this.charBuffer.slice(0, this.charLength).toString(this.encoding);\n\n    // CESU-8: lead surrogate (D800-DBFF) is also the incomplete character\n    var charCode = charStr.charCodeAt(charStr.length - 1);\n    if (charCode >= 0xD800 && charCode <= 0xDBFF) {\n      this.charLength += this.surrogateSize;\n      charStr = '';\n      continue;\n    }\n    this.charReceived = this.charLength = 0;\n\n    // if there are no more bytes in this buffer, just emit our char\n    if (buffer.length === 0) {\n      return charStr;\n    }\n    break;\n  }\n\n  // determine and set charLength / charReceived\n  this.detectIncompleteChar(buffer);\n\n  var end = buffer.length;\n  if (this.charLength) {\n    // buffer the incomplete character bytes we got\n    buffer.copy(this.charBuffer, 0, buffer.length - this.charReceived, end);\n    end -= this.charReceived;\n  }\n\n  charStr += buffer.toString(this.encoding, 0, end);\n\n  var end = charStr.length - 1;\n  var charCode = charStr.charCodeAt(end);\n  // CESU-8: lead surrogate (D800-DBFF) is also the incomplete character\n  if (charCode >= 0xD800 && charCode <= 0xDBFF) {\n    var size = this.surrogateSize;\n    this.charLength += size;\n    this.charReceived += size;\n    this.charBuffer.copy(this.charBuffer, size, 0, size);\n    buffer.copy(this.charBuffer, 0, 0, size);\n    return charStr.substring(0, end);\n  }\n\n  // or just emit the charStr\n  return charStr;\n};\n\n// detectIncompleteChar determines if there is an incomplete UTF-8 character at\n// the end of the given buffer. If so, it sets this.charLength to the byte\n// length that character, and sets this.charReceived to the number of bytes\n// that are available for this character.\nStringDecoder.prototype.detectIncompleteChar = function(buffer) {\n  // determine how many bytes we have to check at the end of this buffer\n  var i = (buffer.length >= 3) ? 3 : buffer.length;\n\n  // Figure out if one of the last i bytes of our buffer announces an\n  // incomplete char.\n  for (; i > 0; i--) {\n    var c = buffer[buffer.length - i];\n\n    // See http://en.wikipedia.org/wiki/UTF-8#Description\n\n    // 110XXXXX\n    if (i == 1 && c >> 5 == 0x06) {\n      this.charLength = 2;\n      break;\n    }\n\n    // 1110XXXX\n    if (i <= 2 && c >> 4 == 0x0E) {\n      this.charLength = 3;\n      break;\n    }\n\n    // 11110XXX\n    if (i <= 3 && c >> 3 == 0x1E) {\n      this.charLength = 4;\n      break;\n    }\n  }\n  this.charReceived = i;\n};\n\nStringDecoder.prototype.end = function(buffer) {\n  var res = '';\n  if (buffer && buffer.length)\n    res = this.write(buffer);\n\n  if (this.charReceived) {\n    var cr = this.charReceived;\n    var buf = this.charBuffer;\n    var enc = this.encoding;\n    res += buf.slice(0, cr).toString(enc);\n  }\n\n  return res;\n};\n\nfunction passThroughWrite(buffer) {\n  return buffer.toString(this.encoding);\n}\n\nfunction utf16DetectIncompleteChar(buffer) {\n  this.charReceived = buffer.length % 2;\n  this.charLength = this.charReceived ? 2 : 0;\n}\n\nfunction base64DetectIncompleteChar(buffer) {\n  this.charReceived = buffer.length % 3;\n  this.charLength = this.charReceived ? 3 : 0;\n}\n\n},{\"buffer\":3}],37:[function(require,module,exports){\n// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n'use strict';\n\nvar punycode = require('punycode');\nvar util = require('./util');\n\nexports.parse = urlParse;\nexports.resolve = urlResolve;\nexports.resolveObject = urlResolveObject;\nexports.format = urlFormat;\n\nexports.Url = Url;\n\nfunction Url() {\n  this.protocol = null;\n  this.slashes = null;\n  this.auth = null;\n  this.host = null;\n  this.port = null;\n  this.hostname = null;\n  this.hash = null;\n  this.search = null;\n  this.query = null;\n  this.pathname = null;\n  this.path = null;\n  this.href = null;\n}\n\n// Reference: RFC 3986, RFC 1808, RFC 2396\n\n// define these here so at least they only have to be\n// compiled once on the first module load.\nvar protocolPattern = /^([a-z0-9.+-]+:)/i,\n    portPattern = /:[0-9]*$/,\n\n    // Special case for a simple path URL\n    simplePathPattern = /^(\\/\\/?(?!\\/)[^\\?\\s]*)(\\?[^\\s]*)?$/,\n\n    // RFC 2396: characters reserved for delimiting URLs.\n    // We actually just auto-escape these.\n    delims = ['<', '>', '\"', '`', ' ', '\\r', '\\n', '\\t'],\n\n    // RFC 2396: characters not allowed for various reasons.\n    unwise = ['{', '}', '|', '\\\\', '^', '`'].concat(delims),\n\n    // Allowed by RFCs, but cause of XSS attacks.  Always escape these.\n    autoEscape = ['\\''].concat(unwise),\n    // Characters that are never ever allowed in a hostname.\n    // Note that any invalid chars are also handled, but these\n    // are the ones that are *expected* to be seen, so we fast-path\n    // them.\n    nonHostChars = ['%', '/', '?', ';', '#'].concat(autoEscape),\n    hostEndingChars = ['/', '?', '#'],\n    hostnameMaxLen = 255,\n    hostnamePartPattern = /^[+a-z0-9A-Z_-]{0,63}$/,\n    hostnamePartStart = /^([+a-z0-9A-Z_-]{0,63})(.*)$/,\n    // protocols that can allow \"unsafe\" and \"unwise\" chars.\n    unsafeProtocol = {\n      'javascript': true,\n      'javascript:': true\n    },\n    // protocols that never have a hostname.\n    hostlessProtocol = {\n      'javascript': true,\n      'javascript:': true\n    },\n    // protocols that always contain a // bit.\n    slashedProtocol = {\n      'http': true,\n      'https': true,\n      'ftp': true,\n      'gopher': true,\n      'file': true,\n      'http:': true,\n      'https:': true,\n      'ftp:': true,\n      'gopher:': true,\n      'file:': true\n    },\n    querystring = require('querystring');\n\nfunction urlParse(url, parseQueryString, slashesDenoteHost) {\n  if (url && util.isObject(url) && url instanceof Url) return url;\n\n  var u = new Url;\n  u.parse(url, parseQueryString, slashesDenoteHost);\n  return u;\n}\n\nUrl.prototype.parse = function(url, parseQueryString, slashesDenoteHost) {\n  if (!util.isString(url)) {\n    throw new TypeError(\"Parameter 'url' must be a string, not \" + typeof url);\n  }\n\n  // Copy chrome, IE, opera backslash-handling behavior.\n  // Back slashes before the query string get converted to forward slashes\n  // See: https://code.google.com/p/chromium/issues/detail?id=25916\n  var queryIndex = url.indexOf('?'),\n      splitter =\n          (queryIndex !== -1 && queryIndex < url.indexOf('#')) ? '?' : '#',\n      uSplit = url.split(splitter),\n      slashRegex = /\\\\/g;\n  uSplit[0] = uSplit[0].replace(slashRegex, '/');\n  url = uSplit.join(splitter);\n\n  var rest = url;\n\n  // trim before proceeding.\n  // This is to support parse stuff like \"  http://foo.com  \\n\"\n  rest = rest.trim();\n\n  if (!slashesDenoteHost && url.split('#').length === 1) {\n    // Try fast path regexp\n    var simplePath = simplePathPattern.exec(rest);\n    if (simplePath) {\n      this.path = rest;\n      this.href = rest;\n      this.pathname = simplePath[1];\n      if (simplePath[2]) {\n        this.search = simplePath[2];\n        if (parseQueryString) {\n          this.query = querystring.parse(this.search.substr(1));\n        } else {\n          this.query = this.search.substr(1);\n        }\n      } else if (parseQueryString) {\n        this.search = '';\n        this.query = {};\n      }\n      return this;\n    }\n  }\n\n  var proto = protocolPattern.exec(rest);\n  if (proto) {\n    proto = proto[0];\n    var lowerProto = proto.toLowerCase();\n    this.protocol = lowerProto;\n    rest = rest.substr(proto.length);\n  }\n\n  // figure out if it's got a host\n  // user@server is *always* interpreted as a hostname, and url\n  // resolution will treat //foo/bar as host=foo,path=bar because that's\n  // how the browser resolves relative URLs.\n  if (slashesDenoteHost || proto || rest.match(/^\\/\\/[^@\\/]+@[^@\\/]+/)) {\n    var slashes = rest.substr(0, 2) === '//';\n    if (slashes && !(proto && hostlessProtocol[proto])) {\n      rest = rest.substr(2);\n      this.slashes = true;\n    }\n  }\n\n  if (!hostlessProtocol[proto] &&\n      (slashes || (proto && !slashedProtocol[proto]))) {\n\n    // there's a hostname.\n    // the first instance of /, ?, ;, or # ends the host.\n    //\n    // If there is an @ in the hostname, then non-host chars *are* allowed\n    // to the left of the last @ sign, unless some host-ending character\n    // comes *before* the @-sign.\n    // URLs are obnoxious.\n    //\n    // ex:\n    // http://a@b@c/ => user:a@b host:c\n    // http://a@b?@c => user:a host:c path:/?@c\n\n    // v0.12 TODO(isaacs): This is not quite how Chrome does things.\n    // Review our test case against browsers more comprehensively.\n\n    // find the first instance of any hostEndingChars\n    var hostEnd = -1;\n    for (var i = 0; i < hostEndingChars.length; i++) {\n      var hec = rest.indexOf(hostEndingChars[i]);\n      if (hec !== -1 && (hostEnd === -1 || hec < hostEnd))\n        hostEnd = hec;\n    }\n\n    // at this point, either we have an explicit point where the\n    // auth portion cannot go past, or the last @ char is the decider.\n    var auth, atSign;\n    if (hostEnd === -1) {\n      // atSign can be anywhere.\n      atSign = rest.lastIndexOf('@');\n    } else {\n      // atSign must be in auth portion.\n      // http://a@b/c@d => host:b auth:a path:/c@d\n      atSign = rest.lastIndexOf('@', hostEnd);\n    }\n\n    // Now we have a portion which is definitely the auth.\n    // Pull that off.\n    if (atSign !== -1) {\n      auth = rest.slice(0, atSign);\n      rest = rest.slice(atSign + 1);\n      this.auth = decodeURIComponent(auth);\n    }\n\n    // the host is the remaining to the left of the first non-host char\n    hostEnd = -1;\n    for (var i = 0; i < nonHostChars.length; i++) {\n      var hec = rest.indexOf(nonHostChars[i]);\n      if (hec !== -1 && (hostEnd === -1 || hec < hostEnd))\n        hostEnd = hec;\n    }\n    // if we still have not hit it, then the entire thing is a host.\n    if (hostEnd === -1)\n      hostEnd = rest.length;\n\n    this.host = rest.slice(0, hostEnd);\n    rest = rest.slice(hostEnd);\n\n    // pull out port.\n    this.parseHost();\n\n    // we've indicated that there is a hostname,\n    // so even if it's empty, it has to be present.\n    this.hostname = this.hostname || '';\n\n    // if hostname begins with [ and ends with ]\n    // assume that it's an IPv6 address.\n    var ipv6Hostname = this.hostname[0] === '[' &&\n        this.hostname[this.hostname.length - 1] === ']';\n\n    // validate a little.\n    if (!ipv6Hostname) {\n      var hostparts = this.hostname.split(/\\./);\n      for (var i = 0, l = hostparts.length; i < l; i++) {\n        var part = hostparts[i];\n        if (!part) continue;\n        if (!part.match(hostnamePartPattern)) {\n          var newpart = '';\n          for (var j = 0, k = part.length; j < k; j++) {\n            if (part.charCodeAt(j) > 127) {\n              // we replace non-ASCII char with a temporary placeholder\n              // we need this to make sure size of hostname is not\n              // broken by replacing non-ASCII by nothing\n              newpart += 'x';\n            } else {\n              newpart += part[j];\n            }\n          }\n          // we test again with ASCII char only\n          if (!newpart.match(hostnamePartPattern)) {\n            var validParts = hostparts.slice(0, i);\n            var notHost = hostparts.slice(i + 1);\n            var bit = part.match(hostnamePartStart);\n            if (bit) {\n              validParts.push(bit[1]);\n              notHost.unshift(bit[2]);\n            }\n            if (notHost.length) {\n              rest = '/' + notHost.join('.') + rest;\n            }\n            this.hostname = validParts.join('.');\n            break;\n          }\n        }\n      }\n    }\n\n    if (this.hostname.length > hostnameMaxLen) {\n      this.hostname = '';\n    } else {\n      // hostnames are always lower case.\n      this.hostname = this.hostname.toLowerCase();\n    }\n\n    if (!ipv6Hostname) {\n      // IDNA Support: Returns a punycoded representation of \"domain\".\n      // It only converts parts of the domain name that\n      // have non-ASCII characters, i.e. it doesn't matter if\n      // you call it with a domain that already is ASCII-only.\n      this.hostname = punycode.toASCII(this.hostname);\n    }\n\n    var p = this.port ? ':' + this.port : '';\n    var h = this.hostname || '';\n    this.host = h + p;\n    this.href += this.host;\n\n    // strip [ and ] from the hostname\n    // the host field still retains them, though\n    if (ipv6Hostname) {\n      this.hostname = this.hostname.substr(1, this.hostname.length - 2);\n      if (rest[0] !== '/') {\n        rest = '/' + rest;\n      }\n    }\n  }\n\n  // now rest is set to the post-host stuff.\n  // chop off any delim chars.\n  if (!unsafeProtocol[lowerProto]) {\n\n    // First, make 100% sure that any \"autoEscape\" chars get\n    // escaped, even if encodeURIComponent doesn't think they\n    // need to be.\n    for (var i = 0, l = autoEscape.length; i < l; i++) {\n      var ae = autoEscape[i];\n      if (rest.indexOf(ae) === -1)\n        continue;\n      var esc = encodeURIComponent(ae);\n      if (esc === ae) {\n        esc = escape(ae);\n      }\n      rest = rest.split(ae).join(esc);\n    }\n  }\n\n\n  // chop off from the tail first.\n  var hash = rest.indexOf('#');\n  if (hash !== -1) {\n    // got a fragment string.\n    this.hash = rest.substr(hash);\n    rest = rest.slice(0, hash);\n  }\n  var qm = rest.indexOf('?');\n  if (qm !== -1) {\n    this.search = rest.substr(qm);\n    this.query = rest.substr(qm + 1);\n    if (parseQueryString) {\n      this.query = querystring.parse(this.query);\n    }\n    rest = rest.slice(0, qm);\n  } else if (parseQueryString) {\n    // no query string, but parseQueryString still requested\n    this.search = '';\n    this.query = {};\n  }\n  if (rest) this.pathname = rest;\n  if (slashedProtocol[lowerProto] &&\n      this.hostname && !this.pathname) {\n    this.pathname = '/';\n  }\n\n  //to support http.request\n  if (this.pathname || this.search) {\n    var p = this.pathname || '';\n    var s = this.search || '';\n    this.path = p + s;\n  }\n\n  // finally, reconstruct the href based on what has been validated.\n  this.href = this.format();\n  return this;\n};\n\n// format a parsed object into a url string\nfunction urlFormat(obj) {\n  // ensure it's an object, and not a string url.\n  // If it's an obj, this is a no-op.\n  // this way, you can call url_format() on strings\n  // to clean up potentially wonky urls.\n  if (util.isString(obj)) obj = urlParse(obj);\n  if (!(obj instanceof Url)) return Url.prototype.format.call(obj);\n  return obj.format();\n}\n\nUrl.prototype.format = function() {\n  var auth = this.auth || '';\n  if (auth) {\n    auth = encodeURIComponent(auth);\n    auth = auth.replace(/%3A/i, ':');\n    auth += '@';\n  }\n\n  var protocol = this.protocol || '',\n      pathname = this.pathname || '',\n      hash = this.hash || '',\n      host = false,\n      query = '';\n\n  if (this.host) {\n    host = auth + this.host;\n  } else if (this.hostname) {\n    host = auth + (this.hostname.indexOf(':') === -1 ?\n        this.hostname :\n        '[' + this.hostname + ']');\n    if (this.port) {\n      host += ':' + this.port;\n    }\n  }\n\n  if (this.query &&\n      util.isObject(this.query) &&\n      Object.keys(this.query).length) {\n    query = querystring.stringify(this.query);\n  }\n\n  var search = this.search || (query && ('?' + query)) || '';\n\n  if (protocol && protocol.substr(-1) !== ':') protocol += ':';\n\n  // only the slashedProtocols get the //.  Not mailto:, xmpp:, etc.\n  // unless they had them to begin with.\n  if (this.slashes ||\n      (!protocol || slashedProtocol[protocol]) && host !== false) {\n    host = '//' + (host || '');\n    if (pathname && pathname.charAt(0) !== '/') pathname = '/' + pathname;\n  } else if (!host) {\n    host = '';\n  }\n\n  if (hash && hash.charAt(0) !== '#') hash = '#' + hash;\n  if (search && search.charAt(0) !== '?') search = '?' + search;\n\n  pathname = pathname.replace(/[?#]/g, function(match) {\n    return encodeURIComponent(match);\n  });\n  search = search.replace('#', '%23');\n\n  return protocol + host + pathname + search + hash;\n};\n\nfunction urlResolve(source, relative) {\n  return urlParse(source, false, true).resolve(relative);\n}\n\nUrl.prototype.resolve = function(relative) {\n  return this.resolveObject(urlParse(relative, false, true)).format();\n};\n\nfunction urlResolveObject(source, relative) {\n  if (!source) return relative;\n  return urlParse(source, false, true).resolveObject(relative);\n}\n\nUrl.prototype.resolveObject = function(relative) {\n  if (util.isString(relative)) {\n    var rel = new Url();\n    rel.parse(relative, false, true);\n    relative = rel;\n  }\n\n  var result = new Url();\n  var tkeys = Object.keys(this);\n  for (var tk = 0; tk < tkeys.length; tk++) {\n    var tkey = tkeys[tk];\n    result[tkey] = this[tkey];\n  }\n\n  // hash is always overridden, no matter what.\n  // even href=\"\" will remove it.\n  result.hash = relative.hash;\n\n  // if the relative url is empty, then there's nothing left to do here.\n  if (relative.href === '') {\n    result.href = result.format();\n    return result;\n  }\n\n  // hrefs like //foo/bar always cut to the protocol.\n  if (relative.slashes && !relative.protocol) {\n    // take everything except the protocol from relative\n    var rkeys = Object.keys(relative);\n    for (var rk = 0; rk < rkeys.length; rk++) {\n      var rkey = rkeys[rk];\n      if (rkey !== 'protocol')\n        result[rkey] = relative[rkey];\n    }\n\n    //urlParse appends trailing / to urls like http://www.example.com\n    if (slashedProtocol[result.protocol] &&\n        result.hostname && !result.pathname) {\n      result.path = result.pathname = '/';\n    }\n\n    result.href = result.format();\n    return result;\n  }\n\n  if (relative.protocol && relative.protocol !== result.protocol) {\n    // if it's a known url protocol, then changing\n    // the protocol does weird things\n    // first, if it's not file:, then we MUST have a host,\n    // and if there was a path\n    // to begin with, then we MUST have a path.\n    // if it is file:, then the host is dropped,\n    // because that's known to be hostless.\n    // anything else is assumed to be absolute.\n    if (!slashedProtocol[relative.protocol]) {\n      var keys = Object.keys(relative);\n      for (var v = 0; v < keys.length; v++) {\n        var k = keys[v];\n        result[k] = relative[k];\n      }\n      result.href = result.format();\n      return result;\n    }\n\n    result.protocol = relative.protocol;\n    if (!relative.host && !hostlessProtocol[relative.protocol]) {\n      var relPath = (relative.pathname || '').split('/');\n      while (relPath.length && !(relative.host = relPath.shift()));\n      if (!relative.host) relative.host = '';\n      if (!relative.hostname) relative.hostname = '';\n      if (relPath[0] !== '') relPath.unshift('');\n      if (relPath.length < 2) relPath.unshift('');\n      result.pathname = relPath.join('/');\n    } else {\n      result.pathname = relative.pathname;\n    }\n    result.search = relative.search;\n    result.query = relative.query;\n    result.host = relative.host || '';\n    result.auth = relative.auth;\n    result.hostname = relative.hostname || relative.host;\n    result.port = relative.port;\n    // to support http.request\n    if (result.pathname || result.search) {\n      var p = result.pathname || '';\n      var s = result.search || '';\n      result.path = p + s;\n    }\n    result.slashes = result.slashes || relative.slashes;\n    result.href = result.format();\n    return result;\n  }\n\n  var isSourceAbs = (result.pathname && result.pathname.charAt(0) === '/'),\n      isRelAbs = (\n          relative.host ||\n          relative.pathname && relative.pathname.charAt(0) === '/'\n      ),\n      mustEndAbs = (isRelAbs || isSourceAbs ||\n                    (result.host && relative.pathname)),\n      removeAllDots = mustEndAbs,\n      srcPath = result.pathname && result.pathname.split('/') || [],\n      relPath = relative.pathname && relative.pathname.split('/') || [],\n      psychotic = result.protocol && !slashedProtocol[result.protocol];\n\n  // if the url is a non-slashed url, then relative\n  // links like ../.. should be able\n  // to crawl up to the hostname, as well.  This is strange.\n  // result.protocol has already been set by now.\n  // Later on, put the first path part into the host field.\n  if (psychotic) {\n    result.hostname = '';\n    result.port = null;\n    if (result.host) {\n      if (srcPath[0] === '') srcPath[0] = result.host;\n      else srcPath.unshift(result.host);\n    }\n    result.host = '';\n    if (relative.protocol) {\n      relative.hostname = null;\n      relative.port = null;\n      if (relative.host) {\n        if (relPath[0] === '') relPath[0] = relative.host;\n        else relPath.unshift(relative.host);\n      }\n      relative.host = null;\n    }\n    mustEndAbs = mustEndAbs && (relPath[0] === '' || srcPath[0] === '');\n  }\n\n  if (isRelAbs) {\n    // it's absolute.\n    result.host = (relative.host || relative.host === '') ?\n                  relative.host : result.host;\n    result.hostname = (relative.hostname || relative.hostname === '') ?\n                      relative.hostname : result.hostname;\n    result.search = relative.search;\n    result.query = relative.query;\n    srcPath = relPath;\n    // fall through to the dot-handling below.\n  } else if (relPath.length) {\n    // it's relative\n    // throw away the existing file, and take the new path instead.\n    if (!srcPath) srcPath = [];\n    srcPath.pop();\n    srcPath = srcPath.concat(relPath);\n    result.search = relative.search;\n    result.query = relative.query;\n  } else if (!util.isNullOrUndefined(relative.search)) {\n    // just pull out the search.\n    // like href='?foo'.\n    // Put this after the other two cases because it simplifies the booleans\n    if (psychotic) {\n      result.hostname = result.host = srcPath.shift();\n      //occationaly the auth can get stuck only in host\n      //this especially happens in cases like\n      //url.resolveObject('mailto:local1@domain1', 'local2@domain2')\n      var authInHost = result.host && result.host.indexOf('@') > 0 ?\n                       result.host.split('@') : false;\n      if (authInHost) {\n        result.auth = authInHost.shift();\n        result.host = result.hostname = authInHost.shift();\n      }\n    }\n    result.search = relative.search;\n    result.query = relative.query;\n    //to support http.request\n    if (!util.isNull(result.pathname) || !util.isNull(result.search)) {\n      result.path = (result.pathname ? result.pathname : '') +\n                    (result.search ? result.search : '');\n    }\n    result.href = result.format();\n    return result;\n  }\n\n  if (!srcPath.length) {\n    // no path at all.  easy.\n    // we've already handled the other stuff above.\n    result.pathname = null;\n    //to support http.request\n    if (result.search) {\n      result.path = '/' + result.search;\n    } else {\n      result.path = null;\n    }\n    result.href = result.format();\n    return result;\n  }\n\n  // if a url ENDs in . or .., then it must get a trailing slash.\n  // however, if it ends in anything else non-slashy,\n  // then it must NOT get a trailing slash.\n  var last = srcPath.slice(-1)[0];\n  var hasTrailingSlash = (\n      (result.host || relative.host || srcPath.length > 1) &&\n      (last === '.' || last === '..') || last === '');\n\n  // strip single dots, resolve double dots to parent dir\n  // if the path tries to go above the root, `up` ends up > 0\n  var up = 0;\n  for (var i = srcPath.length; i >= 0; i--) {\n    last = srcPath[i];\n    if (last === '.') {\n      srcPath.splice(i, 1);\n    } else if (last === '..') {\n      srcPath.splice(i, 1);\n      up++;\n    } else if (up) {\n      srcPath.splice(i, 1);\n      up--;\n    }\n  }\n\n  // if the path is allowed to go above the root, restore leading ..s\n  if (!mustEndAbs && !removeAllDots) {\n    for (; up--; up) {\n      srcPath.unshift('..');\n    }\n  }\n\n  if (mustEndAbs && srcPath[0] !== '' &&\n      (!srcPath[0] || srcPath[0].charAt(0) !== '/')) {\n    srcPath.unshift('');\n  }\n\n  if (hasTrailingSlash && (srcPath.join('/').substr(-1) !== '/')) {\n    srcPath.push('');\n  }\n\n  var isAbsolute = srcPath[0] === '' ||\n      (srcPath[0] && srcPath[0].charAt(0) === '/');\n\n  // put the host back\n  if (psychotic) {\n    result.hostname = result.host = isAbsolute ? '' :\n                                    srcPath.length ? srcPath.shift() : '';\n    //occationaly the auth can get stuck only in host\n    //this especially happens in cases like\n    //url.resolveObject('mailto:local1@domain1', 'local2@domain2')\n    var authInHost = result.host && result.host.indexOf('@') > 0 ?\n                     result.host.split('@') : false;\n    if (authInHost) {\n      result.auth = authInHost.shift();\n      result.host = result.hostname = authInHost.shift();\n    }\n  }\n\n  mustEndAbs = mustEndAbs || (result.host && srcPath.length);\n\n  if (mustEndAbs && !isAbsolute) {\n    srcPath.unshift('');\n  }\n\n  if (!srcPath.length) {\n    result.pathname = null;\n    result.path = null;\n  } else {\n    result.pathname = srcPath.join('/');\n  }\n\n  //to support request.http\n  if (!util.isNull(result.pathname) || !util.isNull(result.search)) {\n    result.path = (result.pathname ? result.pathname : '') +\n                  (result.search ? result.search : '');\n  }\n  result.auth = relative.auth || result.auth;\n  result.slashes = result.slashes || relative.slashes;\n  result.href = result.format();\n  return result;\n};\n\nUrl.prototype.parseHost = function() {\n  var host = this.host;\n  var port = portPattern.exec(host);\n  if (port) {\n    port = port[0];\n    if (port !== ':') {\n      this.port = port.substr(1);\n    }\n    host = host.substr(0, host.length - port.length);\n  }\n  if (host) this.hostname = host;\n};\n\n},{\"./util\":38,\"punycode\":13,\"querystring\":16}],38:[function(require,module,exports){\n'use strict';\n\nmodule.exports = {\n  isString: function(arg) {\n    return typeof(arg) === 'string';\n  },\n  isObject: function(arg) {\n    return typeof(arg) === 'object' && arg !== null;\n  },\n  isNull: function(arg) {\n    return arg === null;\n  },\n  isNullOrUndefined: function(arg) {\n    return arg == null;\n  }\n};\n\n},{}],39:[function(require,module,exports){\nmodule.exports = extend\n\nvar hasOwnProperty = Object.prototype.hasOwnProperty;\n\nfunction extend() {\n    var target = {}\n\n    for (var i = 0; i < arguments.length; i++) {\n        var source = arguments[i]\n\n        for (var key in source) {\n            if (hasOwnProperty.call(source, key)) {\n                target[key] = source[key]\n            }\n        }\n    }\n\n    return target\n}\n\n},{}],40:[function(require,module,exports){\n/*!\n * escape-html\n * Copyright(c) 2012-2013 TJ Holowaychuk\n * Copyright(c) 2015 Andreas Lubbe\n * Copyright(c) 2015 Tiancheng \"Timothy\" Gu\n * MIT Licensed\n */\n\n'use strict';\n\n/**\n * Module variables.\n * @private\n */\n\nvar matchHtmlRegExp = /[\"'&<>]/;\n\n/**\n * Module exports.\n * @public\n */\n\nmodule.exports = escapeHtml;\n\n/**\n * Escape special characters in the given string of html.\n *\n * @param  {string} string The string to escape for inserting into HTML\n * @return {string}\n * @public\n */\n\nfunction escapeHtml(string) {\n  var str = '' + string;\n  var match = matchHtmlRegExp.exec(str);\n\n  if (!match) {\n    return str;\n  }\n\n  var escape;\n  var html = '';\n  var index = 0;\n  var lastIndex = 0;\n\n  for (index = match.index; index < str.length; index++) {\n    switch (str.charCodeAt(index)) {\n      case 34: // \"\n        escape = '&quot;';\n        break;\n      case 38: // &\n        escape = '&amp;';\n        break;\n      case 39: // '\n        escape = '&#39;';\n        break;\n      case 60: // <\n        escape = '&lt;';\n        break;\n      case 62: // >\n        escape = '&gt;';\n        break;\n      default:\n        continue;\n    }\n\n    if (lastIndex !== index) {\n      html += str.substring(lastIndex, index);\n    }\n\n    lastIndex = index + 1;\n    html += escape;\n  }\n\n  return lastIndex !== index\n    ? html + str.substring(lastIndex, index)\n    : html;\n}\n\n},{}],41:[function(require,module,exports){\n(function (Buffer){\n;(function (sax) { // wrapper for non-node envs\n  sax.parser = function (strict, opt) { return new SAXParser(strict, opt) }\n  sax.SAXParser = SAXParser\n  sax.SAXStream = SAXStream\n  sax.createStream = createStream\n\n  // When we pass the MAX_BUFFER_LENGTH position, start checking for buffer overruns.\n  // When we check, schedule the next check for MAX_BUFFER_LENGTH - (max(buffer lengths)),\n  // since that's the earliest that a buffer overrun could occur.  This way, checks are\n  // as rare as required, but as often as necessary to ensure never crossing this bound.\n  // Furthermore, buffers are only tested at most once per write(), so passing a very\n  // large string into write() might have undesirable effects, but this is manageable by\n  // the caller, so it is assumed to be safe.  Thus, a call to write() may, in the extreme\n  // edge case, result in creating at most one complete copy of the string passed in.\n  // Set to Infinity to have unlimited buffers.\n  sax.MAX_BUFFER_LENGTH = 64 * 1024\n\n  var buffers = [\n    'comment', 'sgmlDecl', 'textNode', 'tagName', 'doctype',\n    'procInstName', 'procInstBody', 'entity', 'attribName',\n    'attribValue', 'cdata', 'script'\n  ]\n\n  sax.EVENTS = [\n    'text',\n    'processinginstruction',\n    'sgmldeclaration',\n    'doctype',\n    'comment',\n    'attribute',\n    'opentag',\n    'closetag',\n    'opencdata',\n    'cdata',\n    'closecdata',\n    'error',\n    'end',\n    'ready',\n    'script',\n    'opennamespace',\n    'closenamespace'\n  ]\n\n  function SAXParser (strict, opt) {\n    if (!(this instanceof SAXParser)) {\n      return new SAXParser(strict, opt)\n    }\n\n    var parser = this\n    clearBuffers(parser)\n    parser.q = parser.c = ''\n    parser.bufferCheckPosition = sax.MAX_BUFFER_LENGTH\n    parser.opt = opt || {}\n    parser.opt.lowercase = parser.opt.lowercase || parser.opt.lowercasetags\n    parser.looseCase = parser.opt.lowercase ? 'toLowerCase' : 'toUpperCase'\n    parser.tags = []\n    parser.closed = parser.closedRoot = parser.sawRoot = false\n    parser.tag = parser.error = null\n    parser.strict = !!strict\n    parser.noscript = !!(strict || parser.opt.noscript)\n    parser.state = S.BEGIN\n    parser.strictEntities = parser.opt.strictEntities\n    parser.ENTITIES = parser.strictEntities ? Object.create(sax.XML_ENTITIES) : Object.create(sax.ENTITIES)\n    parser.attribList = []\n\n    // namespaces form a prototype chain.\n    // it always points at the current tag,\n    // which protos to its parent tag.\n    if (parser.opt.xmlns) {\n      parser.ns = Object.create(rootNS)\n    }\n\n    // mostly just for error reporting\n    parser.trackPosition = parser.opt.position !== false\n    if (parser.trackPosition) {\n      parser.position = parser.line = parser.column = 0\n    }\n    emit(parser, 'onready')\n  }\n\n  if (!Object.create) {\n    Object.create = function (o) {\n      function F () {}\n      F.prototype = o\n      var newf = new F()\n      return newf\n    }\n  }\n\n  if (!Object.keys) {\n    Object.keys = function (o) {\n      var a = []\n      for (var i in o) if (o.hasOwnProperty(i)) a.push(i)\n      return a\n    }\n  }\n\n  function checkBufferLength (parser) {\n    var maxAllowed = Math.max(sax.MAX_BUFFER_LENGTH, 10)\n    var maxActual = 0\n    for (var i = 0, l = buffers.length; i < l; i++) {\n      var len = parser[buffers[i]].length\n      if (len > maxAllowed) {\n        // Text/cdata nodes can get big, and since they're buffered,\n        // we can get here under normal conditions.\n        // Avoid issues by emitting the text node now,\n        // so at least it won't get any bigger.\n        switch (buffers[i]) {\n          case 'textNode':\n            closeText(parser)\n            break\n\n          case 'cdata':\n            emitNode(parser, 'oncdata', parser.cdata)\n            parser.cdata = ''\n            break\n\n          case 'script':\n            emitNode(parser, 'onscript', parser.script)\n            parser.script = ''\n            break\n\n          default:\n            error(parser, 'Max buffer length exceeded: ' + buffers[i])\n        }\n      }\n      maxActual = Math.max(maxActual, len)\n    }\n    // schedule the next check for the earliest possible buffer overrun.\n    var m = sax.MAX_BUFFER_LENGTH - maxActual\n    parser.bufferCheckPosition = m + parser.position\n  }\n\n  function clearBuffers (parser) {\n    for (var i = 0, l = buffers.length; i < l; i++) {\n      parser[buffers[i]] = ''\n    }\n  }\n\n  function flushBuffers (parser) {\n    closeText(parser)\n    if (parser.cdata !== '') {\n      emitNode(parser, 'oncdata', parser.cdata)\n      parser.cdata = ''\n    }\n    if (parser.script !== '') {\n      emitNode(parser, 'onscript', parser.script)\n      parser.script = ''\n    }\n  }\n\n  SAXParser.prototype = {\n    end: function () { end(this) },\n    write: write,\n    resume: function () { this.error = null; return this },\n    close: function () { return this.write(null) },\n    flush: function () { flushBuffers(this) }\n  }\n\n  var Stream\n  try {\n    Stream = require('stream').Stream\n  } catch (ex) {\n    Stream = function () {}\n  }\n\n  var streamWraps = sax.EVENTS.filter(function (ev) {\n    return ev !== 'error' && ev !== 'end'\n  })\n\n  function createStream (strict, opt) {\n    return new SAXStream(strict, opt)\n  }\n\n  function SAXStream (strict, opt) {\n    if (!(this instanceof SAXStream)) {\n      return new SAXStream(strict, opt)\n    }\n\n    Stream.apply(this)\n\n    this._parser = new SAXParser(strict, opt)\n    this.writable = true\n    this.readable = true\n\n    var me = this\n\n    this._parser.onend = function () {\n      me.emit('end')\n    }\n\n    this._parser.onerror = function (er) {\n      me.emit('error', er)\n\n      // if didn't throw, then means error was handled.\n      // go ahead and clear error, so we can write again.\n      me._parser.error = null\n    }\n\n    this._decoder = null\n\n    streamWraps.forEach(function (ev) {\n      Object.defineProperty(me, 'on' + ev, {\n        get: function () {\n          return me._parser['on' + ev]\n        },\n        set: function (h) {\n          if (!h) {\n            me.removeAllListeners(ev)\n            me._parser['on' + ev] = h\n            return h\n          }\n          me.on(ev, h)\n        },\n        enumerable: true,\n        configurable: false\n      })\n    })\n  }\n\n  SAXStream.prototype = Object.create(Stream.prototype, {\n    constructor: {\n      value: SAXStream\n    }\n  })\n\n  SAXStream.prototype.write = function (data) {\n    if (typeof Buffer === 'function' &&\n      typeof Buffer.isBuffer === 'function' &&\n      Buffer.isBuffer(data)) {\n      if (!this._decoder) {\n        var SD = require('string_decoder').StringDecoder\n        this._decoder = new SD('utf8')\n      }\n      data = this._decoder.write(data)\n    }\n\n    this._parser.write(data.toString())\n    this.emit('data', data)\n    return true\n  }\n\n  SAXStream.prototype.end = function (chunk) {\n    if (chunk && chunk.length) {\n      this.write(chunk)\n    }\n    this._parser.end()\n    return true\n  }\n\n  SAXStream.prototype.on = function (ev, handler) {\n    var me = this\n    if (!me._parser['on' + ev] && streamWraps.indexOf(ev) !== -1) {\n      me._parser['on' + ev] = function () {\n        var args = arguments.length === 1 ? [arguments[0]] : Array.apply(null, arguments)\n        args.splice(0, 0, ev)\n        me.emit.apply(me, args)\n      }\n    }\n\n    return Stream.prototype.on.call(me, ev, handler)\n  }\n\n  // character classes and tokens\n  var whitespace = '\\r\\n\\t '\n\n  // this really needs to be replaced with character classes.\n  // XML allows all manner of ridiculous numbers and digits.\n  var number = '0124356789'\n  var letter = 'abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ'\n\n  // (Letter | \"_\" | \":\")\n  var quote = '\\'\"'\n  var attribEnd = whitespace + '>'\n  var CDATA = '[CDATA['\n  var DOCTYPE = 'DOCTYPE'\n  var XML_NAMESPACE = 'http://www.w3.org/XML/1998/namespace'\n  var XMLNS_NAMESPACE = 'http://www.w3.org/2000/xmlns/'\n  var rootNS = { xml: XML_NAMESPACE, xmlns: XMLNS_NAMESPACE }\n\n  // turn all the string character sets into character class objects.\n  whitespace = charClass(whitespace)\n  number = charClass(number)\n  letter = charClass(letter)\n\n  // http://www.w3.org/TR/REC-xml/#NT-NameStartChar\n  // This implementation works on strings, a single character at a time\n  // as such, it cannot ever support astral-plane characters (10000-EFFFF)\n  // without a significant breaking change to either this  parser, or the\n  // JavaScript language.  Implementation of an emoji-capable xml parser\n  // is left as an exercise for the reader.\n  var nameStart = /[:_A-Za-z\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD]/\n\n  var nameBody = /[:_A-Za-z\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD\\u00B7\\u0300-\\u036F\\u203F-\\u2040\\.\\d-]/\n\n  var entityStart = /[#:_A-Za-z\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD]/\n  var entityBody = /[#:_A-Za-z\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD\\u00B7\\u0300-\\u036F\\u203F-\\u2040\\.\\d-]/\n\n  quote = charClass(quote)\n  attribEnd = charClass(attribEnd)\n\n  function charClass (str) {\n    return str.split('').reduce(function (s, c) {\n      s[c] = true\n      return s\n    }, {})\n  }\n\n  function isRegExp (c) {\n    return Object.prototype.toString.call(c) === '[object RegExp]'\n  }\n\n  function is (charclass, c) {\n    return isRegExp(charclass) ? !!c.match(charclass) : charclass[c]\n  }\n\n  function not (charclass, c) {\n    return !is(charclass, c)\n  }\n\n  var S = 0\n  sax.STATE = {\n    BEGIN: S++, // leading byte order mark or whitespace\n    BEGIN_WHITESPACE: S++, // leading whitespace\n    TEXT: S++, // general stuff\n    TEXT_ENTITY: S++, // &amp and such.\n    OPEN_WAKA: S++, // <\n    SGML_DECL: S++, // <!BLARG\n    SGML_DECL_QUOTED: S++, // <!BLARG foo \"bar\n    DOCTYPE: S++, // <!DOCTYPE\n    DOCTYPE_QUOTED: S++, // <!DOCTYPE \"//blah\n    DOCTYPE_DTD: S++, // <!DOCTYPE \"//blah\" [ ...\n    DOCTYPE_DTD_QUOTED: S++, // <!DOCTYPE \"//blah\" [ \"foo\n    COMMENT_STARTING: S++, // <!-\n    COMMENT: S++, // <!--\n    COMMENT_ENDING: S++, // <!-- blah -\n    COMMENT_ENDED: S++, // <!-- blah --\n    CDATA: S++, // <![CDATA[ something\n    CDATA_ENDING: S++, // ]\n    CDATA_ENDING_2: S++, // ]]\n    PROC_INST: S++, // <?hi\n    PROC_INST_BODY: S++, // <?hi there\n    PROC_INST_ENDING: S++, // <?hi \"there\" ?\n    OPEN_TAG: S++, // <strong\n    OPEN_TAG_SLASH: S++, // <strong /\n    ATTRIB: S++, // <a\n    ATTRIB_NAME: S++, // <a foo\n    ATTRIB_NAME_SAW_WHITE: S++, // <a foo _\n    ATTRIB_VALUE: S++, // <a foo=\n    ATTRIB_VALUE_QUOTED: S++, // <a foo=\"bar\n    ATTRIB_VALUE_CLOSED: S++, // <a foo=\"bar\"\n    ATTRIB_VALUE_UNQUOTED: S++, // <a foo=bar\n    ATTRIB_VALUE_ENTITY_Q: S++, // <foo bar=\"&quot;\"\n    ATTRIB_VALUE_ENTITY_U: S++, // <foo bar=&quot\n    CLOSE_TAG: S++, // </a\n    CLOSE_TAG_SAW_WHITE: S++, // </a   >\n    SCRIPT: S++, // <script> ...\n    SCRIPT_ENDING: S++ // <script> ... <\n  }\n\n  sax.XML_ENTITIES = {\n    'amp': '&',\n    'gt': '>',\n    'lt': '<',\n    'quot': '\"',\n    'apos': \"'\"\n  }\n\n  sax.ENTITIES = {\n    'amp': '&',\n    'gt': '>',\n    'lt': '<',\n    'quot': '\"',\n    'apos': \"'\",\n    'AElig': 198,\n    'Aacute': 193,\n    'Acirc': 194,\n    'Agrave': 192,\n    'Aring': 197,\n    'Atilde': 195,\n    'Auml': 196,\n    'Ccedil': 199,\n    'ETH': 208,\n    'Eacute': 201,\n    'Ecirc': 202,\n    'Egrave': 200,\n    'Euml': 203,\n    'Iacute': 205,\n    'Icirc': 206,\n    'Igrave': 204,\n    'Iuml': 207,\n    'Ntilde': 209,\n    'Oacute': 211,\n    'Ocirc': 212,\n    'Ograve': 210,\n    'Oslash': 216,\n    'Otilde': 213,\n    'Ouml': 214,\n    'THORN': 222,\n    'Uacute': 218,\n    'Ucirc': 219,\n    'Ugrave': 217,\n    'Uuml': 220,\n    'Yacute': 221,\n    'aacute': 225,\n    'acirc': 226,\n    'aelig': 230,\n    'agrave': 224,\n    'aring': 229,\n    'atilde': 227,\n    'auml': 228,\n    'ccedil': 231,\n    'eacute': 233,\n    'ecirc': 234,\n    'egrave': 232,\n    'eth': 240,\n    'euml': 235,\n    'iacute': 237,\n    'icirc': 238,\n    'igrave': 236,\n    'iuml': 239,\n    'ntilde': 241,\n    'oacute': 243,\n    'ocirc': 244,\n    'ograve': 242,\n    'oslash': 248,\n    'otilde': 245,\n    'ouml': 246,\n    'szlig': 223,\n    'thorn': 254,\n    'uacute': 250,\n    'ucirc': 251,\n    'ugrave': 249,\n    'uuml': 252,\n    'yacute': 253,\n    'yuml': 255,\n    'copy': 169,\n    'reg': 174,\n    'nbsp': 160,\n    'iexcl': 161,\n    'cent': 162,\n    'pound': 163,\n    'curren': 164,\n    'yen': 165,\n    'brvbar': 166,\n    'sect': 167,\n    'uml': 168,\n    'ordf': 170,\n    'laquo': 171,\n    'not': 172,\n    'shy': 173,\n    'macr': 175,\n    'deg': 176,\n    'plusmn': 177,\n    'sup1': 185,\n    'sup2': 178,\n    'sup3': 179,\n    'acute': 180,\n    'micro': 181,\n    'para': 182,\n    'middot': 183,\n    'cedil': 184,\n    'ordm': 186,\n    'raquo': 187,\n    'frac14': 188,\n    'frac12': 189,\n    'frac34': 190,\n    'iquest': 191,\n    'times': 215,\n    'divide': 247,\n    'OElig': 338,\n    'oelig': 339,\n    'Scaron': 352,\n    'scaron': 353,\n    'Yuml': 376,\n    'fnof': 402,\n    'circ': 710,\n    'tilde': 732,\n    'Alpha': 913,\n    'Beta': 914,\n    'Gamma': 915,\n    'Delta': 916,\n    'Epsilon': 917,\n    'Zeta': 918,\n    'Eta': 919,\n    'Theta': 920,\n    'Iota': 921,\n    'Kappa': 922,\n    'Lambda': 923,\n    'Mu': 924,\n    'Nu': 925,\n    'Xi': 926,\n    'Omicron': 927,\n    'Pi': 928,\n    'Rho': 929,\n    'Sigma': 931,\n    'Tau': 932,\n    'Upsilon': 933,\n    'Phi': 934,\n    'Chi': 935,\n    'Psi': 936,\n    'Omega': 937,\n    'alpha': 945,\n    'beta': 946,\n    'gamma': 947,\n    'delta': 948,\n    'epsilon': 949,\n    'zeta': 950,\n    'eta': 951,\n    'theta': 952,\n    'iota': 953,\n    'kappa': 954,\n    'lambda': 955,\n    'mu': 956,\n    'nu': 957,\n    'xi': 958,\n    'omicron': 959,\n    'pi': 960,\n    'rho': 961,\n    'sigmaf': 962,\n    'sigma': 963,\n    'tau': 964,\n    'upsilon': 965,\n    'phi': 966,\n    'chi': 967,\n    'psi': 968,\n    'omega': 969,\n    'thetasym': 977,\n    'upsih': 978,\n    'piv': 982,\n    'ensp': 8194,\n    'emsp': 8195,\n    'thinsp': 8201,\n    'zwnj': 8204,\n    'zwj': 8205,\n    'lrm': 8206,\n    'rlm': 8207,\n    'ndash': 8211,\n    'mdash': 8212,\n    'lsquo': 8216,\n    'rsquo': 8217,\n    'sbquo': 8218,\n    'ldquo': 8220,\n    'rdquo': 8221,\n    'bdquo': 8222,\n    'dagger': 8224,\n    'Dagger': 8225,\n    'bull': 8226,\n    'hellip': 8230,\n    'permil': 8240,\n    'prime': 8242,\n    'Prime': 8243,\n    'lsaquo': 8249,\n    'rsaquo': 8250,\n    'oline': 8254,\n    'frasl': 8260,\n    'euro': 8364,\n    'image': 8465,\n    'weierp': 8472,\n    'real': 8476,\n    'trade': 8482,\n    'alefsym': 8501,\n    'larr': 8592,\n    'uarr': 8593,\n    'rarr': 8594,\n    'darr': 8595,\n    'harr': 8596,\n    'crarr': 8629,\n    'lArr': 8656,\n    'uArr': 8657,\n    'rArr': 8658,\n    'dArr': 8659,\n    'hArr': 8660,\n    'forall': 8704,\n    'part': 8706,\n    'exist': 8707,\n    'empty': 8709,\n    'nabla': 8711,\n    'isin': 8712,\n    'notin': 8713,\n    'ni': 8715,\n    'prod': 8719,\n    'sum': 8721,\n    'minus': 8722,\n    'lowast': 8727,\n    'radic': 8730,\n    'prop': 8733,\n    'infin': 8734,\n    'ang': 8736,\n    'and': 8743,\n    'or': 8744,\n    'cap': 8745,\n    'cup': 8746,\n    'int': 8747,\n    'there4': 8756,\n    'sim': 8764,\n    'cong': 8773,\n    'asymp': 8776,\n    'ne': 8800,\n    'equiv': 8801,\n    'le': 8804,\n    'ge': 8805,\n    'sub': 8834,\n    'sup': 8835,\n    'nsub': 8836,\n    'sube': 8838,\n    'supe': 8839,\n    'oplus': 8853,\n    'otimes': 8855,\n    'perp': 8869,\n    'sdot': 8901,\n    'lceil': 8968,\n    'rceil': 8969,\n    'lfloor': 8970,\n    'rfloor': 8971,\n    'lang': 9001,\n    'rang': 9002,\n    'loz': 9674,\n    'spades': 9824,\n    'clubs': 9827,\n    'hearts': 9829,\n    'diams': 9830\n  }\n\n  Object.keys(sax.ENTITIES).forEach(function (key) {\n    var e = sax.ENTITIES[key]\n    var s = typeof e === 'number' ? String.fromCharCode(e) : e\n    sax.ENTITIES[key] = s\n  })\n\n  for (var s in sax.STATE) {\n    sax.STATE[sax.STATE[s]] = s\n  }\n\n  // shorthand\n  S = sax.STATE\n\n  function emit (parser, event, data) {\n    parser[event] && parser[event](data)\n  }\n\n  function emitNode (parser, nodeType, data) {\n    if (parser.textNode) closeText(parser)\n    emit(parser, nodeType, data)\n  }\n\n  function closeText (parser) {\n    parser.textNode = textopts(parser.opt, parser.textNode)\n    if (parser.textNode) emit(parser, 'ontext', parser.textNode)\n    parser.textNode = ''\n  }\n\n  function textopts (opt, text) {\n    if (opt.trim) text = text.trim()\n    if (opt.normalize) text = text.replace(/\\s+/g, ' ')\n    return text\n  }\n\n  function error (parser, er) {\n    closeText(parser)\n    if (parser.trackPosition) {\n      er += '\\nLine: ' + parser.line +\n        '\\nColumn: ' + parser.column +\n        '\\nChar: ' + parser.c\n    }\n    er = new Error(er)\n    parser.error = er\n    emit(parser, 'onerror', er)\n    return parser\n  }\n\n  function end (parser) {\n    if (parser.sawRoot && !parser.closedRoot) strictFail(parser, 'Unclosed root tag')\n    if ((parser.state !== S.BEGIN) &&\n      (parser.state !== S.BEGIN_WHITESPACE) &&\n      (parser.state !== S.TEXT)) {\n      error(parser, 'Unexpected end')\n    }\n    closeText(parser)\n    parser.c = ''\n    parser.closed = true\n    emit(parser, 'onend')\n    SAXParser.call(parser, parser.strict, parser.opt)\n    return parser\n  }\n\n  function strictFail (parser, message) {\n    if (typeof parser !== 'object' || !(parser instanceof SAXParser)) {\n      throw new Error('bad call to strictFail')\n    }\n    if (parser.strict) {\n      error(parser, message)\n    }\n  }\n\n  function newTag (parser) {\n    if (!parser.strict) parser.tagName = parser.tagName[parser.looseCase]()\n    var parent = parser.tags[parser.tags.length - 1] || parser\n    var tag = parser.tag = { name: parser.tagName, attributes: {} }\n\n    // will be overridden if tag contails an xmlns=\"foo\" or xmlns:foo=\"bar\"\n    if (parser.opt.xmlns) {\n      tag.ns = parent.ns\n    }\n    parser.attribList.length = 0\n  }\n\n  function qname (name, attribute) {\n    var i = name.indexOf(':')\n    var qualName = i < 0 ? [ '', name ] : name.split(':')\n    var prefix = qualName[0]\n    var local = qualName[1]\n\n    // <x \"xmlns\"=\"http://foo\">\n    if (attribute && name === 'xmlns') {\n      prefix = 'xmlns'\n      local = ''\n    }\n\n    return { prefix: prefix, local: local }\n  }\n\n  function attrib (parser) {\n    if (!parser.strict) {\n      parser.attribName = parser.attribName[parser.looseCase]()\n    }\n\n    if (parser.attribList.indexOf(parser.attribName) !== -1 ||\n      parser.tag.attributes.hasOwnProperty(parser.attribName)) {\n      parser.attribName = parser.attribValue = ''\n      return\n    }\n\n    if (parser.opt.xmlns) {\n      var qn = qname(parser.attribName, true)\n      var prefix = qn.prefix\n      var local = qn.local\n\n      if (prefix === 'xmlns') {\n        // namespace binding attribute. push the binding into scope\n        if (local === 'xml' && parser.attribValue !== XML_NAMESPACE) {\n          strictFail(parser,\n            'xml: prefix must be bound to ' + XML_NAMESPACE + '\\n' +\n            'Actual: ' + parser.attribValue)\n        } else if (local === 'xmlns' && parser.attribValue !== XMLNS_NAMESPACE) {\n          strictFail(parser,\n            'xmlns: prefix must be bound to ' + XMLNS_NAMESPACE + '\\n' +\n            'Actual: ' + parser.attribValue)\n        } else {\n          var tag = parser.tag\n          var parent = parser.tags[parser.tags.length - 1] || parser\n          if (tag.ns === parent.ns) {\n            tag.ns = Object.create(parent.ns)\n          }\n          tag.ns[local] = parser.attribValue\n        }\n      }\n\n      // defer onattribute events until all attributes have been seen\n      // so any new bindings can take effect. preserve attribute order\n      // so deferred events can be emitted in document order\n      parser.attribList.push([parser.attribName, parser.attribValue])\n    } else {\n      // in non-xmlns mode, we can emit the event right away\n      parser.tag.attributes[parser.attribName] = parser.attribValue\n      emitNode(parser, 'onattribute', {\n        name: parser.attribName,\n        value: parser.attribValue\n      })\n    }\n\n    parser.attribName = parser.attribValue = ''\n  }\n\n  function openTag (parser, selfClosing) {\n    if (parser.opt.xmlns) {\n      // emit namespace binding events\n      var tag = parser.tag\n\n      // add namespace info to tag\n      var qn = qname(parser.tagName)\n      tag.prefix = qn.prefix\n      tag.local = qn.local\n      tag.uri = tag.ns[qn.prefix] || ''\n\n      if (tag.prefix && !tag.uri) {\n        strictFail(parser, 'Unbound namespace prefix: ' +\n          JSON.stringify(parser.tagName))\n        tag.uri = qn.prefix\n      }\n\n      var parent = parser.tags[parser.tags.length - 1] || parser\n      if (tag.ns && parent.ns !== tag.ns) {\n        Object.keys(tag.ns).forEach(function (p) {\n          emitNode(parser, 'onopennamespace', {\n            prefix: p,\n            uri: tag.ns[p]\n          })\n        })\n      }\n\n      // handle deferred onattribute events\n      // Note: do not apply default ns to attributes:\n      //   http://www.w3.org/TR/REC-xml-names/#defaulting\n      for (var i = 0, l = parser.attribList.length; i < l; i++) {\n        var nv = parser.attribList[i]\n        var name = nv[0]\n        var value = nv[1]\n        var qualName = qname(name, true)\n        var prefix = qualName.prefix\n        var local = qualName.local\n        var uri = prefix === '' ? '' : (tag.ns[prefix] || '')\n        var a = {\n          name: name,\n          value: value,\n          prefix: prefix,\n          local: local,\n          uri: uri\n        }\n\n        // if there's any attributes with an undefined namespace,\n        // then fail on them now.\n        if (prefix && prefix !== 'xmlns' && !uri) {\n          strictFail(parser, 'Unbound namespace prefix: ' +\n            JSON.stringify(prefix))\n          a.uri = prefix\n        }\n        parser.tag.attributes[name] = a\n        emitNode(parser, 'onattribute', a)\n      }\n      parser.attribList.length = 0\n    }\n\n    parser.tag.isSelfClosing = !!selfClosing\n\n    // process the tag\n    parser.sawRoot = true\n    parser.tags.push(parser.tag)\n    emitNode(parser, 'onopentag', parser.tag)\n    if (!selfClosing) {\n      // special case for <script> in non-strict mode.\n      if (!parser.noscript && parser.tagName.toLowerCase() === 'script') {\n        parser.state = S.SCRIPT\n      } else {\n        parser.state = S.TEXT\n      }\n      parser.tag = null\n      parser.tagName = ''\n    }\n    parser.attribName = parser.attribValue = ''\n    parser.attribList.length = 0\n  }\n\n  function closeTag (parser) {\n    if (!parser.tagName) {\n      strictFail(parser, 'Weird empty close tag.')\n      parser.textNode += '</>'\n      parser.state = S.TEXT\n      return\n    }\n\n    if (parser.script) {\n      if (parser.tagName !== 'script') {\n        parser.script += '</' + parser.tagName + '>'\n        parser.tagName = ''\n        parser.state = S.SCRIPT\n        return\n      }\n      emitNode(parser, 'onscript', parser.script)\n      parser.script = ''\n    }\n\n    // first make sure that the closing tag actually exists.\n    // <a><b></c></b></a> will close everything, otherwise.\n    var t = parser.tags.length\n    var tagName = parser.tagName\n    if (!parser.strict) {\n      tagName = tagName[parser.looseCase]()\n    }\n    var closeTo = tagName\n    while (t--) {\n      var close = parser.tags[t]\n      if (close.name !== closeTo) {\n        // fail the first time in strict mode\n        strictFail(parser, 'Unexpected close tag')\n      } else {\n        break\n      }\n    }\n\n    // didn't find it.  we already failed for strict, so just abort.\n    if (t < 0) {\n      strictFail(parser, 'Unmatched closing tag: ' + parser.tagName)\n      parser.textNode += '</' + parser.tagName + '>'\n      parser.state = S.TEXT\n      return\n    }\n    parser.tagName = tagName\n    var s = parser.tags.length\n    while (s-- > t) {\n      var tag = parser.tag = parser.tags.pop()\n      parser.tagName = parser.tag.name\n      emitNode(parser, 'onclosetag', parser.tagName)\n\n      var x = {}\n      for (var i in tag.ns) {\n        x[i] = tag.ns[i]\n      }\n\n      var parent = parser.tags[parser.tags.length - 1] || parser\n      if (parser.opt.xmlns && tag.ns !== parent.ns) {\n        // remove namespace bindings introduced by tag\n        Object.keys(tag.ns).forEach(function (p) {\n          var n = tag.ns[p]\n          emitNode(parser, 'onclosenamespace', { prefix: p, uri: n })\n        })\n      }\n    }\n    if (t === 0) parser.closedRoot = true\n    parser.tagName = parser.attribValue = parser.attribName = ''\n    parser.attribList.length = 0\n    parser.state = S.TEXT\n  }\n\n  function parseEntity (parser) {\n    var entity = parser.entity\n    var entityLC = entity.toLowerCase()\n    var num\n    var numStr = ''\n\n    if (parser.ENTITIES[entity]) {\n      return parser.ENTITIES[entity]\n    }\n    if (parser.ENTITIES[entityLC]) {\n      return parser.ENTITIES[entityLC]\n    }\n    entity = entityLC\n    if (entity.charAt(0) === '#') {\n      if (entity.charAt(1) === 'x') {\n        entity = entity.slice(2)\n        num = parseInt(entity, 16)\n        numStr = num.toString(16)\n      } else {\n        entity = entity.slice(1)\n        num = parseInt(entity, 10)\n        numStr = num.toString(10)\n      }\n    }\n    entity = entity.replace(/^0+/, '')\n    if (numStr.toLowerCase() !== entity) {\n      strictFail(parser, 'Invalid character entity')\n      return '&' + parser.entity + ';'\n    }\n\n    return String.fromCodePoint(num)\n  }\n\n  function beginWhiteSpace (parser, c) {\n    if (c === '<') {\n      parser.state = S.OPEN_WAKA\n      parser.startTagPosition = parser.position\n    } else if (not(whitespace, c)) {\n      // have to process this as a text node.\n      // weird, but happens.\n      strictFail(parser, 'Non-whitespace before first tag.')\n      parser.textNode = c\n      parser.state = S.TEXT\n    }\n  }\n\n  function write (chunk) {\n    var parser = this\n    if (this.error) {\n      throw this.error\n    }\n    if (parser.closed) {\n      return error(parser,\n        'Cannot write after close. Assign an onready handler.')\n    }\n    if (chunk === null) {\n      return end(parser)\n    }\n    var i = 0\n    var c = ''\n    while (true) {\n      c = chunk.charAt(i++)\n      parser.c = c\n      if (!c) {\n        break\n      }\n      if (parser.trackPosition) {\n        parser.position++\n        if (c === '\\n') {\n          parser.line++\n          parser.column = 0\n        } else {\n          parser.column++\n        }\n      }\n      switch (parser.state) {\n        case S.BEGIN:\n          parser.state = S.BEGIN_WHITESPACE\n          if (c === '\\uFEFF') {\n            continue\n          }\n          beginWhiteSpace(parser, c)\n          continue\n\n        case S.BEGIN_WHITESPACE:\n          beginWhiteSpace(parser, c)\n          continue\n\n        case S.TEXT:\n          if (parser.sawRoot && !parser.closedRoot) {\n            var starti = i - 1\n            while (c && c !== '<' && c !== '&') {\n              c = chunk.charAt(i++)\n              if (c && parser.trackPosition) {\n                parser.position++\n                if (c === '\\n') {\n                  parser.line++\n                  parser.column = 0\n                } else {\n                  parser.column++\n                }\n              }\n            }\n            parser.textNode += chunk.substring(starti, i - 1)\n          }\n          if (c === '<' && !(parser.sawRoot && parser.closedRoot && !parser.strict)) {\n            parser.state = S.OPEN_WAKA\n            parser.startTagPosition = parser.position\n          } else {\n            if (not(whitespace, c) && (!parser.sawRoot || parser.closedRoot)) {\n              strictFail(parser, 'Text data outside of root node.')\n            }\n            if (c === '&') {\n              parser.state = S.TEXT_ENTITY\n            } else {\n              parser.textNode += c\n            }\n          }\n          continue\n\n        case S.SCRIPT:\n          // only non-strict\n          if (c === '<') {\n            parser.state = S.SCRIPT_ENDING\n          } else {\n            parser.script += c\n          }\n          continue\n\n        case S.SCRIPT_ENDING:\n          if (c === '/') {\n            parser.state = S.CLOSE_TAG\n          } else {\n            parser.script += '<' + c\n            parser.state = S.SCRIPT\n          }\n          continue\n\n        case S.OPEN_WAKA:\n          // either a /, ?, !, or text is coming next.\n          if (c === '!') {\n            parser.state = S.SGML_DECL\n            parser.sgmlDecl = ''\n          } else if (is(whitespace, c)) {\n            // wait for it...\n          } else if (is(nameStart, c)) {\n            parser.state = S.OPEN_TAG\n            parser.tagName = c\n          } else if (c === '/') {\n            parser.state = S.CLOSE_TAG\n            parser.tagName = ''\n          } else if (c === '?') {\n            parser.state = S.PROC_INST\n            parser.procInstName = parser.procInstBody = ''\n          } else {\n            strictFail(parser, 'Unencoded <')\n            // if there was some whitespace, then add that in.\n            if (parser.startTagPosition + 1 < parser.position) {\n              var pad = parser.position - parser.startTagPosition\n              c = new Array(pad).join(' ') + c\n            }\n            parser.textNode += '<' + c\n            parser.state = S.TEXT\n          }\n          continue\n\n        case S.SGML_DECL:\n          if ((parser.sgmlDecl + c).toUpperCase() === CDATA) {\n            emitNode(parser, 'onopencdata')\n            parser.state = S.CDATA\n            parser.sgmlDecl = ''\n            parser.cdata = ''\n          } else if (parser.sgmlDecl + c === '--') {\n            parser.state = S.COMMENT\n            parser.comment = ''\n            parser.sgmlDecl = ''\n          } else if ((parser.sgmlDecl + c).toUpperCase() === DOCTYPE) {\n            parser.state = S.DOCTYPE\n            if (parser.doctype || parser.sawRoot) {\n              strictFail(parser,\n                'Inappropriately located doctype declaration')\n            }\n            parser.doctype = ''\n            parser.sgmlDecl = ''\n          } else if (c === '>') {\n            emitNode(parser, 'onsgmldeclaration', parser.sgmlDecl)\n            parser.sgmlDecl = ''\n            parser.state = S.TEXT\n          } else if (is(quote, c)) {\n            parser.state = S.SGML_DECL_QUOTED\n            parser.sgmlDecl += c\n          } else {\n            parser.sgmlDecl += c\n          }\n          continue\n\n        case S.SGML_DECL_QUOTED:\n          if (c === parser.q) {\n            parser.state = S.SGML_DECL\n            parser.q = ''\n          }\n          parser.sgmlDecl += c\n          continue\n\n        case S.DOCTYPE:\n          if (c === '>') {\n            parser.state = S.TEXT\n            emitNode(parser, 'ondoctype', parser.doctype)\n            parser.doctype = true // just remember that we saw it.\n          } else {\n            parser.doctype += c\n            if (c === '[') {\n              parser.state = S.DOCTYPE_DTD\n            } else if (is(quote, c)) {\n              parser.state = S.DOCTYPE_QUOTED\n              parser.q = c\n            }\n          }\n          continue\n\n        case S.DOCTYPE_QUOTED:\n          parser.doctype += c\n          if (c === parser.q) {\n            parser.q = ''\n            parser.state = S.DOCTYPE\n          }\n          continue\n\n        case S.DOCTYPE_DTD:\n          parser.doctype += c\n          if (c === ']') {\n            parser.state = S.DOCTYPE\n          } else if (is(quote, c)) {\n            parser.state = S.DOCTYPE_DTD_QUOTED\n            parser.q = c\n          }\n          continue\n\n        case S.DOCTYPE_DTD_QUOTED:\n          parser.doctype += c\n          if (c === parser.q) {\n            parser.state = S.DOCTYPE_DTD\n            parser.q = ''\n          }\n          continue\n\n        case S.COMMENT:\n          if (c === '-') {\n            parser.state = S.COMMENT_ENDING\n          } else {\n            parser.comment += c\n          }\n          continue\n\n        case S.COMMENT_ENDING:\n          if (c === '-') {\n            parser.state = S.COMMENT_ENDED\n            parser.comment = textopts(parser.opt, parser.comment)\n            if (parser.comment) {\n              emitNode(parser, 'oncomment', parser.comment)\n            }\n            parser.comment = ''\n          } else {\n            parser.comment += '-' + c\n            parser.state = S.COMMENT\n          }\n          continue\n\n        case S.COMMENT_ENDED:\n          if (c !== '>') {\n            strictFail(parser, 'Malformed comment')\n            // allow <!-- blah -- bloo --> in non-strict mode,\n            // which is a comment of \" blah -- bloo \"\n            parser.comment += '--' + c\n            parser.state = S.COMMENT\n          } else {\n            parser.state = S.TEXT\n          }\n          continue\n\n        case S.CDATA:\n          if (c === ']') {\n            parser.state = S.CDATA_ENDING\n          } else {\n            parser.cdata += c\n          }\n          continue\n\n        case S.CDATA_ENDING:\n          if (c === ']') {\n            parser.state = S.CDATA_ENDING_2\n          } else {\n            parser.cdata += ']' + c\n            parser.state = S.CDATA\n          }\n          continue\n\n        case S.CDATA_ENDING_2:\n          if (c === '>') {\n            if (parser.cdata) {\n              emitNode(parser, 'oncdata', parser.cdata)\n            }\n            emitNode(parser, 'onclosecdata')\n            parser.cdata = ''\n            parser.state = S.TEXT\n          } else if (c === ']') {\n            parser.cdata += ']'\n          } else {\n            parser.cdata += ']]' + c\n            parser.state = S.CDATA\n          }\n          continue\n\n        case S.PROC_INST:\n          if (c === '?') {\n            parser.state = S.PROC_INST_ENDING\n          } else if (is(whitespace, c)) {\n            parser.state = S.PROC_INST_BODY\n          } else {\n            parser.procInstName += c\n          }\n          continue\n\n        case S.PROC_INST_BODY:\n          if (!parser.procInstBody && is(whitespace, c)) {\n            continue\n          } else if (c === '?') {\n            parser.state = S.PROC_INST_ENDING\n          } else {\n            parser.procInstBody += c\n          }\n          continue\n\n        case S.PROC_INST_ENDING:\n          if (c === '>') {\n            emitNode(parser, 'onprocessinginstruction', {\n              name: parser.procInstName,\n              body: parser.procInstBody\n            })\n            parser.procInstName = parser.procInstBody = ''\n            parser.state = S.TEXT\n          } else {\n            parser.procInstBody += '?' + c\n            parser.state = S.PROC_INST_BODY\n          }\n          continue\n\n        case S.OPEN_TAG:\n          if (is(nameBody, c)) {\n            parser.tagName += c\n          } else {\n            newTag(parser)\n            if (c === '>') {\n              openTag(parser)\n            } else if (c === '/') {\n              parser.state = S.OPEN_TAG_SLASH\n            } else {\n              if (not(whitespace, c)) {\n                strictFail(parser, 'Invalid character in tag name')\n              }\n              parser.state = S.ATTRIB\n            }\n          }\n          continue\n\n        case S.OPEN_TAG_SLASH:\n          if (c === '>') {\n            openTag(parser, true)\n            closeTag(parser)\n          } else {\n            strictFail(parser, 'Forward-slash in opening tag not followed by >')\n            parser.state = S.ATTRIB\n          }\n          continue\n\n        case S.ATTRIB:\n          // haven't read the attribute name yet.\n          if (is(whitespace, c)) {\n            continue\n          } else if (c === '>') {\n            openTag(parser)\n          } else if (c === '/') {\n            parser.state = S.OPEN_TAG_SLASH\n          } else if (is(nameStart, c)) {\n            parser.attribName = c\n            parser.attribValue = ''\n            parser.state = S.ATTRIB_NAME\n          } else {\n            strictFail(parser, 'Invalid attribute name')\n          }\n          continue\n\n        case S.ATTRIB_NAME:\n          if (c === '=') {\n            parser.state = S.ATTRIB_VALUE\n          } else if (c === '>') {\n            strictFail(parser, 'Attribute without value')\n            parser.attribValue = parser.attribName\n            attrib(parser)\n            openTag(parser)\n          } else if (is(whitespace, c)) {\n            parser.state = S.ATTRIB_NAME_SAW_WHITE\n          } else if (is(nameBody, c)) {\n            parser.attribName += c\n          } else {\n            strictFail(parser, 'Invalid attribute name')\n          }\n          continue\n\n        case S.ATTRIB_NAME_SAW_WHITE:\n          if (c === '=') {\n            parser.state = S.ATTRIB_VALUE\n          } else if (is(whitespace, c)) {\n            continue\n          } else {\n            strictFail(parser, 'Attribute without value')\n            parser.tag.attributes[parser.attribName] = ''\n            parser.attribValue = ''\n            emitNode(parser, 'onattribute', {\n              name: parser.attribName,\n              value: ''\n            })\n            parser.attribName = ''\n            if (c === '>') {\n              openTag(parser)\n            } else if (is(nameStart, c)) {\n              parser.attribName = c\n              parser.state = S.ATTRIB_NAME\n            } else {\n              strictFail(parser, 'Invalid attribute name')\n              parser.state = S.ATTRIB\n            }\n          }\n          continue\n\n        case S.ATTRIB_VALUE:\n          if (is(whitespace, c)) {\n            continue\n          } else if (is(quote, c)) {\n            parser.q = c\n            parser.state = S.ATTRIB_VALUE_QUOTED\n          } else {\n            strictFail(parser, 'Unquoted attribute value')\n            parser.state = S.ATTRIB_VALUE_UNQUOTED\n            parser.attribValue = c\n          }\n          continue\n\n        case S.ATTRIB_VALUE_QUOTED:\n          if (c !== parser.q) {\n            if (c === '&') {\n              parser.state = S.ATTRIB_VALUE_ENTITY_Q\n            } else {\n              parser.attribValue += c\n            }\n            continue\n          }\n          attrib(parser)\n          parser.q = ''\n          parser.state = S.ATTRIB_VALUE_CLOSED\n          continue\n\n        case S.ATTRIB_VALUE_CLOSED:\n          if (is(whitespace, c)) {\n            parser.state = S.ATTRIB\n          } else if (c === '>') {\n            openTag(parser)\n          } else if (c === '/') {\n            parser.state = S.OPEN_TAG_SLASH\n          } else if (is(nameStart, c)) {\n            strictFail(parser, 'No whitespace between attributes')\n            parser.attribName = c\n            parser.attribValue = ''\n            parser.state = S.ATTRIB_NAME\n          } else {\n            strictFail(parser, 'Invalid attribute name')\n          }\n          continue\n\n        case S.ATTRIB_VALUE_UNQUOTED:\n          if (not(attribEnd, c)) {\n            if (c === '&') {\n              parser.state = S.ATTRIB_VALUE_ENTITY_U\n            } else {\n              parser.attribValue += c\n            }\n            continue\n          }\n          attrib(parser)\n          if (c === '>') {\n            openTag(parser)\n          } else {\n            parser.state = S.ATTRIB\n          }\n          continue\n\n        case S.CLOSE_TAG:\n          if (!parser.tagName) {\n            if (is(whitespace, c)) {\n              continue\n            } else if (not(nameStart, c)) {\n              if (parser.script) {\n                parser.script += '</' + c\n                parser.state = S.SCRIPT\n              } else {\n                strictFail(parser, 'Invalid tagname in closing tag.')\n              }\n            } else {\n              parser.tagName = c\n            }\n          } else if (c === '>') {\n            closeTag(parser)\n          } else if (is(nameBody, c)) {\n            parser.tagName += c\n          } else if (parser.script) {\n            parser.script += '</' + parser.tagName\n            parser.tagName = ''\n            parser.state = S.SCRIPT\n          } else {\n            if (not(whitespace, c)) {\n              strictFail(parser, 'Invalid tagname in closing tag')\n            }\n            parser.state = S.CLOSE_TAG_SAW_WHITE\n          }\n          continue\n\n        case S.CLOSE_TAG_SAW_WHITE:\n          if (is(whitespace, c)) {\n            continue\n          }\n          if (c === '>') {\n            closeTag(parser)\n          } else {\n            strictFail(parser, 'Invalid characters in closing tag')\n          }\n          continue\n\n        case S.TEXT_ENTITY:\n        case S.ATTRIB_VALUE_ENTITY_Q:\n        case S.ATTRIB_VALUE_ENTITY_U:\n          var returnState\n          var buffer\n          switch (parser.state) {\n            case S.TEXT_ENTITY:\n              returnState = S.TEXT\n              buffer = 'textNode'\n              break\n\n            case S.ATTRIB_VALUE_ENTITY_Q:\n              returnState = S.ATTRIB_VALUE_QUOTED\n              buffer = 'attribValue'\n              break\n\n            case S.ATTRIB_VALUE_ENTITY_U:\n              returnState = S.ATTRIB_VALUE_UNQUOTED\n              buffer = 'attribValue'\n              break\n          }\n\n          if (c === ';') {\n            parser[buffer] += parseEntity(parser)\n            parser.entity = ''\n            parser.state = returnState\n          } else if (is(parser.entity.length ? entityBody : entityStart, c)) {\n            parser.entity += c\n          } else {\n            strictFail(parser, 'Invalid character in entity name')\n            parser[buffer] += '&' + parser.entity + c\n            parser.entity = ''\n            parser.state = returnState\n          }\n\n          continue\n\n        default:\n          throw new Error(parser, 'Unknown state: ' + parser.state)\n      }\n    } // while\n\n    if (parser.position >= parser.bufferCheckPosition) {\n      checkBufferLength(parser)\n    }\n    return parser\n  }\n\n  /*! http://mths.be/fromcodepoint v0.1.0 by @mathias */\n  if (!String.fromCodePoint) {\n    (function () {\n      var stringFromCharCode = String.fromCharCode\n      var floor = Math.floor\n      var fromCodePoint = function () {\n        var MAX_SIZE = 0x4000\n        var codeUnits = []\n        var highSurrogate\n        var lowSurrogate\n        var index = -1\n        var length = arguments.length\n        if (!length) {\n          return ''\n        }\n        var result = ''\n        while (++index < length) {\n          var codePoint = Number(arguments[index])\n          if (\n            !isFinite(codePoint) || // `NaN`, `+Infinity`, or `-Infinity`\n            codePoint < 0 || // not a valid Unicode code point\n            codePoint > 0x10FFFF || // not a valid Unicode code point\n            floor(codePoint) !== codePoint // not an integer\n          ) {\n            throw RangeError('Invalid code point: ' + codePoint)\n          }\n          if (codePoint <= 0xFFFF) { // BMP code point\n            codeUnits.push(codePoint)\n          } else { // Astral code point; split in surrogate halves\n            // http://mathiasbynens.be/notes/javascript-encoding#surrogate-formulae\n            codePoint -= 0x10000\n            highSurrogate = (codePoint >> 10) + 0xD800\n            lowSurrogate = (codePoint % 0x400) + 0xDC00\n            codeUnits.push(highSurrogate, lowSurrogate)\n          }\n          if (index + 1 === length || codeUnits.length > MAX_SIZE) {\n            result += stringFromCharCode.apply(null, codeUnits)\n            codeUnits.length = 0\n          }\n        }\n        return result\n      }\n      if (Object.defineProperty) {\n        Object.defineProperty(String, 'fromCodePoint', {\n          value: fromCodePoint,\n          configurable: true,\n          writable: true\n        })\n      } else {\n        String.fromCodePoint = fromCodePoint\n      }\n    }())\n  }\n})(typeof exports === 'undefined' ? this.sax = {} : exports)\n\n}).call(this,require(\"buffer\").Buffer)\n\n},{\"buffer\":3,\"stream\":30,\"string_decoder\":36}]},{},[1])\n\n","/*!\n * The buffer module from node.js, for the browser.\n *\n * @author   Feross Aboukhadijeh <feross@feross.org> <http://feross.org>\n * @license  MIT\n */\n/* eslint-disable no-proto */\n\nvar base64 = require('base64-js')\nvar ieee754 = require('ieee754')\nvar isArray = require('isarray')\n\nexports.Buffer = Buffer\nexports.SlowBuffer = SlowBuffer\nexports.INSPECT_MAX_BYTES = 50\nBuffer.poolSize = 8192 // not used by this implementation\n\nvar rootParent = {}\n\n/**\n * If `Buffer.TYPED_ARRAY_SUPPORT`:\n *   === true    Use Uint8Array implementation (fastest)\n *   === false   Use Object implementation (most compatible, even IE6)\n *\n * Browsers that support typed arrays are IE 10+, Firefox 4+, Chrome 7+, Safari 5.1+,\n * Opera 11.6+, iOS 4.2+.\n *\n * Due to various browser bugs, sometimes the Object implementation will be used even\n * when the browser supports typed arrays.\n *\n * Note:\n *\n *   - Firefox 4-29 lacks support for adding new properties to `Uint8Array` instances,\n *     See: https://bugzilla.mozilla.org/show_bug.cgi?id=695438.\n *\n *   - Safari 5-7 lacks support for changing the `Object.prototype.constructor` property\n *     on objects.\n *\n *   - Chrome 9-10 is missing the `TypedArray.prototype.subarray` function.\n *\n *   - IE10 has a broken `TypedArray.prototype.subarray` function which returns arrays of\n *     incorrect length in some situations.\n\n * We detect these buggy browsers and set `Buffer.TYPED_ARRAY_SUPPORT` to `false` so they\n * get the Object implementation, which is slower but behaves correctly.\n */\nBuffer.TYPED_ARRAY_SUPPORT = global.TYPED_ARRAY_SUPPORT !== undefined\n  ? global.TYPED_ARRAY_SUPPORT\n  : typedArraySupport()\n\nfunction typedArraySupport () {\n  function Bar () {}\n  try {\n    var arr = new Uint8Array(1)\n    arr.foo = function () { return 42 }\n    arr.constructor = Bar\n    return arr.foo() === 42 && // typed array instances can be augmented\n        arr.constructor === Bar && // constructor can be set\n        typeof arr.subarray === 'function' && // chrome 9-10 lack `subarray`\n        arr.subarray(1, 1).byteLength === 0 // ie10 has broken `subarray`\n  } catch (e) {\n    return false\n  }\n}\n\nfunction kMaxLength () {\n  return Buffer.TYPED_ARRAY_SUPPORT\n    ? 0x7fffffff\n    : 0x3fffffff\n}\n\n/**\n * Class: Buffer\n * =============\n *\n * The Buffer constructor returns instances of `Uint8Array` that are augmented\n * with function properties for all the node `Buffer` API functions. We use\n * `Uint8Array` so that square bracket notation works as expected -- it returns\n * a single octet.\n *\n * By augmenting the instances, we can avoid modifying the `Uint8Array`\n * prototype.\n */\nfunction Buffer (arg) {\n  if (!(this instanceof Buffer)) {\n    // Avoid going through an ArgumentsAdaptorTrampoline in the common case.\n    if (arguments.length > 1) return new Buffer(arg, arguments[1])\n    return new Buffer(arg)\n  }\n\n  this.length = 0\n  this.parent = undefined\n\n  // Common case.\n  if (typeof arg === 'number') {\n    return fromNumber(this, arg)\n  }\n\n  // Slightly less common case.\n  if (typeof arg === 'string') {\n    return fromString(this, arg, arguments.length > 1 ? arguments[1] : 'utf8')\n  }\n\n  // Unusual.\n  return fromObject(this, arg)\n}\n\nfunction fromNumber (that, length) {\n  that = allocate(that, length < 0 ? 0 : checked(length) | 0)\n  if (!Buffer.TYPED_ARRAY_SUPPORT) {\n    for (var i = 0; i < length; i++) {\n      that[i] = 0\n    }\n  }\n  return that\n}\n\nfunction fromString (that, string, encoding) {\n  if (typeof encoding !== 'string' || encoding === '') encoding = 'utf8'\n\n  // Assumption: byteLength() return value is always < kMaxLength.\n  var length = byteLength(string, encoding) | 0\n  that = allocate(that, length)\n\n  that.write(string, encoding)\n  return that\n}\n\nfunction fromObject (that, object) {\n  if (Buffer.isBuffer(object)) return fromBuffer(that, object)\n\n  if (isArray(object)) return fromArray(that, object)\n\n  if (object == null) {\n    throw new TypeError('must start with number, buffer, array or string')\n  }\n\n  if (typeof ArrayBuffer !== 'undefined') {\n    if (object.buffer instanceof ArrayBuffer) {\n      return fromTypedArray(that, object)\n    }\n    if (object instanceof ArrayBuffer) {\n      return fromArrayBuffer(that, object)\n    }\n  }\n\n  if (object.length) return fromArrayLike(that, object)\n\n  return fromJsonObject(that, object)\n}\n\nfunction fromBuffer (that, buffer) {\n  var length = checked(buffer.length) | 0\n  that = allocate(that, length)\n  buffer.copy(that, 0, 0, length)\n  return that\n}\n\nfunction fromArray (that, array) {\n  var length = checked(array.length) | 0\n  that = allocate(that, length)\n  for (var i = 0; i < length; i += 1) {\n    that[i] = array[i] & 255\n  }\n  return that\n}\n\n// Duplicate of fromArray() to keep fromArray() monomorphic.\nfunction fromTypedArray (that, array) {\n  var length = checked(array.length) | 0\n  that = allocate(that, length)\n  // Truncating the elements is probably not what people expect from typed\n  // arrays with BYTES_PER_ELEMENT > 1 but it's compatible with the behavior\n  // of the old Buffer constructor.\n  for (var i = 0; i < length; i += 1) {\n    that[i] = array[i] & 255\n  }\n  return that\n}\n\nfunction fromArrayBuffer (that, array) {\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    // Return an augmented `Uint8Array` instance, for best performance\n    array.byteLength\n    that = Buffer._augment(new Uint8Array(array))\n  } else {\n    // Fallback: Return an object instance of the Buffer class\n    that = fromTypedArray(that, new Uint8Array(array))\n  }\n  return that\n}\n\nfunction fromArrayLike (that, array) {\n  var length = checked(array.length) | 0\n  that = allocate(that, length)\n  for (var i = 0; i < length; i += 1) {\n    that[i] = array[i] & 255\n  }\n  return that\n}\n\n// Deserialize { type: 'Buffer', data: [1,2,3,...] } into a Buffer object.\n// Returns a zero-length buffer for inputs that don't conform to the spec.\nfunction fromJsonObject (that, object) {\n  var array\n  var length = 0\n\n  if (object.type === 'Buffer' && isArray(object.data)) {\n    array = object.data\n    length = checked(array.length) | 0\n  }\n  that = allocate(that, length)\n\n  for (var i = 0; i < length; i += 1) {\n    that[i] = array[i] & 255\n  }\n  return that\n}\n\nif (Buffer.TYPED_ARRAY_SUPPORT) {\n  Buffer.prototype.__proto__ = Uint8Array.prototype\n  Buffer.__proto__ = Uint8Array\n}\n\nfunction allocate (that, length) {\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    // Return an augmented `Uint8Array` instance, for best performance\n    that = Buffer._augment(new Uint8Array(length))\n    that.__proto__ = Buffer.prototype\n  } else {\n    // Fallback: Return an object instance of the Buffer class\n    that.length = length\n    that._isBuffer = true\n  }\n\n  var fromPool = length !== 0 && length <= Buffer.poolSize >>> 1\n  if (fromPool) that.parent = rootParent\n\n  return that\n}\n\nfunction checked (length) {\n  // Note: cannot use `length < kMaxLength` here because that fails when\n  // length is NaN (which is otherwise coerced to zero.)\n  if (length >= kMaxLength()) {\n    throw new RangeError('Attempt to allocate Buffer larger than maximum ' +\n                         'size: 0x' + kMaxLength().toString(16) + ' bytes')\n  }\n  return length | 0\n}\n\nfunction SlowBuffer (subject, encoding) {\n  if (!(this instanceof SlowBuffer)) return new SlowBuffer(subject, encoding)\n\n  var buf = new Buffer(subject, encoding)\n  delete buf.parent\n  return buf\n}\n\nBuffer.isBuffer = function isBuffer (b) {\n  return !!(b != null && b._isBuffer)\n}\n\nBuffer.compare = function compare (a, b) {\n  if (!Buffer.isBuffer(a) || !Buffer.isBuffer(b)) {\n    throw new TypeError('Arguments must be Buffers')\n  }\n\n  if (a === b) return 0\n\n  var x = a.length\n  var y = b.length\n\n  var i = 0\n  var len = Math.min(x, y)\n  while (i < len) {\n    if (a[i] !== b[i]) break\n\n    ++i\n  }\n\n  if (i !== len) {\n    x = a[i]\n    y = b[i]\n  }\n\n  if (x < y) return -1\n  if (y < x) return 1\n  return 0\n}\n\nBuffer.isEncoding = function isEncoding (encoding) {\n  switch (String(encoding).toLowerCase()) {\n    case 'hex':\n    case 'utf8':\n    case 'utf-8':\n    case 'ascii':\n    case 'binary':\n    case 'base64':\n    case 'raw':\n    case 'ucs2':\n    case 'ucs-2':\n    case 'utf16le':\n    case 'utf-16le':\n      return true\n    default:\n      return false\n  }\n}\n\nBuffer.concat = function concat (list, length) {\n  if (!isArray(list)) throw new TypeError('list argument must be an Array of Buffers.')\n\n  if (list.length === 0) {\n    return new Buffer(0)\n  }\n\n  var i\n  if (length === undefined) {\n    length = 0\n    for (i = 0; i < list.length; i++) {\n      length += list[i].length\n    }\n  }\n\n  var buf = new Buffer(length)\n  var pos = 0\n  for (i = 0; i < list.length; i++) {\n    var item = list[i]\n    item.copy(buf, pos)\n    pos += item.length\n  }\n  return buf\n}\n\nfunction byteLength (string, encoding) {\n  if (typeof string !== 'string') string = '' + string\n\n  var len = string.length\n  if (len === 0) return 0\n\n  // Use a for loop to avoid recursion\n  var loweredCase = false\n  for (;;) {\n    switch (encoding) {\n      case 'ascii':\n      case 'binary':\n      // Deprecated\n      case 'raw':\n      case 'raws':\n        return len\n      case 'utf8':\n      case 'utf-8':\n        return utf8ToBytes(string).length\n      case 'ucs2':\n      case 'ucs-2':\n      case 'utf16le':\n      case 'utf-16le':\n        return len * 2\n      case 'hex':\n        return len >>> 1\n      case 'base64':\n        return base64ToBytes(string).length\n      default:\n        if (loweredCase) return utf8ToBytes(string).length // assume utf8\n        encoding = ('' + encoding).toLowerCase()\n        loweredCase = true\n    }\n  }\n}\nBuffer.byteLength = byteLength\n\n// pre-set for values that may exist in the future\nBuffer.prototype.length = undefined\nBuffer.prototype.parent = undefined\n\nfunction slowToString (encoding, start, end) {\n  var loweredCase = false\n\n  start = start | 0\n  end = end === undefined || end === Infinity ? this.length : end | 0\n\n  if (!encoding) encoding = 'utf8'\n  if (start < 0) start = 0\n  if (end > this.length) end = this.length\n  if (end <= start) return ''\n\n  while (true) {\n    switch (encoding) {\n      case 'hex':\n        return hexSlice(this, start, end)\n\n      case 'utf8':\n      case 'utf-8':\n        return utf8Slice(this, start, end)\n\n      case 'ascii':\n        return asciiSlice(this, start, end)\n\n      case 'binary':\n        return binarySlice(this, start, end)\n\n      case 'base64':\n        return base64Slice(this, start, end)\n\n      case 'ucs2':\n      case 'ucs-2':\n      case 'utf16le':\n      case 'utf-16le':\n        return utf16leSlice(this, start, end)\n\n      default:\n        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)\n        encoding = (encoding + '').toLowerCase()\n        loweredCase = true\n    }\n  }\n}\n\nBuffer.prototype.toString = function toString () {\n  var length = this.length | 0\n  if (length === 0) return ''\n  if (arguments.length === 0) return utf8Slice(this, 0, length)\n  return slowToString.apply(this, arguments)\n}\n\nBuffer.prototype.equals = function equals (b) {\n  if (!Buffer.isBuffer(b)) throw new TypeError('Argument must be a Buffer')\n  if (this === b) return true\n  return Buffer.compare(this, b) === 0\n}\n\nBuffer.prototype.inspect = function inspect () {\n  var str = ''\n  var max = exports.INSPECT_MAX_BYTES\n  if (this.length > 0) {\n    str = this.toString('hex', 0, max).match(/.{2}/g).join(' ')\n    if (this.length > max) str += ' ... '\n  }\n  return '<Buffer ' + str + '>'\n}\n\nBuffer.prototype.compare = function compare (b) {\n  if (!Buffer.isBuffer(b)) throw new TypeError('Argument must be a Buffer')\n  if (this === b) return 0\n  return Buffer.compare(this, b)\n}\n\nBuffer.prototype.indexOf = function indexOf (val, byteOffset) {\n  if (byteOffset > 0x7fffffff) byteOffset = 0x7fffffff\n  else if (byteOffset < -0x80000000) byteOffset = -0x80000000\n  byteOffset >>= 0\n\n  if (this.length === 0) return -1\n  if (byteOffset >= this.length) return -1\n\n  // Negative offsets start from the end of the buffer\n  if (byteOffset < 0) byteOffset = Math.max(this.length + byteOffset, 0)\n\n  if (typeof val === 'string') {\n    if (val.length === 0) return -1 // special case: looking for empty string always fails\n    return String.prototype.indexOf.call(this, val, byteOffset)\n  }\n  if (Buffer.isBuffer(val)) {\n    return arrayIndexOf(this, val, byteOffset)\n  }\n  if (typeof val === 'number') {\n    if (Buffer.TYPED_ARRAY_SUPPORT && Uint8Array.prototype.indexOf === 'function') {\n      return Uint8Array.prototype.indexOf.call(this, val, byteOffset)\n    }\n    return arrayIndexOf(this, [ val ], byteOffset)\n  }\n\n  function arrayIndexOf (arr, val, byteOffset) {\n    var foundIndex = -1\n    for (var i = 0; byteOffset + i < arr.length; i++) {\n      if (arr[byteOffset + i] === val[foundIndex === -1 ? 0 : i - foundIndex]) {\n        if (foundIndex === -1) foundIndex = i\n        if (i - foundIndex + 1 === val.length) return byteOffset + foundIndex\n      } else {\n        foundIndex = -1\n      }\n    }\n    return -1\n  }\n\n  throw new TypeError('val must be string, number or Buffer')\n}\n\n// `get` is deprecated\nBuffer.prototype.get = function get (offset) {\n  console.log('.get() is deprecated. Access using array indexes instead.')\n  return this.readUInt8(offset)\n}\n\n// `set` is deprecated\nBuffer.prototype.set = function set (v, offset) {\n  console.log('.set() is deprecated. Access using array indexes instead.')\n  return this.writeUInt8(v, offset)\n}\n\nfunction hexWrite (buf, string, offset, length) {\n  offset = Number(offset) || 0\n  var remaining = buf.length - offset\n  if (!length) {\n    length = remaining\n  } else {\n    length = Number(length)\n    if (length > remaining) {\n      length = remaining\n    }\n  }\n\n  // must be an even number of digits\n  var strLen = string.length\n  if (strLen % 2 !== 0) throw new Error('Invalid hex string')\n\n  if (length > strLen / 2) {\n    length = strLen / 2\n  }\n  for (var i = 0; i < length; i++) {\n    var parsed = parseInt(string.substr(i * 2, 2), 16)\n    if (isNaN(parsed)) throw new Error('Invalid hex string')\n    buf[offset + i] = parsed\n  }\n  return i\n}\n\nfunction utf8Write (buf, string, offset, length) {\n  return blitBuffer(utf8ToBytes(string, buf.length - offset), buf, offset, length)\n}\n\nfunction asciiWrite (buf, string, offset, length) {\n  return blitBuffer(asciiToBytes(string), buf, offset, length)\n}\n\nfunction binaryWrite (buf, string, offset, length) {\n  return asciiWrite(buf, string, offset, length)\n}\n\nfunction base64Write (buf, string, offset, length) {\n  return blitBuffer(base64ToBytes(string), buf, offset, length)\n}\n\nfunction ucs2Write (buf, string, offset, length) {\n  return blitBuffer(utf16leToBytes(string, buf.length - offset), buf, offset, length)\n}\n\nBuffer.prototype.write = function write (string, offset, length, encoding) {\n  // Buffer#write(string)\n  if (offset === undefined) {\n    encoding = 'utf8'\n    length = this.length\n    offset = 0\n  // Buffer#write(string, encoding)\n  } else if (length === undefined && typeof offset === 'string') {\n    encoding = offset\n    length = this.length\n    offset = 0\n  // Buffer#write(string, offset[, length][, encoding])\n  } else if (isFinite(offset)) {\n    offset = offset | 0\n    if (isFinite(length)) {\n      length = length | 0\n      if (encoding === undefined) encoding = 'utf8'\n    } else {\n      encoding = length\n      length = undefined\n    }\n  // legacy write(string, encoding, offset, length) - remove in v0.13\n  } else {\n    var swap = encoding\n    encoding = offset\n    offset = length | 0\n    length = swap\n  }\n\n  var remaining = this.length - offset\n  if (length === undefined || length > remaining) length = remaining\n\n  if ((string.length > 0 && (length < 0 || offset < 0)) || offset > this.length) {\n    throw new RangeError('attempt to write outside buffer bounds')\n  }\n\n  if (!encoding) encoding = 'utf8'\n\n  var loweredCase = false\n  for (;;) {\n    switch (encoding) {\n      case 'hex':\n        return hexWrite(this, string, offset, length)\n\n      case 'utf8':\n      case 'utf-8':\n        return utf8Write(this, string, offset, length)\n\n      case 'ascii':\n        return asciiWrite(this, string, offset, length)\n\n      case 'binary':\n        return binaryWrite(this, string, offset, length)\n\n      case 'base64':\n        // Warning: maxLength not taken into account in base64Write\n        return base64Write(this, string, offset, length)\n\n      case 'ucs2':\n      case 'ucs-2':\n      case 'utf16le':\n      case 'utf-16le':\n        return ucs2Write(this, string, offset, length)\n\n      default:\n        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)\n        encoding = ('' + encoding).toLowerCase()\n        loweredCase = true\n    }\n  }\n}\n\nBuffer.prototype.toJSON = function toJSON () {\n  return {\n    type: 'Buffer',\n    data: Array.prototype.slice.call(this._arr || this, 0)\n  }\n}\n\nfunction base64Slice (buf, start, end) {\n  if (start === 0 && end === buf.length) {\n    return base64.fromByteArray(buf)\n  } else {\n    return base64.fromByteArray(buf.slice(start, end))\n  }\n}\n\nfunction utf8Slice (buf, start, end) {\n  end = Math.min(buf.length, end)\n  var res = []\n\n  var i = start\n  while (i < end) {\n    var firstByte = buf[i]\n    var codePoint = null\n    var bytesPerSequence = (firstByte > 0xEF) ? 4\n      : (firstByte > 0xDF) ? 3\n      : (firstByte > 0xBF) ? 2\n      : 1\n\n    if (i + bytesPerSequence <= end) {\n      var secondByte, thirdByte, fourthByte, tempCodePoint\n\n      switch (bytesPerSequence) {\n        case 1:\n          if (firstByte < 0x80) {\n            codePoint = firstByte\n          }\n          break\n        case 2:\n          secondByte = buf[i + 1]\n          if ((secondByte & 0xC0) === 0x80) {\n            tempCodePoint = (firstByte & 0x1F) << 0x6 | (secondByte & 0x3F)\n            if (tempCodePoint > 0x7F) {\n              codePoint = tempCodePoint\n            }\n          }\n          break\n        case 3:\n          secondByte = buf[i + 1]\n          thirdByte = buf[i + 2]\n          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80) {\n            tempCodePoint = (firstByte & 0xF) << 0xC | (secondByte & 0x3F) << 0x6 | (thirdByte & 0x3F)\n            if (tempCodePoint > 0x7FF && (tempCodePoint < 0xD800 || tempCodePoint > 0xDFFF)) {\n              codePoint = tempCodePoint\n            }\n          }\n          break\n        case 4:\n          secondByte = buf[i + 1]\n          thirdByte = buf[i + 2]\n          fourthByte = buf[i + 3]\n          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80 && (fourthByte & 0xC0) === 0x80) {\n            tempCodePoint = (firstByte & 0xF) << 0x12 | (secondByte & 0x3F) << 0xC | (thirdByte & 0x3F) << 0x6 | (fourthByte & 0x3F)\n            if (tempCodePoint > 0xFFFF && tempCodePoint < 0x110000) {\n              codePoint = tempCodePoint\n            }\n          }\n      }\n    }\n\n    if (codePoint === null) {\n      // we did not generate a valid codePoint so insert a\n      // replacement char (U+FFFD) and advance only 1 byte\n      codePoint = 0xFFFD\n      bytesPerSequence = 1\n    } else if (codePoint > 0xFFFF) {\n      // encode to utf16 (surrogate pair dance)\n      codePoint -= 0x10000\n      res.push(codePoint >>> 10 & 0x3FF | 0xD800)\n      codePoint = 0xDC00 | codePoint & 0x3FF\n    }\n\n    res.push(codePoint)\n    i += bytesPerSequence\n  }\n\n  return decodeCodePointsArray(res)\n}\n\n// Based on http://stackoverflow.com/a/22747272/680742, the browser with\n// the lowest limit is Chrome, with 0x10000 args.\n// We go 1 magnitude less, for safety\nvar MAX_ARGUMENTS_LENGTH = 0x1000\n\nfunction decodeCodePointsArray (codePoints) {\n  var len = codePoints.length\n  if (len <= MAX_ARGUMENTS_LENGTH) {\n    return String.fromCharCode.apply(String, codePoints) // avoid extra slice()\n  }\n\n  // Decode in chunks to avoid \"call stack size exceeded\".\n  var res = ''\n  var i = 0\n  while (i < len) {\n    res += String.fromCharCode.apply(\n      String,\n      codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH)\n    )\n  }\n  return res\n}\n\nfunction asciiSlice (buf, start, end) {\n  var ret = ''\n  end = Math.min(buf.length, end)\n\n  for (var i = start; i < end; i++) {\n    ret += String.fromCharCode(buf[i] & 0x7F)\n  }\n  return ret\n}\n\nfunction binarySlice (buf, start, end) {\n  var ret = ''\n  end = Math.min(buf.length, end)\n\n  for (var i = start; i < end; i++) {\n    ret += String.fromCharCode(buf[i])\n  }\n  return ret\n}\n\nfunction hexSlice (buf, start, end) {\n  var len = buf.length\n\n  if (!start || start < 0) start = 0\n  if (!end || end < 0 || end > len) end = len\n\n  var out = ''\n  for (var i = start; i < end; i++) {\n    out += toHex(buf[i])\n  }\n  return out\n}\n\nfunction utf16leSlice (buf, start, end) {\n  var bytes = buf.slice(start, end)\n  var res = ''\n  for (var i = 0; i < bytes.length; i += 2) {\n    res += String.fromCharCode(bytes[i] + bytes[i + 1] * 256)\n  }\n  return res\n}\n\nBuffer.prototype.slice = function slice (start, end) {\n  var len = this.length\n  start = ~~start\n  end = end === undefined ? len : ~~end\n\n  if (start < 0) {\n    start += len\n    if (start < 0) start = 0\n  } else if (start > len) {\n    start = len\n  }\n\n  if (end < 0) {\n    end += len\n    if (end < 0) end = 0\n  } else if (end > len) {\n    end = len\n  }\n\n  if (end < start) end = start\n\n  var newBuf\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    newBuf = Buffer._augment(this.subarray(start, end))\n  } else {\n    var sliceLen = end - start\n    newBuf = new Buffer(sliceLen, undefined)\n    for (var i = 0; i < sliceLen; i++) {\n      newBuf[i] = this[i + start]\n    }\n  }\n\n  if (newBuf.length) newBuf.parent = this.parent || this\n\n  return newBuf\n}\n\n/*\n * Need to make sure that buffer isn't trying to write out of bounds.\n */\nfunction checkOffset (offset, ext, length) {\n  if ((offset % 1) !== 0 || offset < 0) throw new RangeError('offset is not uint')\n  if (offset + ext > length) throw new RangeError('Trying to access beyond buffer length')\n}\n\nBuffer.prototype.readUIntLE = function readUIntLE (offset, byteLength, noAssert) {\n  offset = offset | 0\n  byteLength = byteLength | 0\n  if (!noAssert) checkOffset(offset, byteLength, this.length)\n\n  var val = this[offset]\n  var mul = 1\n  var i = 0\n  while (++i < byteLength && (mul *= 0x100)) {\n    val += this[offset + i] * mul\n  }\n\n  return val\n}\n\nBuffer.prototype.readUIntBE = function readUIntBE (offset, byteLength, noAssert) {\n  offset = offset | 0\n  byteLength = byteLength | 0\n  if (!noAssert) {\n    checkOffset(offset, byteLength, this.length)\n  }\n\n  var val = this[offset + --byteLength]\n  var mul = 1\n  while (byteLength > 0 && (mul *= 0x100)) {\n    val += this[offset + --byteLength] * mul\n  }\n\n  return val\n}\n\nBuffer.prototype.readUInt8 = function readUInt8 (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 1, this.length)\n  return this[offset]\n}\n\nBuffer.prototype.readUInt16LE = function readUInt16LE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 2, this.length)\n  return this[offset] | (this[offset + 1] << 8)\n}\n\nBuffer.prototype.readUInt16BE = function readUInt16BE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 2, this.length)\n  return (this[offset] << 8) | this[offset + 1]\n}\n\nBuffer.prototype.readUInt32LE = function readUInt32LE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 4, this.length)\n\n  return ((this[offset]) |\n      (this[offset + 1] << 8) |\n      (this[offset + 2] << 16)) +\n      (this[offset + 3] * 0x1000000)\n}\n\nBuffer.prototype.readUInt32BE = function readUInt32BE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 4, this.length)\n\n  return (this[offset] * 0x1000000) +\n    ((this[offset + 1] << 16) |\n    (this[offset + 2] << 8) |\n    this[offset + 3])\n}\n\nBuffer.prototype.readIntLE = function readIntLE (offset, byteLength, noAssert) {\n  offset = offset | 0\n  byteLength = byteLength | 0\n  if (!noAssert) checkOffset(offset, byteLength, this.length)\n\n  var val = this[offset]\n  var mul = 1\n  var i = 0\n  while (++i < byteLength && (mul *= 0x100)) {\n    val += this[offset + i] * mul\n  }\n  mul *= 0x80\n\n  if (val >= mul) val -= Math.pow(2, 8 * byteLength)\n\n  return val\n}\n\nBuffer.prototype.readIntBE = function readIntBE (offset, byteLength, noAssert) {\n  offset = offset | 0\n  byteLength = byteLength | 0\n  if (!noAssert) checkOffset(offset, byteLength, this.length)\n\n  var i = byteLength\n  var mul = 1\n  var val = this[offset + --i]\n  while (i > 0 && (mul *= 0x100)) {\n    val += this[offset + --i] * mul\n  }\n  mul *= 0x80\n\n  if (val >= mul) val -= Math.pow(2, 8 * byteLength)\n\n  return val\n}\n\nBuffer.prototype.readInt8 = function readInt8 (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 1, this.length)\n  if (!(this[offset] & 0x80)) return (this[offset])\n  return ((0xff - this[offset] + 1) * -1)\n}\n\nBuffer.prototype.readInt16LE = function readInt16LE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 2, this.length)\n  var val = this[offset] | (this[offset + 1] << 8)\n  return (val & 0x8000) ? val | 0xFFFF0000 : val\n}\n\nBuffer.prototype.readInt16BE = function readInt16BE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 2, this.length)\n  var val = this[offset + 1] | (this[offset] << 8)\n  return (val & 0x8000) ? val | 0xFFFF0000 : val\n}\n\nBuffer.prototype.readInt32LE = function readInt32LE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 4, this.length)\n\n  return (this[offset]) |\n    (this[offset + 1] << 8) |\n    (this[offset + 2] << 16) |\n    (this[offset + 3] << 24)\n}\n\nBuffer.prototype.readInt32BE = function readInt32BE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 4, this.length)\n\n  return (this[offset] << 24) |\n    (this[offset + 1] << 16) |\n    (this[offset + 2] << 8) |\n    (this[offset + 3])\n}\n\nBuffer.prototype.readFloatLE = function readFloatLE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 4, this.length)\n  return ieee754.read(this, offset, true, 23, 4)\n}\n\nBuffer.prototype.readFloatBE = function readFloatBE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 4, this.length)\n  return ieee754.read(this, offset, false, 23, 4)\n}\n\nBuffer.prototype.readDoubleLE = function readDoubleLE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 8, this.length)\n  return ieee754.read(this, offset, true, 52, 8)\n}\n\nBuffer.prototype.readDoubleBE = function readDoubleBE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 8, this.length)\n  return ieee754.read(this, offset, false, 52, 8)\n}\n\nfunction checkInt (buf, value, offset, ext, max, min) {\n  if (!Buffer.isBuffer(buf)) throw new TypeError('buffer must be a Buffer instance')\n  if (value > max || value < min) throw new RangeError('value is out of bounds')\n  if (offset + ext > buf.length) throw new RangeError('index out of range')\n}\n\nBuffer.prototype.writeUIntLE = function writeUIntLE (value, offset, byteLength, noAssert) {\n  value = +value\n  offset = offset | 0\n  byteLength = byteLength | 0\n  if (!noAssert) checkInt(this, value, offset, byteLength, Math.pow(2, 8 * byteLength), 0)\n\n  var mul = 1\n  var i = 0\n  this[offset] = value & 0xFF\n  while (++i < byteLength && (mul *= 0x100)) {\n    this[offset + i] = (value / mul) & 0xFF\n  }\n\n  return offset + byteLength\n}\n\nBuffer.prototype.writeUIntBE = function writeUIntBE (value, offset, byteLength, noAssert) {\n  value = +value\n  offset = offset | 0\n  byteLength = byteLength | 0\n  if (!noAssert) checkInt(this, value, offset, byteLength, Math.pow(2, 8 * byteLength), 0)\n\n  var i = byteLength - 1\n  var mul = 1\n  this[offset + i] = value & 0xFF\n  while (--i >= 0 && (mul *= 0x100)) {\n    this[offset + i] = (value / mul) & 0xFF\n  }\n\n  return offset + byteLength\n}\n\nBuffer.prototype.writeUInt8 = function writeUInt8 (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 1, 0xff, 0)\n  if (!Buffer.TYPED_ARRAY_SUPPORT) value = Math.floor(value)\n  this[offset] = (value & 0xff)\n  return offset + 1\n}\n\nfunction objectWriteUInt16 (buf, value, offset, littleEndian) {\n  if (value < 0) value = 0xffff + value + 1\n  for (var i = 0, j = Math.min(buf.length - offset, 2); i < j; i++) {\n    buf[offset + i] = (value & (0xff << (8 * (littleEndian ? i : 1 - i)))) >>>\n      (littleEndian ? i : 1 - i) * 8\n  }\n}\n\nBuffer.prototype.writeUInt16LE = function writeUInt16LE (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    this[offset] = (value & 0xff)\n    this[offset + 1] = (value >>> 8)\n  } else {\n    objectWriteUInt16(this, value, offset, true)\n  }\n  return offset + 2\n}\n\nBuffer.prototype.writeUInt16BE = function writeUInt16BE (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    this[offset] = (value >>> 8)\n    this[offset + 1] = (value & 0xff)\n  } else {\n    objectWriteUInt16(this, value, offset, false)\n  }\n  return offset + 2\n}\n\nfunction objectWriteUInt32 (buf, value, offset, littleEndian) {\n  if (value < 0) value = 0xffffffff + value + 1\n  for (var i = 0, j = Math.min(buf.length - offset, 4); i < j; i++) {\n    buf[offset + i] = (value >>> (littleEndian ? i : 3 - i) * 8) & 0xff\n  }\n}\n\nBuffer.prototype.writeUInt32LE = function writeUInt32LE (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    this[offset + 3] = (value >>> 24)\n    this[offset + 2] = (value >>> 16)\n    this[offset + 1] = (value >>> 8)\n    this[offset] = (value & 0xff)\n  } else {\n    objectWriteUInt32(this, value, offset, true)\n  }\n  return offset + 4\n}\n\nBuffer.prototype.writeUInt32BE = function writeUInt32BE (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    this[offset] = (value >>> 24)\n    this[offset + 1] = (value >>> 16)\n    this[offset + 2] = (value >>> 8)\n    this[offset + 3] = (value & 0xff)\n  } else {\n    objectWriteUInt32(this, value, offset, false)\n  }\n  return offset + 4\n}\n\nBuffer.prototype.writeIntLE = function writeIntLE (value, offset, byteLength, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) {\n    var limit = Math.pow(2, 8 * byteLength - 1)\n\n    checkInt(this, value, offset, byteLength, limit - 1, -limit)\n  }\n\n  var i = 0\n  var mul = 1\n  var sub = value < 0 ? 1 : 0\n  this[offset] = value & 0xFF\n  while (++i < byteLength && (mul *= 0x100)) {\n    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF\n  }\n\n  return offset + byteLength\n}\n\nBuffer.prototype.writeIntBE = function writeIntBE (value, offset, byteLength, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) {\n    var limit = Math.pow(2, 8 * byteLength - 1)\n\n    checkInt(this, value, offset, byteLength, limit - 1, -limit)\n  }\n\n  var i = byteLength - 1\n  var mul = 1\n  var sub = value < 0 ? 1 : 0\n  this[offset + i] = value & 0xFF\n  while (--i >= 0 && (mul *= 0x100)) {\n    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF\n  }\n\n  return offset + byteLength\n}\n\nBuffer.prototype.writeInt8 = function writeInt8 (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 1, 0x7f, -0x80)\n  if (!Buffer.TYPED_ARRAY_SUPPORT) value = Math.floor(value)\n  if (value < 0) value = 0xff + value + 1\n  this[offset] = (value & 0xff)\n  return offset + 1\n}\n\nBuffer.prototype.writeInt16LE = function writeInt16LE (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    this[offset] = (value & 0xff)\n    this[offset + 1] = (value >>> 8)\n  } else {\n    objectWriteUInt16(this, value, offset, true)\n  }\n  return offset + 2\n}\n\nBuffer.prototype.writeInt16BE = function writeInt16BE (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    this[offset] = (value >>> 8)\n    this[offset + 1] = (value & 0xff)\n  } else {\n    objectWriteUInt16(this, value, offset, false)\n  }\n  return offset + 2\n}\n\nBuffer.prototype.writeInt32LE = function writeInt32LE (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    this[offset] = (value & 0xff)\n    this[offset + 1] = (value >>> 8)\n    this[offset + 2] = (value >>> 16)\n    this[offset + 3] = (value >>> 24)\n  } else {\n    objectWriteUInt32(this, value, offset, true)\n  }\n  return offset + 4\n}\n\nBuffer.prototype.writeInt32BE = function writeInt32BE (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)\n  if (value < 0) value = 0xffffffff + value + 1\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    this[offset] = (value >>> 24)\n    this[offset + 1] = (value >>> 16)\n    this[offset + 2] = (value >>> 8)\n    this[offset + 3] = (value & 0xff)\n  } else {\n    objectWriteUInt32(this, value, offset, false)\n  }\n  return offset + 4\n}\n\nfunction checkIEEE754 (buf, value, offset, ext, max, min) {\n  if (value > max || value < min) throw new RangeError('value is out of bounds')\n  if (offset + ext > buf.length) throw new RangeError('index out of range')\n  if (offset < 0) throw new RangeError('index out of range')\n}\n\nfunction writeFloat (buf, value, offset, littleEndian, noAssert) {\n  if (!noAssert) {\n    checkIEEE754(buf, value, offset, 4, 3.4028234663852886e+38, -3.4028234663852886e+38)\n  }\n  ieee754.write(buf, value, offset, littleEndian, 23, 4)\n  return offset + 4\n}\n\nBuffer.prototype.writeFloatLE = function writeFloatLE (value, offset, noAssert) {\n  return writeFloat(this, value, offset, true, noAssert)\n}\n\nBuffer.prototype.writeFloatBE = function writeFloatBE (value, offset, noAssert) {\n  return writeFloat(this, value, offset, false, noAssert)\n}\n\nfunction writeDouble (buf, value, offset, littleEndian, noAssert) {\n  if (!noAssert) {\n    checkIEEE754(buf, value, offset, 8, 1.7976931348623157E+308, -1.7976931348623157E+308)\n  }\n  ieee754.write(buf, value, offset, littleEndian, 52, 8)\n  return offset + 8\n}\n\nBuffer.prototype.writeDoubleLE = function writeDoubleLE (value, offset, noAssert) {\n  return writeDouble(this, value, offset, true, noAssert)\n}\n\nBuffer.prototype.writeDoubleBE = function writeDoubleBE (value, offset, noAssert) {\n  return writeDouble(this, value, offset, false, noAssert)\n}\n\n// copy(targetBuffer, targetStart=0, sourceStart=0, sourceEnd=buffer.length)\nBuffer.prototype.copy = function copy (target, targetStart, start, end) {\n  if (!start) start = 0\n  if (!end && end !== 0) end = this.length\n  if (targetStart >= target.length) targetStart = target.length\n  if (!targetStart) targetStart = 0\n  if (end > 0 && end < start) end = start\n\n  // Copy 0 bytes; we're done\n  if (end === start) return 0\n  if (target.length === 0 || this.length === 0) return 0\n\n  // Fatal error conditions\n  if (targetStart < 0) {\n    throw new RangeError('targetStart out of bounds')\n  }\n  if (start < 0 || start >= this.length) throw new RangeError('sourceStart out of bounds')\n  if (end < 0) throw new RangeError('sourceEnd out of bounds')\n\n  // Are we oob?\n  if (end > this.length) end = this.length\n  if (target.length - targetStart < end - start) {\n    end = target.length - targetStart + start\n  }\n\n  var len = end - start\n  var i\n\n  if (this === target && start < targetStart && targetStart < end) {\n    // descending copy from end\n    for (i = len - 1; i >= 0; i--) {\n      target[i + targetStart] = this[i + start]\n    }\n  } else if (len < 1000 || !Buffer.TYPED_ARRAY_SUPPORT) {\n    // ascending copy from start\n    for (i = 0; i < len; i++) {\n      target[i + targetStart] = this[i + start]\n    }\n  } else {\n    target._set(this.subarray(start, start + len), targetStart)\n  }\n\n  return len\n}\n\n// fill(value, start=0, end=buffer.length)\nBuffer.prototype.fill = function fill (value, start, end) {\n  if (!value) value = 0\n  if (!start) start = 0\n  if (!end) end = this.length\n\n  if (end < start) throw new RangeError('end < start')\n\n  // Fill 0 bytes; we're done\n  if (end === start) return\n  if (this.length === 0) return\n\n  if (start < 0 || start >= this.length) throw new RangeError('start out of bounds')\n  if (end < 0 || end > this.length) throw new RangeError('end out of bounds')\n\n  var i\n  if (typeof value === 'number') {\n    for (i = start; i < end; i++) {\n      this[i] = value\n    }\n  } else {\n    var bytes = utf8ToBytes(value.toString())\n    var len = bytes.length\n    for (i = start; i < end; i++) {\n      this[i] = bytes[i % len]\n    }\n  }\n\n  return this\n}\n\n/**\n * Creates a new `ArrayBuffer` with the *copied* memory of the buffer instance.\n * Added in Node 0.12. Only available in browsers that support ArrayBuffer.\n */\nBuffer.prototype.toArrayBuffer = function toArrayBuffer () {\n  if (typeof Uint8Array !== 'undefined') {\n    if (Buffer.TYPED_ARRAY_SUPPORT) {\n      return (new Buffer(this)).buffer\n    } else {\n      var buf = new Uint8Array(this.length)\n      for (var i = 0, len = buf.length; i < len; i += 1) {\n        buf[i] = this[i]\n      }\n      return buf.buffer\n    }\n  } else {\n    throw new TypeError('Buffer.toArrayBuffer not supported in this browser')\n  }\n}\n\n// HELPER FUNCTIONS\n// ================\n\nvar BP = Buffer.prototype\n\n/**\n * Augment a Uint8Array *instance* (not the Uint8Array class!) with Buffer methods\n */\nBuffer._augment = function _augment (arr) {\n  arr.constructor = Buffer\n  arr._isBuffer = true\n\n  // save reference to original Uint8Array set method before overwriting\n  arr._set = arr.set\n\n  // deprecated\n  arr.get = BP.get\n  arr.set = BP.set\n\n  arr.write = BP.write\n  arr.toString = BP.toString\n  arr.toLocaleString = BP.toString\n  arr.toJSON = BP.toJSON\n  arr.equals = BP.equals\n  arr.compare = BP.compare\n  arr.indexOf = BP.indexOf\n  arr.copy = BP.copy\n  arr.slice = BP.slice\n  arr.readUIntLE = BP.readUIntLE\n  arr.readUIntBE = BP.readUIntBE\n  arr.readUInt8 = BP.readUInt8\n  arr.readUInt16LE = BP.readUInt16LE\n  arr.readUInt16BE = BP.readUInt16BE\n  arr.readUInt32LE = BP.readUInt32LE\n  arr.readUInt32BE = BP.readUInt32BE\n  arr.readIntLE = BP.readIntLE\n  arr.readIntBE = BP.readIntBE\n  arr.readInt8 = BP.readInt8\n  arr.readInt16LE = BP.readInt16LE\n  arr.readInt16BE = BP.readInt16BE\n  arr.readInt32LE = BP.readInt32LE\n  arr.readInt32BE = BP.readInt32BE\n  arr.readFloatLE = BP.readFloatLE\n  arr.readFloatBE = BP.readFloatBE\n  arr.readDoubleLE = BP.readDoubleLE\n  arr.readDoubleBE = BP.readDoubleBE\n  arr.writeUInt8 = BP.writeUInt8\n  arr.writeUIntLE = BP.writeUIntLE\n  arr.writeUIntBE = BP.writeUIntBE\n  arr.writeUInt16LE = BP.writeUInt16LE\n  arr.writeUInt16BE = BP.writeUInt16BE\n  arr.writeUInt32LE = BP.writeUInt32LE\n  arr.writeUInt32BE = BP.writeUInt32BE\n  arr.writeIntLE = BP.writeIntLE\n  arr.writeIntBE = BP.writeIntBE\n  arr.writeInt8 = BP.writeInt8\n  arr.writeInt16LE = BP.writeInt16LE\n  arr.writeInt16BE = BP.writeInt16BE\n  arr.writeInt32LE = BP.writeInt32LE\n  arr.writeInt32BE = BP.writeInt32BE\n  arr.writeFloatLE = BP.writeFloatLE\n  arr.writeFloatBE = BP.writeFloatBE\n  arr.writeDoubleLE = BP.writeDoubleLE\n  arr.writeDoubleBE = BP.writeDoubleBE\n  arr.fill = BP.fill\n  arr.inspect = BP.inspect\n  arr.toArrayBuffer = BP.toArrayBuffer\n\n  return arr\n}\n\nvar INVALID_BASE64_RE = /[^+\\/0-9A-Za-z-_]/g\n\nfunction base64clean (str) {\n  // Node strips out invalid characters like \\n and \\t from the string, base64-js does not\n  str = stringtrim(str).replace(INVALID_BASE64_RE, '')\n  // Node converts strings with length < 2 to ''\n  if (str.length < 2) return ''\n  // Node allows for non-padded base64 strings (missing trailing ===), base64-js does not\n  while (str.length % 4 !== 0) {\n    str = str + '='\n  }\n  return str\n}\n\nfunction stringtrim (str) {\n  if (str.trim) return str.trim()\n  return str.replace(/^\\s+|\\s+$/g, '')\n}\n\nfunction toHex (n) {\n  if (n < 16) return '0' + n.toString(16)\n  return n.toString(16)\n}\n\nfunction utf8ToBytes (string, units) {\n  units = units || Infinity\n  var codePoint\n  var length = string.length\n  var leadSurrogate = null\n  var bytes = []\n\n  for (var i = 0; i < length; i++) {\n    codePoint = string.charCodeAt(i)\n\n    // is surrogate component\n    if (codePoint > 0xD7FF && codePoint < 0xE000) {\n      // last char was a lead\n      if (!leadSurrogate) {\n        // no lead yet\n        if (codePoint > 0xDBFF) {\n          // unexpected trail\n          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)\n          continue\n        } else if (i + 1 === length) {\n          // unpaired lead\n          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)\n          continue\n        }\n\n        // valid lead\n        leadSurrogate = codePoint\n\n        continue\n      }\n\n      // 2 leads in a row\n      if (codePoint < 0xDC00) {\n        if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)\n        leadSurrogate = codePoint\n        continue\n      }\n\n      // valid surrogate pair\n      codePoint = (leadSurrogate - 0xD800 << 10 | codePoint - 0xDC00) + 0x10000\n    } else if (leadSurrogate) {\n      // valid bmp char, but last char was a lead\n      if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)\n    }\n\n    leadSurrogate = null\n\n    // encode utf8\n    if (codePoint < 0x80) {\n      if ((units -= 1) < 0) break\n      bytes.push(codePoint)\n    } else if (codePoint < 0x800) {\n      if ((units -= 2) < 0) break\n      bytes.push(\n        codePoint >> 0x6 | 0xC0,\n        codePoint & 0x3F | 0x80\n      )\n    } else if (codePoint < 0x10000) {\n      if ((units -= 3) < 0) break\n      bytes.push(\n        codePoint >> 0xC | 0xE0,\n        codePoint >> 0x6 & 0x3F | 0x80,\n        codePoint & 0x3F | 0x80\n      )\n    } else if (codePoint < 0x110000) {\n      if ((units -= 4) < 0) break\n      bytes.push(\n        codePoint >> 0x12 | 0xF0,\n        codePoint >> 0xC & 0x3F | 0x80,\n        codePoint >> 0x6 & 0x3F | 0x80,\n        codePoint & 0x3F | 0x80\n      )\n    } else {\n      throw new Error('Invalid code point')\n    }\n  }\n\n  return bytes\n}\n\nfunction asciiToBytes (str) {\n  var byteArray = []\n  for (var i = 0; i < str.length; i++) {\n    // Node's code seems to be doing this and not & 0x7F..\n    byteArray.push(str.charCodeAt(i) & 0xFF)\n  }\n  return byteArray\n}\n\nfunction utf16leToBytes (str, units) {\n  var c, hi, lo\n  var byteArray = []\n  for (var i = 0; i < str.length; i++) {\n    if ((units -= 2) < 0) break\n\n    c = str.charCodeAt(i)\n    hi = c >> 8\n    lo = c % 256\n    byteArray.push(lo)\n    byteArray.push(hi)\n  }\n\n  return byteArray\n}\n\nfunction base64ToBytes (str) {\n  return base64.toByteArray(base64clean(str))\n}\n\nfunction blitBuffer (src, dst, offset, length) {\n  for (var i = 0; i < length; i++) {\n    if ((i + offset >= dst.length) || (i >= src.length)) break\n    dst[i + offset] = src[i]\n  }\n  return i\n}\n","var lookup = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';\n\n;(function (exports) {\n\t'use strict';\n\n  var Arr = (typeof Uint8Array !== 'undefined')\n    ? Uint8Array\n    : Array\n\n\tvar PLUS   = '+'.charCodeAt(0)\n\tvar SLASH  = '/'.charCodeAt(0)\n\tvar NUMBER = '0'.charCodeAt(0)\n\tvar LOWER  = 'a'.charCodeAt(0)\n\tvar UPPER  = 'A'.charCodeAt(0)\n\tvar PLUS_URL_SAFE = '-'.charCodeAt(0)\n\tvar SLASH_URL_SAFE = '_'.charCodeAt(0)\n\n\tfunction decode (elt) {\n\t\tvar code = elt.charCodeAt(0)\n\t\tif (code === PLUS ||\n\t\t    code === PLUS_URL_SAFE)\n\t\t\treturn 62 // '+'\n\t\tif (code === SLASH ||\n\t\t    code === SLASH_URL_SAFE)\n\t\t\treturn 63 // '/'\n\t\tif (code < NUMBER)\n\t\t\treturn -1 //no match\n\t\tif (code < NUMBER + 10)\n\t\t\treturn code - NUMBER + 26 + 26\n\t\tif (code < UPPER + 26)\n\t\t\treturn code - UPPER\n\t\tif (code < LOWER + 26)\n\t\t\treturn code - LOWER + 26\n\t}\n\n\tfunction b64ToByteArray (b64) {\n\t\tvar i, j, l, tmp, placeHolders, arr\n\n\t\tif (b64.length % 4 > 0) {\n\t\t\tthrow new Error('Invalid string. Length must be a multiple of 4')\n\t\t}\n\n\t\t// the number of equal signs (place holders)\n\t\t// if there are two placeholders, than the two characters before it\n\t\t// represent one byte\n\t\t// if there is only one, then the three characters before it represent 2 bytes\n\t\t// this is just a cheap hack to not do indexOf twice\n\t\tvar len = b64.length\n\t\tplaceHolders = '=' === b64.charAt(len - 2) ? 2 : '=' === b64.charAt(len - 1) ? 1 : 0\n\n\t\t// base64 is 4/3 + up to two characters of the original data\n\t\tarr = new Arr(b64.length * 3 / 4 - placeHolders)\n\n\t\t// if there are placeholders, only get up to the last complete 4 chars\n\t\tl = placeHolders > 0 ? b64.length - 4 : b64.length\n\n\t\tvar L = 0\n\n\t\tfunction push (v) {\n\t\t\tarr[L++] = v\n\t\t}\n\n\t\tfor (i = 0, j = 0; i < l; i += 4, j += 3) {\n\t\t\ttmp = (decode(b64.charAt(i)) << 18) | (decode(b64.charAt(i + 1)) << 12) | (decode(b64.charAt(i + 2)) << 6) | decode(b64.charAt(i + 3))\n\t\t\tpush((tmp & 0xFF0000) >> 16)\n\t\t\tpush((tmp & 0xFF00) >> 8)\n\t\t\tpush(tmp & 0xFF)\n\t\t}\n\n\t\tif (placeHolders === 2) {\n\t\t\ttmp = (decode(b64.charAt(i)) << 2) | (decode(b64.charAt(i + 1)) >> 4)\n\t\t\tpush(tmp & 0xFF)\n\t\t} else if (placeHolders === 1) {\n\t\t\ttmp = (decode(b64.charAt(i)) << 10) | (decode(b64.charAt(i + 1)) << 4) | (decode(b64.charAt(i + 2)) >> 2)\n\t\t\tpush((tmp >> 8) & 0xFF)\n\t\t\tpush(tmp & 0xFF)\n\t\t}\n\n\t\treturn arr\n\t}\n\n\tfunction uint8ToBase64 (uint8) {\n\t\tvar i,\n\t\t\textraBytes = uint8.length % 3, // if we have 1 byte left, pad 2 bytes\n\t\t\toutput = \"\",\n\t\t\ttemp, length\n\n\t\tfunction encode (num) {\n\t\t\treturn lookup.charAt(num)\n\t\t}\n\n\t\tfunction tripletToBase64 (num) {\n\t\t\treturn encode(num >> 18 & 0x3F) + encode(num >> 12 & 0x3F) + encode(num >> 6 & 0x3F) + encode(num & 0x3F)\n\t\t}\n\n\t\t// go through the array every three bytes, we'll deal with trailing stuff later\n\t\tfor (i = 0, length = uint8.length - extraBytes; i < length; i += 3) {\n\t\t\ttemp = (uint8[i] << 16) + (uint8[i + 1] << 8) + (uint8[i + 2])\n\t\t\toutput += tripletToBase64(temp)\n\t\t}\n\n\t\t// pad the end with zeros, but make sure to not forget the extra bytes\n\t\tswitch (extraBytes) {\n\t\t\tcase 1:\n\t\t\t\ttemp = uint8[uint8.length - 1]\n\t\t\t\toutput += encode(temp >> 2)\n\t\t\t\toutput += encode((temp << 4) & 0x3F)\n\t\t\t\toutput += '=='\n\t\t\t\tbreak\n\t\t\tcase 2:\n\t\t\t\ttemp = (uint8[uint8.length - 2] << 8) + (uint8[uint8.length - 1])\n\t\t\t\toutput += encode(temp >> 10)\n\t\t\t\toutput += encode((temp >> 4) & 0x3F)\n\t\t\t\toutput += encode((temp << 2) & 0x3F)\n\t\t\t\toutput += '='\n\t\t\t\tbreak\n\t\t}\n\n\t\treturn output\n\t}\n\n\texports.toByteArray = b64ToByteArray\n\texports.fromByteArray = uint8ToBase64\n}(typeof exports === 'undefined' ? (this.base64js = {}) : exports))\n","exports.read = function (buffer, offset, isLE, mLen, nBytes) {\n  var e, m\n  var eLen = nBytes * 8 - mLen - 1\n  var eMax = (1 << eLen) - 1\n  var eBias = eMax >> 1\n  var nBits = -7\n  var i = isLE ? (nBytes - 1) : 0\n  var d = isLE ? -1 : 1\n  var s = buffer[offset + i]\n\n  i += d\n\n  e = s & ((1 << (-nBits)) - 1)\n  s >>= (-nBits)\n  nBits += eLen\n  for (; nBits > 0; e = e * 256 + buffer[offset + i], i += d, nBits -= 8) {}\n\n  m = e & ((1 << (-nBits)) - 1)\n  e >>= (-nBits)\n  nBits += mLen\n  for (; nBits > 0; m = m * 256 + buffer[offset + i], i += d, nBits -= 8) {}\n\n  if (e === 0) {\n    e = 1 - eBias\n  } else if (e === eMax) {\n    return m ? NaN : ((s ? -1 : 1) * Infinity)\n  } else {\n    m = m + Math.pow(2, mLen)\n    e = e - eBias\n  }\n  return (s ? -1 : 1) * m * Math.pow(2, e - mLen)\n}\n\nexports.write = function (buffer, value, offset, isLE, mLen, nBytes) {\n  var e, m, c\n  var eLen = nBytes * 8 - mLen - 1\n  var eMax = (1 << eLen) - 1\n  var eBias = eMax >> 1\n  var rt = (mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0)\n  var i = isLE ? 0 : (nBytes - 1)\n  var d = isLE ? 1 : -1\n  var s = value < 0 || (value === 0 && 1 / value < 0) ? 1 : 0\n\n  value = Math.abs(value)\n\n  if (isNaN(value) || value === Infinity) {\n    m = isNaN(value) ? 1 : 0\n    e = eMax\n  } else {\n    e = Math.floor(Math.log(value) / Math.LN2)\n    if (value * (c = Math.pow(2, -e)) < 1) {\n      e--\n      c *= 2\n    }\n    if (e + eBias >= 1) {\n      value += rt / c\n    } else {\n      value += rt * Math.pow(2, 1 - eBias)\n    }\n    if (value * c >= 2) {\n      e++\n      c /= 2\n    }\n\n    if (e + eBias >= eMax) {\n      m = 0\n      e = eMax\n    } else if (e + eBias >= 1) {\n      m = (value * c - 1) * Math.pow(2, mLen)\n      e = e + eBias\n    } else {\n      m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen)\n      e = 0\n    }\n  }\n\n  for (; mLen >= 8; buffer[offset + i] = m & 0xff, i += d, m /= 256, mLen -= 8) {}\n\n  e = (e << mLen) | m\n  eLen += mLen\n  for (; eLen > 0; buffer[offset + i] = e & 0xff, i += d, e /= 256, eLen -= 8) {}\n\n  buffer[offset + i - d] |= s * 128\n}\n","var toString = {}.toString;\n\nmodule.exports = Array.isArray || function (arr) {\n  return toString.call(arr) == '[object Array]';\n};\n","// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\nfunction EventEmitter() {\n  this._events = this._events || {};\n  this._maxListeners = this._maxListeners || undefined;\n}\nmodule.exports = EventEmitter;\n\n// Backwards-compat with node 0.10.x\nEventEmitter.EventEmitter = EventEmitter;\n\nEventEmitter.prototype._events = undefined;\nEventEmitter.prototype._maxListeners = undefined;\n\n// By default EventEmitters will print a warning if more than 10 listeners are\n// added to it. This is a useful default which helps finding memory leaks.\nEventEmitter.defaultMaxListeners = 10;\n\n// Obviously not all Emitters should be limited to 10. This function allows\n// that to be increased. Set to zero for unlimited.\nEventEmitter.prototype.setMaxListeners = function(n) {\n  if (!isNumber(n) || n < 0 || isNaN(n))\n    throw TypeError('n must be a positive number');\n  this._maxListeners = n;\n  return this;\n};\n\nEventEmitter.prototype.emit = function(type) {\n  var er, handler, len, args, i, listeners;\n\n  if (!this._events)\n    this._events = {};\n\n  // If there is no 'error' event listener then throw.\n  if (type === 'error') {\n    if (!this._events.error ||\n        (isObject(this._events.error) && !this._events.error.length)) {\n      er = arguments[1];\n      if (er instanceof Error) {\n        throw er; // Unhandled 'error' event\n      }\n      throw TypeError('Uncaught, unspecified \"error\" event.');\n    }\n  }\n\n  handler = this._events[type];\n\n  if (isUndefined(handler))\n    return false;\n\n  if (isFunction(handler)) {\n    switch (arguments.length) {\n      // fast cases\n      case 1:\n        handler.call(this);\n        break;\n      case 2:\n        handler.call(this, arguments[1]);\n        break;\n      case 3:\n        handler.call(this, arguments[1], arguments[2]);\n        break;\n      // slower\n      default:\n        args = Array.prototype.slice.call(arguments, 1);\n        handler.apply(this, args);\n    }\n  } else if (isObject(handler)) {\n    args = Array.prototype.slice.call(arguments, 1);\n    listeners = handler.slice();\n    len = listeners.length;\n    for (i = 0; i < len; i++)\n      listeners[i].apply(this, args);\n  }\n\n  return true;\n};\n\nEventEmitter.prototype.addListener = function(type, listener) {\n  var m;\n\n  if (!isFunction(listener))\n    throw TypeError('listener must be a function');\n\n  if (!this._events)\n    this._events = {};\n\n  // To avoid recursion in the case that type === \"newListener\"! Before\n  // adding it to the listeners, first emit \"newListener\".\n  if (this._events.newListener)\n    this.emit('newListener', type,\n              isFunction(listener.listener) ?\n              listener.listener : listener);\n\n  if (!this._events[type])\n    // Optimize the case of one listener. Don't need the extra array object.\n    this._events[type] = listener;\n  else if (isObject(this._events[type]))\n    // If we've already got an array, just append.\n    this._events[type].push(listener);\n  else\n    // Adding the second element, need to change to array.\n    this._events[type] = [this._events[type], listener];\n\n  // Check for listener leak\n  if (isObject(this._events[type]) && !this._events[type].warned) {\n    if (!isUndefined(this._maxListeners)) {\n      m = this._maxListeners;\n    } else {\n      m = EventEmitter.defaultMaxListeners;\n    }\n\n    if (m && m > 0 && this._events[type].length > m) {\n      this._events[type].warned = true;\n      console.error('(node) warning: possible EventEmitter memory ' +\n                    'leak detected. %d listeners added. ' +\n                    'Use emitter.setMaxListeners() to increase limit.',\n                    this._events[type].length);\n      if (typeof console.trace === 'function') {\n        // not supported in IE 10\n        console.trace();\n      }\n    }\n  }\n\n  return this;\n};\n\nEventEmitter.prototype.on = EventEmitter.prototype.addListener;\n\nEventEmitter.prototype.once = function(type, listener) {\n  if (!isFunction(listener))\n    throw TypeError('listener must be a function');\n\n  var fired = false;\n\n  function g() {\n    this.removeListener(type, g);\n\n    if (!fired) {\n      fired = true;\n      listener.apply(this, arguments);\n    }\n  }\n\n  g.listener = listener;\n  this.on(type, g);\n\n  return this;\n};\n\n// emits a 'removeListener' event iff the listener was removed\nEventEmitter.prototype.removeListener = function(type, listener) {\n  var list, position, length, i;\n\n  if (!isFunction(listener))\n    throw TypeError('listener must be a function');\n\n  if (!this._events || !this._events[type])\n    return this;\n\n  list = this._events[type];\n  length = list.length;\n  position = -1;\n\n  if (list === listener ||\n      (isFunction(list.listener) && list.listener === listener)) {\n    delete this._events[type];\n    if (this._events.removeListener)\n      this.emit('removeListener', type, listener);\n\n  } else if (isObject(list)) {\n    for (i = length; i-- > 0;) {\n      if (list[i] === listener ||\n          (list[i].listener && list[i].listener === listener)) {\n        position = i;\n        break;\n      }\n    }\n\n    if (position < 0)\n      return this;\n\n    if (list.length === 1) {\n      list.length = 0;\n      delete this._events[type];\n    } else {\n      list.splice(position, 1);\n    }\n\n    if (this._events.removeListener)\n      this.emit('removeListener', type, listener);\n  }\n\n  return this;\n};\n\nEventEmitter.prototype.removeAllListeners = function(type) {\n  var key, listeners;\n\n  if (!this._events)\n    return this;\n\n  // not listening for removeListener, no need to emit\n  if (!this._events.removeListener) {\n    if (arguments.length === 0)\n      this._events = {};\n    else if (this._events[type])\n      delete this._events[type];\n    return this;\n  }\n\n  // emit removeListener for all listeners on all events\n  if (arguments.length === 0) {\n    for (key in this._events) {\n      if (key === 'removeListener') continue;\n      this.removeAllListeners(key);\n    }\n    this.removeAllListeners('removeListener');\n    this._events = {};\n    return this;\n  }\n\n  listeners = this._events[type];\n\n  if (isFunction(listeners)) {\n    this.removeListener(type, listeners);\n  } else if (listeners) {\n    // LIFO order\n    while (listeners.length)\n      this.removeListener(type, listeners[listeners.length - 1]);\n  }\n  delete this._events[type];\n\n  return this;\n};\n\nEventEmitter.prototype.listeners = function(type) {\n  var ret;\n  if (!this._events || !this._events[type])\n    ret = [];\n  else if (isFunction(this._events[type]))\n    ret = [this._events[type]];\n  else\n    ret = this._events[type].slice();\n  return ret;\n};\n\nEventEmitter.prototype.listenerCount = function(type) {\n  if (this._events) {\n    var evlistener = this._events[type];\n\n    if (isFunction(evlistener))\n      return 1;\n    else if (evlistener)\n      return evlistener.length;\n  }\n  return 0;\n};\n\nEventEmitter.listenerCount = function(emitter, type) {\n  return emitter.listenerCount(type);\n};\n\nfunction isFunction(arg) {\n  return typeof arg === 'function';\n}\n\nfunction isNumber(arg) {\n  return typeof arg === 'number';\n}\n\nfunction isObject(arg) {\n  return typeof arg === 'object' && arg !== null;\n}\n\nfunction isUndefined(arg) {\n  return arg === void 0;\n}\n","var http = require('http');\n\nvar https = module.exports;\n\nfor (var key in http) {\n    if (http.hasOwnProperty(key)) https[key] = http[key];\n};\n\nhttps.request = function (params, cb) {\n    if (!params) params = {};\n    params.scheme = 'https';\n    params.protocol = 'https:';\n    return http.request.call(this, params, cb);\n}\n","if (typeof Object.create === 'function') {\n  // implementation from standard node.js 'util' module\n  module.exports = function inherits(ctor, superCtor) {\n    ctor.super_ = superCtor\n    ctor.prototype = Object.create(superCtor.prototype, {\n      constructor: {\n        value: ctor,\n        enumerable: false,\n        writable: true,\n        configurable: true\n      }\n    });\n  };\n} else {\n  // old school shim for old browsers\n  module.exports = function inherits(ctor, superCtor) {\n    ctor.super_ = superCtor\n    var TempCtor = function () {}\n    TempCtor.prototype = superCtor.prototype\n    ctor.prototype = new TempCtor()\n    ctor.prototype.constructor = ctor\n  }\n}\n","/**\n * Determine if an object is Buffer\n *\n * Author:   Feross Aboukhadijeh <feross@feross.org> <http://feross.org>\n * License:  MIT\n *\n * `npm install is-buffer`\n */\n\nmodule.exports = function (obj) {\n  return !!(obj != null &&\n    (obj._isBuffer || // For Safari 5-7 (missing Object.prototype.constructor)\n      (obj.constructor &&\n      typeof obj.constructor.isBuffer === 'function' &&\n      obj.constructor.isBuffer(obj))\n    ))\n}\n","module.exports = Array.isArray || function (arr) {\n  return Object.prototype.toString.call(arr) == '[object Array]';\n};\n","// shim for using process in browser\n\nvar process = module.exports = {};\nvar queue = [];\nvar draining = false;\nvar currentQueue;\nvar queueIndex = -1;\n\nfunction cleanUpNextTick() {\n    draining = false;\n    if (currentQueue.length) {\n        queue = currentQueue.concat(queue);\n    } else {\n        queueIndex = -1;\n    }\n    if (queue.length) {\n        drainQueue();\n    }\n}\n\nfunction drainQueue() {\n    if (draining) {\n        return;\n    }\n    var timeout = setTimeout(cleanUpNextTick);\n    draining = true;\n\n    var len = queue.length;\n    while(len) {\n        currentQueue = queue;\n        queue = [];\n        while (++queueIndex < len) {\n            if (currentQueue) {\n                currentQueue[queueIndex].run();\n            }\n        }\n        queueIndex = -1;\n        len = queue.length;\n    }\n    currentQueue = null;\n    draining = false;\n    clearTimeout(timeout);\n}\n\nprocess.nextTick = function (fun) {\n    var args = new Array(arguments.length - 1);\n    if (arguments.length > 1) {\n        for (var i = 1; i < arguments.length; i++) {\n            args[i - 1] = arguments[i];\n        }\n    }\n    queue.push(new Item(fun, args));\n    if (queue.length === 1 && !draining) {\n        setTimeout(drainQueue, 0);\n    }\n};\n\n// v8 likes predictible objects\nfunction Item(fun, array) {\n    this.fun = fun;\n    this.array = array;\n}\nItem.prototype.run = function () {\n    this.fun.apply(null, this.array);\n};\nprocess.title = 'browser';\nprocess.browser = true;\nprocess.env = {};\nprocess.argv = [];\nprocess.version = ''; // empty string to avoid regexp issues\nprocess.versions = {};\n\nfunction noop() {}\n\nprocess.on = noop;\nprocess.addListener = noop;\nprocess.once = noop;\nprocess.off = noop;\nprocess.removeListener = noop;\nprocess.removeAllListeners = noop;\nprocess.emit = noop;\n\nprocess.binding = function (name) {\n    throw new Error('process.binding is not supported');\n};\n\nprocess.cwd = function () { return '/' };\nprocess.chdir = function (dir) {\n    throw new Error('process.chdir is not supported');\n};\nprocess.umask = function() { return 0; };\n","/*! https://mths.be/punycode v1.4.0 by @mathias */\n;(function(root) {\n\n\t/** Detect free variables */\n\tvar freeExports = typeof exports == 'object' && exports &&\n\t\t!exports.nodeType && exports;\n\tvar freeModule = typeof module == 'object' && module &&\n\t\t!module.nodeType && module;\n\tvar freeGlobal = typeof global == 'object' && global;\n\tif (\n\t\tfreeGlobal.global === freeGlobal ||\n\t\tfreeGlobal.window === freeGlobal ||\n\t\tfreeGlobal.self === freeGlobal\n\t) {\n\t\troot = freeGlobal;\n\t}\n\n\t/**\n\t * The `punycode` object.\n\t * @name punycode\n\t * @type Object\n\t */\n\tvar punycode,\n\n\t/** Highest positive signed 32-bit float value */\n\tmaxInt = 2147483647, // aka. 0x7FFFFFFF or 2^31-1\n\n\t/** Bootstring parameters */\n\tbase = 36,\n\ttMin = 1,\n\ttMax = 26,\n\tskew = 38,\n\tdamp = 700,\n\tinitialBias = 72,\n\tinitialN = 128, // 0x80\n\tdelimiter = '-', // '\\x2D'\n\n\t/** Regular expressions */\n\tregexPunycode = /^xn--/,\n\tregexNonASCII = /[^\\x20-\\x7E]/, // unprintable ASCII chars + non-ASCII chars\n\tregexSeparators = /[\\x2E\\u3002\\uFF0E\\uFF61]/g, // RFC 3490 separators\n\n\t/** Error messages */\n\terrors = {\n\t\t'overflow': 'Overflow: input needs wider integers to process',\n\t\t'not-basic': 'Illegal input >= 0x80 (not a basic code point)',\n\t\t'invalid-input': 'Invalid input'\n\t},\n\n\t/** Convenience shortcuts */\n\tbaseMinusTMin = base - tMin,\n\tfloor = Math.floor,\n\tstringFromCharCode = String.fromCharCode,\n\n\t/** Temporary variable */\n\tkey;\n\n\t/*--------------------------------------------------------------------------*/\n\n\t/**\n\t * A generic error utility function.\n\t * @private\n\t * @param {String} type The error type.\n\t * @returns {Error} Throws a `RangeError` with the applicable error message.\n\t */\n\tfunction error(type) {\n\t\tthrow new RangeError(errors[type]);\n\t}\n\n\t/**\n\t * A generic `Array#map` utility function.\n\t * @private\n\t * @param {Array} array The array to iterate over.\n\t * @param {Function} callback The function that gets called for every array\n\t * item.\n\t * @returns {Array} A new array of values returned by the callback function.\n\t */\n\tfunction map(array, fn) {\n\t\tvar length = array.length;\n\t\tvar result = [];\n\t\twhile (length--) {\n\t\t\tresult[length] = fn(array[length]);\n\t\t}\n\t\treturn result;\n\t}\n\n\t/**\n\t * A simple `Array#map`-like wrapper to work with domain name strings or email\n\t * addresses.\n\t * @private\n\t * @param {String} domain The domain name or email address.\n\t * @param {Function} callback The function that gets called for every\n\t * character.\n\t * @returns {Array} A new string of characters returned by the callback\n\t * function.\n\t */\n\tfunction mapDomain(string, fn) {\n\t\tvar parts = string.split('@');\n\t\tvar result = '';\n\t\tif (parts.length > 1) {\n\t\t\t// In email addresses, only the domain name should be punycoded. Leave\n\t\t\t// the local part (i.e. everything up to `@`) intact.\n\t\t\tresult = parts[0] + '@';\n\t\t\tstring = parts[1];\n\t\t}\n\t\t// Avoid `split(regex)` for IE8 compatibility. See #17.\n\t\tstring = string.replace(regexSeparators, '\\x2E');\n\t\tvar labels = string.split('.');\n\t\tvar encoded = map(labels, fn).join('.');\n\t\treturn result + encoded;\n\t}\n\n\t/**\n\t * Creates an array containing the numeric code points of each Unicode\n\t * character in the string. While JavaScript uses UCS-2 internally,\n\t * this function will convert a pair of surrogate halves (each of which\n\t * UCS-2 exposes as separate characters) into a single code point,\n\t * matching UTF-16.\n\t * @see `punycode.ucs2.encode`\n\t * @see <https://mathiasbynens.be/notes/javascript-encoding>\n\t * @memberOf punycode.ucs2\n\t * @name decode\n\t * @param {String} string The Unicode input string (UCS-2).\n\t * @returns {Array} The new array of code points.\n\t */\n\tfunction ucs2decode(string) {\n\t\tvar output = [],\n\t\t    counter = 0,\n\t\t    length = string.length,\n\t\t    value,\n\t\t    extra;\n\t\twhile (counter < length) {\n\t\t\tvalue = string.charCodeAt(counter++);\n\t\t\tif (value >= 0xD800 && value <= 0xDBFF && counter < length) {\n\t\t\t\t// high surrogate, and there is a next character\n\t\t\t\textra = string.charCodeAt(counter++);\n\t\t\t\tif ((extra & 0xFC00) == 0xDC00) { // low surrogate\n\t\t\t\t\toutput.push(((value & 0x3FF) << 10) + (extra & 0x3FF) + 0x10000);\n\t\t\t\t} else {\n\t\t\t\t\t// unmatched surrogate; only append this code unit, in case the next\n\t\t\t\t\t// code unit is the high surrogate of a surrogate pair\n\t\t\t\t\toutput.push(value);\n\t\t\t\t\tcounter--;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\toutput.push(value);\n\t\t\t}\n\t\t}\n\t\treturn output;\n\t}\n\n\t/**\n\t * Creates a string based on an array of numeric code points.\n\t * @see `punycode.ucs2.decode`\n\t * @memberOf punycode.ucs2\n\t * @name encode\n\t * @param {Array} codePoints The array of numeric code points.\n\t * @returns {String} The new Unicode string (UCS-2).\n\t */\n\tfunction ucs2encode(array) {\n\t\treturn map(array, function(value) {\n\t\t\tvar output = '';\n\t\t\tif (value > 0xFFFF) {\n\t\t\t\tvalue -= 0x10000;\n\t\t\t\toutput += stringFromCharCode(value >>> 10 & 0x3FF | 0xD800);\n\t\t\t\tvalue = 0xDC00 | value & 0x3FF;\n\t\t\t}\n\t\t\toutput += stringFromCharCode(value);\n\t\t\treturn output;\n\t\t}).join('');\n\t}\n\n\t/**\n\t * Converts a basic code point into a digit/integer.\n\t * @see `digitToBasic()`\n\t * @private\n\t * @param {Number} codePoint The basic numeric code point value.\n\t * @returns {Number} The numeric value of a basic code point (for use in\n\t * representing integers) in the range `0` to `base - 1`, or `base` if\n\t * the code point does not represent a value.\n\t */\n\tfunction basicToDigit(codePoint) {\n\t\tif (codePoint - 48 < 10) {\n\t\t\treturn codePoint - 22;\n\t\t}\n\t\tif (codePoint - 65 < 26) {\n\t\t\treturn codePoint - 65;\n\t\t}\n\t\tif (codePoint - 97 < 26) {\n\t\t\treturn codePoint - 97;\n\t\t}\n\t\treturn base;\n\t}\n\n\t/**\n\t * Converts a digit/integer into a basic code point.\n\t * @see `basicToDigit()`\n\t * @private\n\t * @param {Number} digit The numeric value of a basic code point.\n\t * @returns {Number} The basic code point whose value (when used for\n\t * representing integers) is `digit`, which needs to be in the range\n\t * `0` to `base - 1`. If `flag` is non-zero, the uppercase form is\n\t * used; else, the lowercase form is used. The behavior is undefined\n\t * if `flag` is non-zero and `digit` has no uppercase form.\n\t */\n\tfunction digitToBasic(digit, flag) {\n\t\t//  0..25 map to ASCII a..z or A..Z\n\t\t// 26..35 map to ASCII 0..9\n\t\treturn digit + 22 + 75 * (digit < 26) - ((flag != 0) << 5);\n\t}\n\n\t/**\n\t * Bias adaptation function as per section 3.4 of RFC 3492.\n\t * https://tools.ietf.org/html/rfc3492#section-3.4\n\t * @private\n\t */\n\tfunction adapt(delta, numPoints, firstTime) {\n\t\tvar k = 0;\n\t\tdelta = firstTime ? floor(delta / damp) : delta >> 1;\n\t\tdelta += floor(delta / numPoints);\n\t\tfor (/* no initialization */; delta > baseMinusTMin * tMax >> 1; k += base) {\n\t\t\tdelta = floor(delta / baseMinusTMin);\n\t\t}\n\t\treturn floor(k + (baseMinusTMin + 1) * delta / (delta + skew));\n\t}\n\n\t/**\n\t * Converts a Punycode string of ASCII-only symbols to a string of Unicode\n\t * symbols.\n\t * @memberOf punycode\n\t * @param {String} input The Punycode string of ASCII-only symbols.\n\t * @returns {String} The resulting string of Unicode symbols.\n\t */\n\tfunction decode(input) {\n\t\t// Don't use UCS-2\n\t\tvar output = [],\n\t\t    inputLength = input.length,\n\t\t    out,\n\t\t    i = 0,\n\t\t    n = initialN,\n\t\t    bias = initialBias,\n\t\t    basic,\n\t\t    j,\n\t\t    index,\n\t\t    oldi,\n\t\t    w,\n\t\t    k,\n\t\t    digit,\n\t\t    t,\n\t\t    /** Cached calculation results */\n\t\t    baseMinusT;\n\n\t\t// Handle the basic code points: let `basic` be the number of input code\n\t\t// points before the last delimiter, or `0` if there is none, then copy\n\t\t// the first basic code points to the output.\n\n\t\tbasic = input.lastIndexOf(delimiter);\n\t\tif (basic < 0) {\n\t\t\tbasic = 0;\n\t\t}\n\n\t\tfor (j = 0; j < basic; ++j) {\n\t\t\t// if it's not a basic code point\n\t\t\tif (input.charCodeAt(j) >= 0x80) {\n\t\t\t\terror('not-basic');\n\t\t\t}\n\t\t\toutput.push(input.charCodeAt(j));\n\t\t}\n\n\t\t// Main decoding loop: start just after the last delimiter if any basic code\n\t\t// points were copied; start at the beginning otherwise.\n\n\t\tfor (index = basic > 0 ? basic + 1 : 0; index < inputLength; /* no final expression */) {\n\n\t\t\t// `index` is the index of the next character to be consumed.\n\t\t\t// Decode a generalized variable-length integer into `delta`,\n\t\t\t// which gets added to `i`. The overflow checking is easier\n\t\t\t// if we increase `i` as we go, then subtract off its starting\n\t\t\t// value at the end to obtain `delta`.\n\t\t\tfor (oldi = i, w = 1, k = base; /* no condition */; k += base) {\n\n\t\t\t\tif (index >= inputLength) {\n\t\t\t\t\terror('invalid-input');\n\t\t\t\t}\n\n\t\t\t\tdigit = basicToDigit(input.charCodeAt(index++));\n\n\t\t\t\tif (digit >= base || digit > floor((maxInt - i) / w)) {\n\t\t\t\t\terror('overflow');\n\t\t\t\t}\n\n\t\t\t\ti += digit * w;\n\t\t\t\tt = k <= bias ? tMin : (k >= bias + tMax ? tMax : k - bias);\n\n\t\t\t\tif (digit < t) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\tbaseMinusT = base - t;\n\t\t\t\tif (w > floor(maxInt / baseMinusT)) {\n\t\t\t\t\terror('overflow');\n\t\t\t\t}\n\n\t\t\t\tw *= baseMinusT;\n\n\t\t\t}\n\n\t\t\tout = output.length + 1;\n\t\t\tbias = adapt(i - oldi, out, oldi == 0);\n\n\t\t\t// `i` was supposed to wrap around from `out` to `0`,\n\t\t\t// incrementing `n` each time, so we'll fix that now:\n\t\t\tif (floor(i / out) > maxInt - n) {\n\t\t\t\terror('overflow');\n\t\t\t}\n\n\t\t\tn += floor(i / out);\n\t\t\ti %= out;\n\n\t\t\t// Insert `n` at position `i` of the output\n\t\t\toutput.splice(i++, 0, n);\n\n\t\t}\n\n\t\treturn ucs2encode(output);\n\t}\n\n\t/**\n\t * Converts a string of Unicode symbols (e.g. a domain name label) to a\n\t * Punycode string of ASCII-only symbols.\n\t * @memberOf punycode\n\t * @param {String} input The string of Unicode symbols.\n\t * @returns {String} The resulting Punycode string of ASCII-only symbols.\n\t */\n\tfunction encode(input) {\n\t\tvar n,\n\t\t    delta,\n\t\t    handledCPCount,\n\t\t    basicLength,\n\t\t    bias,\n\t\t    j,\n\t\t    m,\n\t\t    q,\n\t\t    k,\n\t\t    t,\n\t\t    currentValue,\n\t\t    output = [],\n\t\t    /** `inputLength` will hold the number of code points in `input`. */\n\t\t    inputLength,\n\t\t    /** Cached calculation results */\n\t\t    handledCPCountPlusOne,\n\t\t    baseMinusT,\n\t\t    qMinusT;\n\n\t\t// Convert the input in UCS-2 to Unicode\n\t\tinput = ucs2decode(input);\n\n\t\t// Cache the length\n\t\tinputLength = input.length;\n\n\t\t// Initialize the state\n\t\tn = initialN;\n\t\tdelta = 0;\n\t\tbias = initialBias;\n\n\t\t// Handle the basic code points\n\t\tfor (j = 0; j < inputLength; ++j) {\n\t\t\tcurrentValue = input[j];\n\t\t\tif (currentValue < 0x80) {\n\t\t\t\toutput.push(stringFromCharCode(currentValue));\n\t\t\t}\n\t\t}\n\n\t\thandledCPCount = basicLength = output.length;\n\n\t\t// `handledCPCount` is the number of code points that have been handled;\n\t\t// `basicLength` is the number of basic code points.\n\n\t\t// Finish the basic string - if it is not empty - with a delimiter\n\t\tif (basicLength) {\n\t\t\toutput.push(delimiter);\n\t\t}\n\n\t\t// Main encoding loop:\n\t\twhile (handledCPCount < inputLength) {\n\n\t\t\t// All non-basic code points < n have been handled already. Find the next\n\t\t\t// larger one:\n\t\t\tfor (m = maxInt, j = 0; j < inputLength; ++j) {\n\t\t\t\tcurrentValue = input[j];\n\t\t\t\tif (currentValue >= n && currentValue < m) {\n\t\t\t\t\tm = currentValue;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Increase `delta` enough to advance the decoder's <n,i> state to <m,0>,\n\t\t\t// but guard against overflow\n\t\t\thandledCPCountPlusOne = handledCPCount + 1;\n\t\t\tif (m - n > floor((maxInt - delta) / handledCPCountPlusOne)) {\n\t\t\t\terror('overflow');\n\t\t\t}\n\n\t\t\tdelta += (m - n) * handledCPCountPlusOne;\n\t\t\tn = m;\n\n\t\t\tfor (j = 0; j < inputLength; ++j) {\n\t\t\t\tcurrentValue = input[j];\n\n\t\t\t\tif (currentValue < n && ++delta > maxInt) {\n\t\t\t\t\terror('overflow');\n\t\t\t\t}\n\n\t\t\t\tif (currentValue == n) {\n\t\t\t\t\t// Represent delta as a generalized variable-length integer\n\t\t\t\t\tfor (q = delta, k = base; /* no condition */; k += base) {\n\t\t\t\t\t\tt = k <= bias ? tMin : (k >= bias + tMax ? tMax : k - bias);\n\t\t\t\t\t\tif (q < t) {\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tqMinusT = q - t;\n\t\t\t\t\t\tbaseMinusT = base - t;\n\t\t\t\t\t\toutput.push(\n\t\t\t\t\t\t\tstringFromCharCode(digitToBasic(t + qMinusT % baseMinusT, 0))\n\t\t\t\t\t\t);\n\t\t\t\t\t\tq = floor(qMinusT / baseMinusT);\n\t\t\t\t\t}\n\n\t\t\t\t\toutput.push(stringFromCharCode(digitToBasic(q, 0)));\n\t\t\t\t\tbias = adapt(delta, handledCPCountPlusOne, handledCPCount == basicLength);\n\t\t\t\t\tdelta = 0;\n\t\t\t\t\t++handledCPCount;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t++delta;\n\t\t\t++n;\n\n\t\t}\n\t\treturn output.join('');\n\t}\n\n\t/**\n\t * Converts a Punycode string representing a domain name or an email address\n\t * to Unicode. Only the Punycoded parts of the input will be converted, i.e.\n\t * it doesn't matter if you call it on a string that has already been\n\t * converted to Unicode.\n\t * @memberOf punycode\n\t * @param {String} input The Punycoded domain name or email address to\n\t * convert to Unicode.\n\t * @returns {String} The Unicode representation of the given Punycode\n\t * string.\n\t */\n\tfunction toUnicode(input) {\n\t\treturn mapDomain(input, function(string) {\n\t\t\treturn regexPunycode.test(string)\n\t\t\t\t? decode(string.slice(4).toLowerCase())\n\t\t\t\t: string;\n\t\t});\n\t}\n\n\t/**\n\t * Converts a Unicode string representing a domain name or an email address to\n\t * Punycode. Only the non-ASCII parts of the domain name will be converted,\n\t * i.e. it doesn't matter if you call it with a domain that's already in\n\t * ASCII.\n\t * @memberOf punycode\n\t * @param {String} input The domain name or email address to convert, as a\n\t * Unicode string.\n\t * @returns {String} The Punycode representation of the given domain name or\n\t * email address.\n\t */\n\tfunction toASCII(input) {\n\t\treturn mapDomain(input, function(string) {\n\t\t\treturn regexNonASCII.test(string)\n\t\t\t\t? 'xn--' + encode(string)\n\t\t\t\t: string;\n\t\t});\n\t}\n\n\t/*--------------------------------------------------------------------------*/\n\n\t/** Define the public API */\n\tpunycode = {\n\t\t/**\n\t\t * A string representing the current Punycode.js version number.\n\t\t * @memberOf punycode\n\t\t * @type String\n\t\t */\n\t\t'version': '1.3.2',\n\t\t/**\n\t\t * An object of methods to convert from JavaScript's internal character\n\t\t * representation (UCS-2) to Unicode code points, and back.\n\t\t * @see <https://mathiasbynens.be/notes/javascript-encoding>\n\t\t * @memberOf punycode\n\t\t * @type Object\n\t\t */\n\t\t'ucs2': {\n\t\t\t'decode': ucs2decode,\n\t\t\t'encode': ucs2encode\n\t\t},\n\t\t'decode': decode,\n\t\t'encode': encode,\n\t\t'toASCII': toASCII,\n\t\t'toUnicode': toUnicode\n\t};\n\n\t/** Expose `punycode` */\n\t// Some AMD build optimizers, like r.js, check for specific condition patterns\n\t// like the following:\n\tif (\n\t\ttypeof define == 'function' &&\n\t\ttypeof define.amd == 'object' &&\n\t\tdefine.amd\n\t) {\n\t\tdefine('punycode', function() {\n\t\t\treturn punycode;\n\t\t});\n\t} else if (freeExports && freeModule) {\n\t\tif (module.exports == freeExports) {\n\t\t\t// in Node.js, io.js, or RingoJS v0.8.0+\n\t\t\tfreeModule.exports = punycode;\n\t\t} else {\n\t\t\t// in Narwhal or RingoJS v0.7.0-\n\t\t\tfor (key in punycode) {\n\t\t\t\tpunycode.hasOwnProperty(key) && (freeExports[key] = punycode[key]);\n\t\t\t}\n\t\t}\n\t} else {\n\t\t// in Rhino or a web browser\n\t\troot.punycode = punycode;\n\t}\n\n}(this));\n","// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n'use strict';\n\n// If obj.hasOwnProperty has been overridden, then calling\n// obj.hasOwnProperty(prop) will break.\n// See: https://github.com/joyent/node/issues/1707\nfunction hasOwnProperty(obj, prop) {\n  return Object.prototype.hasOwnProperty.call(obj, prop);\n}\n\nmodule.exports = function(qs, sep, eq, options) {\n  sep = sep || '&';\n  eq = eq || '=';\n  var obj = {};\n\n  if (typeof qs !== 'string' || qs.length === 0) {\n    return obj;\n  }\n\n  var regexp = /\\+/g;\n  qs = qs.split(sep);\n\n  var maxKeys = 1000;\n  if (options && typeof options.maxKeys === 'number') {\n    maxKeys = options.maxKeys;\n  }\n\n  var len = qs.length;\n  // maxKeys <= 0 means that we should not limit keys count\n  if (maxKeys > 0 && len > maxKeys) {\n    len = maxKeys;\n  }\n\n  for (var i = 0; i < len; ++i) {\n    var x = qs[i].replace(regexp, '%20'),\n        idx = x.indexOf(eq),\n        kstr, vstr, k, v;\n\n    if (idx >= 0) {\n      kstr = x.substr(0, idx);\n      vstr = x.substr(idx + 1);\n    } else {\n      kstr = x;\n      vstr = '';\n    }\n\n    k = decodeURIComponent(kstr);\n    v = decodeURIComponent(vstr);\n\n    if (!hasOwnProperty(obj, k)) {\n      obj[k] = v;\n    } else if (isArray(obj[k])) {\n      obj[k].push(v);\n    } else {\n      obj[k] = [obj[k], v];\n    }\n  }\n\n  return obj;\n};\n\nvar isArray = Array.isArray || function (xs) {\n  return Object.prototype.toString.call(xs) === '[object Array]';\n};\n","// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n'use strict';\n\nvar stringifyPrimitive = function(v) {\n  switch (typeof v) {\n    case 'string':\n      return v;\n\n    case 'boolean':\n      return v ? 'true' : 'false';\n\n    case 'number':\n      return isFinite(v) ? v : '';\n\n    default:\n      return '';\n  }\n};\n\nmodule.exports = function(obj, sep, eq, name) {\n  sep = sep || '&';\n  eq = eq || '=';\n  if (obj === null) {\n    obj = undefined;\n  }\n\n  if (typeof obj === 'object') {\n    return map(objectKeys(obj), function(k) {\n      var ks = encodeURIComponent(stringifyPrimitive(k)) + eq;\n      if (isArray(obj[k])) {\n        return map(obj[k], function(v) {\n          return ks + encodeURIComponent(stringifyPrimitive(v));\n        }).join(sep);\n      } else {\n        return ks + encodeURIComponent(stringifyPrimitive(obj[k]));\n      }\n    }).join(sep);\n\n  }\n\n  if (!name) return '';\n  return encodeURIComponent(stringifyPrimitive(name)) + eq +\n         encodeURIComponent(stringifyPrimitive(obj));\n};\n\nvar isArray = Array.isArray || function (xs) {\n  return Object.prototype.toString.call(xs) === '[object Array]';\n};\n\nfunction map (xs, f) {\n  if (xs.map) return xs.map(f);\n  var res = [];\n  for (var i = 0; i < xs.length; i++) {\n    res.push(f(xs[i], i));\n  }\n  return res;\n}\n\nvar objectKeys = Object.keys || function (obj) {\n  var res = [];\n  for (var key in obj) {\n    if (Object.prototype.hasOwnProperty.call(obj, key)) res.push(key);\n  }\n  return res;\n};\n","'use strict';\n\nexports.decode = exports.parse = require('./decode');\nexports.encode = exports.stringify = require('./encode');\n","module.exports = require(\"./lib/_stream_duplex.js\")\n","// a duplex stream is just a stream that is both readable and writable.\n// Since JS doesn't have multiple prototypal inheritance, this class\n// prototypally inherits from Readable, and then parasitically from\n// Writable.\n\n'use strict';\n\n/*<replacement>*/\nvar objectKeys = Object.keys || function (obj) {\n  var keys = [];\n  for (var key in obj) keys.push(key);\n  return keys;\n}\n/*</replacement>*/\n\n\nmodule.exports = Duplex;\n\n/*<replacement>*/\nvar processNextTick = require('process-nextick-args');\n/*</replacement>*/\n\n\n\n/*<replacement>*/\nvar util = require('core-util-is');\nutil.inherits = require('inherits');\n/*</replacement>*/\n\nvar Readable = require('./_stream_readable');\nvar Writable = require('./_stream_writable');\n\nutil.inherits(Duplex, Readable);\n\nvar keys = objectKeys(Writable.prototype);\nfor (var v = 0; v < keys.length; v++) {\n  var method = keys[v];\n  if (!Duplex.prototype[method])\n    Duplex.prototype[method] = Writable.prototype[method];\n}\n\nfunction Duplex(options) {\n  if (!(this instanceof Duplex))\n    return new Duplex(options);\n\n  Readable.call(this, options);\n  Writable.call(this, options);\n\n  if (options && options.readable === false)\n    this.readable = false;\n\n  if (options && options.writable === false)\n    this.writable = false;\n\n  this.allowHalfOpen = true;\n  if (options && options.allowHalfOpen === false)\n    this.allowHalfOpen = false;\n\n  this.once('end', onend);\n}\n\n// the no-half-open enforcer\nfunction onend() {\n  // if we allow half-open state, or if the writable side ended,\n  // then we're ok.\n  if (this.allowHalfOpen || this._writableState.ended)\n    return;\n\n  // no more data can be written.\n  // But allow more writes to happen in this tick.\n  processNextTick(onEndNT, this);\n}\n\nfunction onEndNT(self) {\n  self.end();\n}\n\nfunction forEach (xs, f) {\n  for (var i = 0, l = xs.length; i < l; i++) {\n    f(xs[i], i);\n  }\n}\n","// a passthrough stream.\n// basically just the most minimal sort of Transform stream.\n// Every written chunk gets output as-is.\n\n'use strict';\n\nmodule.exports = PassThrough;\n\nvar Transform = require('./_stream_transform');\n\n/*<replacement>*/\nvar util = require('core-util-is');\nutil.inherits = require('inherits');\n/*</replacement>*/\n\nutil.inherits(PassThrough, Transform);\n\nfunction PassThrough(options) {\n  if (!(this instanceof PassThrough))\n    return new PassThrough(options);\n\n  Transform.call(this, options);\n}\n\nPassThrough.prototype._transform = function(chunk, encoding, cb) {\n  cb(null, chunk);\n};\n","'use strict';\n\nmodule.exports = Readable;\n\n/*<replacement>*/\nvar processNextTick = require('process-nextick-args');\n/*</replacement>*/\n\n\n/*<replacement>*/\nvar isArray = require('isarray');\n/*</replacement>*/\n\n\n/*<replacement>*/\nvar Buffer = require('buffer').Buffer;\n/*</replacement>*/\n\nReadable.ReadableState = ReadableState;\n\nvar EE = require('events');\n\n/*<replacement>*/\nvar EElistenerCount = function(emitter, type) {\n  return emitter.listeners(type).length;\n};\n/*</replacement>*/\n\n\n\n/*<replacement>*/\nvar Stream;\n(function (){try{\n  Stream = require('st' + 'ream');\n}catch(_){}finally{\n  if (!Stream)\n    Stream = require('events').EventEmitter;\n}}())\n/*</replacement>*/\n\nvar Buffer = require('buffer').Buffer;\n\n/*<replacement>*/\nvar util = require('core-util-is');\nutil.inherits = require('inherits');\n/*</replacement>*/\n\n\n\n/*<replacement>*/\nvar debugUtil = require('util');\nvar debug;\nif (debugUtil && debugUtil.debuglog) {\n  debug = debugUtil.debuglog('stream');\n} else {\n  debug = function () {};\n}\n/*</replacement>*/\n\nvar StringDecoder;\n\nutil.inherits(Readable, Stream);\n\nfunction ReadableState(options, stream) {\n  var Duplex = require('./_stream_duplex');\n\n  options = options || {};\n\n  // object stream flag. Used to make read(n) ignore n and to\n  // make all the buffer merging and length checks go away\n  this.objectMode = !!options.objectMode;\n\n  if (stream instanceof Duplex)\n    this.objectMode = this.objectMode || !!options.readableObjectMode;\n\n  // the point at which it stops calling _read() to fill the buffer\n  // Note: 0 is a valid value, means \"don't call _read preemptively ever\"\n  var hwm = options.highWaterMark;\n  var defaultHwm = this.objectMode ? 16 : 16 * 1024;\n  this.highWaterMark = (hwm || hwm === 0) ? hwm : defaultHwm;\n\n  // cast to ints.\n  this.highWaterMark = ~~this.highWaterMark;\n\n  this.buffer = [];\n  this.length = 0;\n  this.pipes = null;\n  this.pipesCount = 0;\n  this.flowing = null;\n  this.ended = false;\n  this.endEmitted = false;\n  this.reading = false;\n\n  // a flag to be able to tell if the onwrite cb is called immediately,\n  // or on a later tick.  We set this to true at first, because any\n  // actions that shouldn't happen until \"later\" should generally also\n  // not happen before the first write call.\n  this.sync = true;\n\n  // whenever we return null, then we set a flag to say\n  // that we're awaiting a 'readable' event emission.\n  this.needReadable = false;\n  this.emittedReadable = false;\n  this.readableListening = false;\n\n  // Crypto is kind of old and crusty.  Historically, its default string\n  // encoding is 'binary' so we have to make this configurable.\n  // Everything else in the universe uses 'utf8', though.\n  this.defaultEncoding = options.defaultEncoding || 'utf8';\n\n  // when piping, we only care about 'readable' events that happen\n  // after read()ing all the bytes and not getting any pushback.\n  this.ranOut = false;\n\n  // the number of writers that are awaiting a drain event in .pipe()s\n  this.awaitDrain = 0;\n\n  // if true, a maybeReadMore has been scheduled\n  this.readingMore = false;\n\n  this.decoder = null;\n  this.encoding = null;\n  if (options.encoding) {\n    if (!StringDecoder)\n      StringDecoder = require('string_decoder/').StringDecoder;\n    this.decoder = new StringDecoder(options.encoding);\n    this.encoding = options.encoding;\n  }\n}\n\nfunction Readable(options) {\n  var Duplex = require('./_stream_duplex');\n\n  if (!(this instanceof Readable))\n    return new Readable(options);\n\n  this._readableState = new ReadableState(options, this);\n\n  // legacy\n  this.readable = true;\n\n  if (options && typeof options.read === 'function')\n    this._read = options.read;\n\n  Stream.call(this);\n}\n\n// Manually shove something into the read() buffer.\n// This returns true if the highWaterMark has not been hit yet,\n// similar to how Writable.write() returns true if you should\n// write() some more.\nReadable.prototype.push = function(chunk, encoding) {\n  var state = this._readableState;\n\n  if (!state.objectMode && typeof chunk === 'string') {\n    encoding = encoding || state.defaultEncoding;\n    if (encoding !== state.encoding) {\n      chunk = new Buffer(chunk, encoding);\n      encoding = '';\n    }\n  }\n\n  return readableAddChunk(this, state, chunk, encoding, false);\n};\n\n// Unshift should *always* be something directly out of read()\nReadable.prototype.unshift = function(chunk) {\n  var state = this._readableState;\n  return readableAddChunk(this, state, chunk, '', true);\n};\n\nReadable.prototype.isPaused = function() {\n  return this._readableState.flowing === false;\n};\n\nfunction readableAddChunk(stream, state, chunk, encoding, addToFront) {\n  var er = chunkInvalid(state, chunk);\n  if (er) {\n    stream.emit('error', er);\n  } else if (chunk === null) {\n    state.reading = false;\n    onEofChunk(stream, state);\n  } else if (state.objectMode || chunk && chunk.length > 0) {\n    if (state.ended && !addToFront) {\n      var e = new Error('stream.push() after EOF');\n      stream.emit('error', e);\n    } else if (state.endEmitted && addToFront) {\n      var e = new Error('stream.unshift() after end event');\n      stream.emit('error', e);\n    } else {\n      if (state.decoder && !addToFront && !encoding)\n        chunk = state.decoder.write(chunk);\n\n      if (!addToFront)\n        state.reading = false;\n\n      // if we want the data now, just emit it.\n      if (state.flowing && state.length === 0 && !state.sync) {\n        stream.emit('data', chunk);\n        stream.read(0);\n      } else {\n        // update the buffer info.\n        state.length += state.objectMode ? 1 : chunk.length;\n        if (addToFront)\n          state.buffer.unshift(chunk);\n        else\n          state.buffer.push(chunk);\n\n        if (state.needReadable)\n          emitReadable(stream);\n      }\n\n      maybeReadMore(stream, state);\n    }\n  } else if (!addToFront) {\n    state.reading = false;\n  }\n\n  return needMoreData(state);\n}\n\n\n// if it's past the high water mark, we can push in some more.\n// Also, if we have no data yet, we can stand some\n// more bytes.  This is to work around cases where hwm=0,\n// such as the repl.  Also, if the push() triggered a\n// readable event, and the user called read(largeNumber) such that\n// needReadable was set, then we ought to push more, so that another\n// 'readable' event will be triggered.\nfunction needMoreData(state) {\n  return !state.ended &&\n         (state.needReadable ||\n          state.length < state.highWaterMark ||\n          state.length === 0);\n}\n\n// backwards compatibility.\nReadable.prototype.setEncoding = function(enc) {\n  if (!StringDecoder)\n    StringDecoder = require('string_decoder/').StringDecoder;\n  this._readableState.decoder = new StringDecoder(enc);\n  this._readableState.encoding = enc;\n  return this;\n};\n\n// Don't raise the hwm > 8MB\nvar MAX_HWM = 0x800000;\nfunction computeNewHighWaterMark(n) {\n  if (n >= MAX_HWM) {\n    n = MAX_HWM;\n  } else {\n    // Get the next highest power of 2\n    n--;\n    n |= n >>> 1;\n    n |= n >>> 2;\n    n |= n >>> 4;\n    n |= n >>> 8;\n    n |= n >>> 16;\n    n++;\n  }\n  return n;\n}\n\nfunction howMuchToRead(n, state) {\n  if (state.length === 0 && state.ended)\n    return 0;\n\n  if (state.objectMode)\n    return n === 0 ? 0 : 1;\n\n  if (n === null || isNaN(n)) {\n    // only flow one buffer at a time\n    if (state.flowing && state.buffer.length)\n      return state.buffer[0].length;\n    else\n      return state.length;\n  }\n\n  if (n <= 0)\n    return 0;\n\n  // If we're asking for more than the target buffer level,\n  // then raise the water mark.  Bump up to the next highest\n  // power of 2, to prevent increasing it excessively in tiny\n  // amounts.\n  if (n > state.highWaterMark)\n    state.highWaterMark = computeNewHighWaterMark(n);\n\n  // don't have that much.  return null, unless we've ended.\n  if (n > state.length) {\n    if (!state.ended) {\n      state.needReadable = true;\n      return 0;\n    } else {\n      return state.length;\n    }\n  }\n\n  return n;\n}\n\n// you can override either this method, or the async _read(n) below.\nReadable.prototype.read = function(n) {\n  debug('read', n);\n  var state = this._readableState;\n  var nOrig = n;\n\n  if (typeof n !== 'number' || n > 0)\n    state.emittedReadable = false;\n\n  // if we're doing read(0) to trigger a readable event, but we\n  // already have a bunch of data in the buffer, then just trigger\n  // the 'readable' event and move on.\n  if (n === 0 &&\n      state.needReadable &&\n      (state.length >= state.highWaterMark || state.ended)) {\n    debug('read: emitReadable', state.length, state.ended);\n    if (state.length === 0 && state.ended)\n      endReadable(this);\n    else\n      emitReadable(this);\n    return null;\n  }\n\n  n = howMuchToRead(n, state);\n\n  // if we've ended, and we're now clear, then finish it up.\n  if (n === 0 && state.ended) {\n    if (state.length === 0)\n      endReadable(this);\n    return null;\n  }\n\n  // All the actual chunk generation logic needs to be\n  // *below* the call to _read.  The reason is that in certain\n  // synthetic stream cases, such as passthrough streams, _read\n  // may be a completely synchronous operation which may change\n  // the state of the read buffer, providing enough data when\n  // before there was *not* enough.\n  //\n  // So, the steps are:\n  // 1. Figure out what the state of things will be after we do\n  // a read from the buffer.\n  //\n  // 2. If that resulting state will trigger a _read, then call _read.\n  // Note that this may be asynchronous, or synchronous.  Yes, it is\n  // deeply ugly to write APIs this way, but that still doesn't mean\n  // that the Readable class should behave improperly, as streams are\n  // designed to be sync/async agnostic.\n  // Take note if the _read call is sync or async (ie, if the read call\n  // has returned yet), so that we know whether or not it's safe to emit\n  // 'readable' etc.\n  //\n  // 3. Actually pull the requested chunks out of the buffer and return.\n\n  // if we need a readable event, then we need to do some reading.\n  var doRead = state.needReadable;\n  debug('need readable', doRead);\n\n  // if we currently have less than the highWaterMark, then also read some\n  if (state.length === 0 || state.length - n < state.highWaterMark) {\n    doRead = true;\n    debug('length less than watermark', doRead);\n  }\n\n  // however, if we've ended, then there's no point, and if we're already\n  // reading, then it's unnecessary.\n  if (state.ended || state.reading) {\n    doRead = false;\n    debug('reading or ended', doRead);\n  }\n\n  if (doRead) {\n    debug('do read');\n    state.reading = true;\n    state.sync = true;\n    // if the length is currently zero, then we *need* a readable event.\n    if (state.length === 0)\n      state.needReadable = true;\n    // call internal read method\n    this._read(state.highWaterMark);\n    state.sync = false;\n  }\n\n  // If _read pushed data synchronously, then `reading` will be false,\n  // and we need to re-evaluate how much data we can return to the user.\n  if (doRead && !state.reading)\n    n = howMuchToRead(nOrig, state);\n\n  var ret;\n  if (n > 0)\n    ret = fromList(n, state);\n  else\n    ret = null;\n\n  if (ret === null) {\n    state.needReadable = true;\n    n = 0;\n  }\n\n  state.length -= n;\n\n  // If we have nothing in the buffer, then we want to know\n  // as soon as we *do* get something into the buffer.\n  if (state.length === 0 && !state.ended)\n    state.needReadable = true;\n\n  // If we tried to read() past the EOF, then emit end on the next tick.\n  if (nOrig !== n && state.ended && state.length === 0)\n    endReadable(this);\n\n  if (ret !== null)\n    this.emit('data', ret);\n\n  return ret;\n};\n\nfunction chunkInvalid(state, chunk) {\n  var er = null;\n  if (!(Buffer.isBuffer(chunk)) &&\n      typeof chunk !== 'string' &&\n      chunk !== null &&\n      chunk !== undefined &&\n      !state.objectMode) {\n    er = new TypeError('Invalid non-string/buffer chunk');\n  }\n  return er;\n}\n\n\nfunction onEofChunk(stream, state) {\n  if (state.ended) return;\n  if (state.decoder) {\n    var chunk = state.decoder.end();\n    if (chunk && chunk.length) {\n      state.buffer.push(chunk);\n      state.length += state.objectMode ? 1 : chunk.length;\n    }\n  }\n  state.ended = true;\n\n  // emit 'readable' now to make sure it gets picked up.\n  emitReadable(stream);\n}\n\n// Don't emit readable right away in sync mode, because this can trigger\n// another read() call => stack overflow.  This way, it might trigger\n// a nextTick recursion warning, but that's not so bad.\nfunction emitReadable(stream) {\n  var state = stream._readableState;\n  state.needReadable = false;\n  if (!state.emittedReadable) {\n    debug('emitReadable', state.flowing);\n    state.emittedReadable = true;\n    if (state.sync)\n      processNextTick(emitReadable_, stream);\n    else\n      emitReadable_(stream);\n  }\n}\n\nfunction emitReadable_(stream) {\n  debug('emit readable');\n  stream.emit('readable');\n  flow(stream);\n}\n\n\n// at this point, the user has presumably seen the 'readable' event,\n// and called read() to consume some data.  that may have triggered\n// in turn another _read(n) call, in which case reading = true if\n// it's in progress.\n// However, if we're not ended, or reading, and the length < hwm,\n// then go ahead and try to read some more preemptively.\nfunction maybeReadMore(stream, state) {\n  if (!state.readingMore) {\n    state.readingMore = true;\n    processNextTick(maybeReadMore_, stream, state);\n  }\n}\n\nfunction maybeReadMore_(stream, state) {\n  var len = state.length;\n  while (!state.reading && !state.flowing && !state.ended &&\n         state.length < state.highWaterMark) {\n    debug('maybeReadMore read 0');\n    stream.read(0);\n    if (len === state.length)\n      // didn't get any data, stop spinning.\n      break;\n    else\n      len = state.length;\n  }\n  state.readingMore = false;\n}\n\n// abstract method.  to be overridden in specific implementation classes.\n// call cb(er, data) where data is <= n in length.\n// for virtual (non-string, non-buffer) streams, \"length\" is somewhat\n// arbitrary, and perhaps not very meaningful.\nReadable.prototype._read = function(n) {\n  this.emit('error', new Error('not implemented'));\n};\n\nReadable.prototype.pipe = function(dest, pipeOpts) {\n  var src = this;\n  var state = this._readableState;\n\n  switch (state.pipesCount) {\n    case 0:\n      state.pipes = dest;\n      break;\n    case 1:\n      state.pipes = [state.pipes, dest];\n      break;\n    default:\n      state.pipes.push(dest);\n      break;\n  }\n  state.pipesCount += 1;\n  debug('pipe count=%d opts=%j', state.pipesCount, pipeOpts);\n\n  var doEnd = (!pipeOpts || pipeOpts.end !== false) &&\n              dest !== process.stdout &&\n              dest !== process.stderr;\n\n  var endFn = doEnd ? onend : cleanup;\n  if (state.endEmitted)\n    processNextTick(endFn);\n  else\n    src.once('end', endFn);\n\n  dest.on('unpipe', onunpipe);\n  function onunpipe(readable) {\n    debug('onunpipe');\n    if (readable === src) {\n      cleanup();\n    }\n  }\n\n  function onend() {\n    debug('onend');\n    dest.end();\n  }\n\n  // when the dest drains, it reduces the awaitDrain counter\n  // on the source.  This would be more elegant with a .once()\n  // handler in flow(), but adding and removing repeatedly is\n  // too slow.\n  var ondrain = pipeOnDrain(src);\n  dest.on('drain', ondrain);\n\n  var cleanedUp = false;\n  function cleanup() {\n    debug('cleanup');\n    // cleanup event handlers once the pipe is broken\n    dest.removeListener('close', onclose);\n    dest.removeListener('finish', onfinish);\n    dest.removeListener('drain', ondrain);\n    dest.removeListener('error', onerror);\n    dest.removeListener('unpipe', onunpipe);\n    src.removeListener('end', onend);\n    src.removeListener('end', cleanup);\n    src.removeListener('data', ondata);\n\n    cleanedUp = true;\n\n    // if the reader is waiting for a drain event from this\n    // specific writer, then it would cause it to never start\n    // flowing again.\n    // So, if this is awaiting a drain, then we just call it now.\n    // If we don't know, then assume that we are waiting for one.\n    if (state.awaitDrain &&\n        (!dest._writableState || dest._writableState.needDrain))\n      ondrain();\n  }\n\n  src.on('data', ondata);\n  function ondata(chunk) {\n    debug('ondata');\n    var ret = dest.write(chunk);\n    if (false === ret) {\n      // If the user unpiped during `dest.write()`, it is possible\n      // to get stuck in a permanently paused state if that write\n      // also returned false.\n      if (state.pipesCount === 1 &&\n          state.pipes[0] === dest &&\n          src.listenerCount('data') === 1 &&\n          !cleanedUp) {\n        debug('false write response, pause', src._readableState.awaitDrain);\n        src._readableState.awaitDrain++;\n      }\n      src.pause();\n    }\n  }\n\n  // if the dest has an error, then stop piping into it.\n  // however, don't suppress the throwing behavior for this.\n  function onerror(er) {\n    debug('onerror', er);\n    unpipe();\n    dest.removeListener('error', onerror);\n    if (EElistenerCount(dest, 'error') === 0)\n      dest.emit('error', er);\n  }\n  // This is a brutally ugly hack to make sure that our error handler\n  // is attached before any userland ones.  NEVER DO THIS.\n  if (!dest._events || !dest._events.error)\n    dest.on('error', onerror);\n  else if (isArray(dest._events.error))\n    dest._events.error.unshift(onerror);\n  else\n    dest._events.error = [onerror, dest._events.error];\n\n\n  // Both close and finish should trigger unpipe, but only once.\n  function onclose() {\n    dest.removeListener('finish', onfinish);\n    unpipe();\n  }\n  dest.once('close', onclose);\n  function onfinish() {\n    debug('onfinish');\n    dest.removeListener('close', onclose);\n    unpipe();\n  }\n  dest.once('finish', onfinish);\n\n  function unpipe() {\n    debug('unpipe');\n    src.unpipe(dest);\n  }\n\n  // tell the dest that it's being piped to\n  dest.emit('pipe', src);\n\n  // start the flow if it hasn't been started already.\n  if (!state.flowing) {\n    debug('pipe resume');\n    src.resume();\n  }\n\n  return dest;\n};\n\nfunction pipeOnDrain(src) {\n  return function() {\n    var state = src._readableState;\n    debug('pipeOnDrain', state.awaitDrain);\n    if (state.awaitDrain)\n      state.awaitDrain--;\n    if (state.awaitDrain === 0 && EElistenerCount(src, 'data')) {\n      state.flowing = true;\n      flow(src);\n    }\n  };\n}\n\n\nReadable.prototype.unpipe = function(dest) {\n  var state = this._readableState;\n\n  // if we're not piping anywhere, then do nothing.\n  if (state.pipesCount === 0)\n    return this;\n\n  // just one destination.  most common case.\n  if (state.pipesCount === 1) {\n    // passed in one, but it's not the right one.\n    if (dest && dest !== state.pipes)\n      return this;\n\n    if (!dest)\n      dest = state.pipes;\n\n    // got a match.\n    state.pipes = null;\n    state.pipesCount = 0;\n    state.flowing = false;\n    if (dest)\n      dest.emit('unpipe', this);\n    return this;\n  }\n\n  // slow case. multiple pipe destinations.\n\n  if (!dest) {\n    // remove all.\n    var dests = state.pipes;\n    var len = state.pipesCount;\n    state.pipes = null;\n    state.pipesCount = 0;\n    state.flowing = false;\n\n    for (var i = 0; i < len; i++)\n      dests[i].emit('unpipe', this);\n    return this;\n  }\n\n  // try to find the right one.\n  var i = indexOf(state.pipes, dest);\n  if (i === -1)\n    return this;\n\n  state.pipes.splice(i, 1);\n  state.pipesCount -= 1;\n  if (state.pipesCount === 1)\n    state.pipes = state.pipes[0];\n\n  dest.emit('unpipe', this);\n\n  return this;\n};\n\n// set up data events if they are asked for\n// Ensure readable listeners eventually get something\nReadable.prototype.on = function(ev, fn) {\n  var res = Stream.prototype.on.call(this, ev, fn);\n\n  // If listening to data, and it has not explicitly been paused,\n  // then call resume to start the flow of data on the next tick.\n  if (ev === 'data' && false !== this._readableState.flowing) {\n    this.resume();\n  }\n\n  if (ev === 'readable' && this.readable) {\n    var state = this._readableState;\n    if (!state.readableListening) {\n      state.readableListening = true;\n      state.emittedReadable = false;\n      state.needReadable = true;\n      if (!state.reading) {\n        processNextTick(nReadingNextTick, this);\n      } else if (state.length) {\n        emitReadable(this, state);\n      }\n    }\n  }\n\n  return res;\n};\nReadable.prototype.addListener = Readable.prototype.on;\n\nfunction nReadingNextTick(self) {\n  debug('readable nexttick read 0');\n  self.read(0);\n}\n\n// pause() and resume() are remnants of the legacy readable stream API\n// If the user uses them, then switch into old mode.\nReadable.prototype.resume = function() {\n  var state = this._readableState;\n  if (!state.flowing) {\n    debug('resume');\n    state.flowing = true;\n    resume(this, state);\n  }\n  return this;\n};\n\nfunction resume(stream, state) {\n  if (!state.resumeScheduled) {\n    state.resumeScheduled = true;\n    processNextTick(resume_, stream, state);\n  }\n}\n\nfunction resume_(stream, state) {\n  if (!state.reading) {\n    debug('resume read 0');\n    stream.read(0);\n  }\n\n  state.resumeScheduled = false;\n  stream.emit('resume');\n  flow(stream);\n  if (state.flowing && !state.reading)\n    stream.read(0);\n}\n\nReadable.prototype.pause = function() {\n  debug('call pause flowing=%j', this._readableState.flowing);\n  if (false !== this._readableState.flowing) {\n    debug('pause');\n    this._readableState.flowing = false;\n    this.emit('pause');\n  }\n  return this;\n};\n\nfunction flow(stream) {\n  var state = stream._readableState;\n  debug('flow', state.flowing);\n  if (state.flowing) {\n    do {\n      var chunk = stream.read();\n    } while (null !== chunk && state.flowing);\n  }\n}\n\n// wrap an old-style stream as the async data source.\n// This is *not* part of the readable stream interface.\n// It is an ugly unfortunate mess of history.\nReadable.prototype.wrap = function(stream) {\n  var state = this._readableState;\n  var paused = false;\n\n  var self = this;\n  stream.on('end', function() {\n    debug('wrapped end');\n    if (state.decoder && !state.ended) {\n      var chunk = state.decoder.end();\n      if (chunk && chunk.length)\n        self.push(chunk);\n    }\n\n    self.push(null);\n  });\n\n  stream.on('data', function(chunk) {\n    debug('wrapped data');\n    if (state.decoder)\n      chunk = state.decoder.write(chunk);\n\n    // don't skip over falsy values in objectMode\n    if (state.objectMode && (chunk === null || chunk === undefined))\n      return;\n    else if (!state.objectMode && (!chunk || !chunk.length))\n      return;\n\n    var ret = self.push(chunk);\n    if (!ret) {\n      paused = true;\n      stream.pause();\n    }\n  });\n\n  // proxy all the other methods.\n  // important when wrapping filters and duplexes.\n  for (var i in stream) {\n    if (this[i] === undefined && typeof stream[i] === 'function') {\n      this[i] = function(method) { return function() {\n        return stream[method].apply(stream, arguments);\n      }; }(i);\n    }\n  }\n\n  // proxy certain important events.\n  var events = ['error', 'close', 'destroy', 'pause', 'resume'];\n  forEach(events, function(ev) {\n    stream.on(ev, self.emit.bind(self, ev));\n  });\n\n  // when we try to consume some more bytes, simply unpause the\n  // underlying stream.\n  self._read = function(n) {\n    debug('wrapped _read', n);\n    if (paused) {\n      paused = false;\n      stream.resume();\n    }\n  };\n\n  return self;\n};\n\n\n// exposed for testing purposes only.\nReadable._fromList = fromList;\n\n// Pluck off n bytes from an array of buffers.\n// Length is the combined lengths of all the buffers in the list.\nfunction fromList(n, state) {\n  var list = state.buffer;\n  var length = state.length;\n  var stringMode = !!state.decoder;\n  var objectMode = !!state.objectMode;\n  var ret;\n\n  // nothing in the list, definitely empty.\n  if (list.length === 0)\n    return null;\n\n  if (length === 0)\n    ret = null;\n  else if (objectMode)\n    ret = list.shift();\n  else if (!n || n >= length) {\n    // read it all, truncate the array.\n    if (stringMode)\n      ret = list.join('');\n    else if (list.length === 1)\n      ret = list[0];\n    else\n      ret = Buffer.concat(list, length);\n    list.length = 0;\n  } else {\n    // read just some of it.\n    if (n < list[0].length) {\n      // just take a part of the first list item.\n      // slice is the same for buffers and strings.\n      var buf = list[0];\n      ret = buf.slice(0, n);\n      list[0] = buf.slice(n);\n    } else if (n === list[0].length) {\n      // first list is a perfect match\n      ret = list.shift();\n    } else {\n      // complex case.\n      // we have enough to cover it, but it spans past the first buffer.\n      if (stringMode)\n        ret = '';\n      else\n        ret = new Buffer(n);\n\n      var c = 0;\n      for (var i = 0, l = list.length; i < l && c < n; i++) {\n        var buf = list[0];\n        var cpy = Math.min(n - c, buf.length);\n\n        if (stringMode)\n          ret += buf.slice(0, cpy);\n        else\n          buf.copy(ret, c, 0, cpy);\n\n        if (cpy < buf.length)\n          list[0] = buf.slice(cpy);\n        else\n          list.shift();\n\n        c += cpy;\n      }\n    }\n  }\n\n  return ret;\n}\n\nfunction endReadable(stream) {\n  var state = stream._readableState;\n\n  // If we get here before consuming all the bytes, then that is a\n  // bug in node.  Should never happen.\n  if (state.length > 0)\n    throw new Error('endReadable called on non-empty stream');\n\n  if (!state.endEmitted) {\n    state.ended = true;\n    processNextTick(endReadableNT, state, stream);\n  }\n}\n\nfunction endReadableNT(state, stream) {\n  // Check that we didn't get one last unshift.\n  if (!state.endEmitted && state.length === 0) {\n    state.endEmitted = true;\n    stream.readable = false;\n    stream.emit('end');\n  }\n}\n\nfunction forEach (xs, f) {\n  for (var i = 0, l = xs.length; i < l; i++) {\n    f(xs[i], i);\n  }\n}\n\nfunction indexOf (xs, x) {\n  for (var i = 0, l = xs.length; i < l; i++) {\n    if (xs[i] === x) return i;\n  }\n  return -1;\n}\n","// a transform stream is a readable/writable stream where you do\n// something with the data.  Sometimes it's called a \"filter\",\n// but that's not a great name for it, since that implies a thing where\n// some bits pass through, and others are simply ignored.  (That would\n// be a valid example of a transform, of course.)\n//\n// While the output is causally related to the input, it's not a\n// necessarily symmetric or synchronous transformation.  For example,\n// a zlib stream might take multiple plain-text writes(), and then\n// emit a single compressed chunk some time in the future.\n//\n// Here's how this works:\n//\n// The Transform stream has all the aspects of the readable and writable\n// stream classes.  When you write(chunk), that calls _write(chunk,cb)\n// internally, and returns false if there's a lot of pending writes\n// buffered up.  When you call read(), that calls _read(n) until\n// there's enough pending readable data buffered up.\n//\n// In a transform stream, the written data is placed in a buffer.  When\n// _read(n) is called, it transforms the queued up data, calling the\n// buffered _write cb's as it consumes chunks.  If consuming a single\n// written chunk would result in multiple output chunks, then the first\n// outputted bit calls the readcb, and subsequent chunks just go into\n// the read buffer, and will cause it to emit 'readable' if necessary.\n//\n// This way, back-pressure is actually determined by the reading side,\n// since _read has to be called to start processing a new chunk.  However,\n// a pathological inflate type of transform can cause excessive buffering\n// here.  For example, imagine a stream where every byte of input is\n// interpreted as an integer from 0-255, and then results in that many\n// bytes of output.  Writing the 4 bytes {ff,ff,ff,ff} would result in\n// 1kb of data being output.  In this case, you could write a very small\n// amount of input, and end up with a very large amount of output.  In\n// such a pathological inflating mechanism, there'd be no way to tell\n// the system to stop doing the transform.  A single 4MB write could\n// cause the system to run out of memory.\n//\n// However, even in such a pathological case, only a single written chunk\n// would be consumed, and then the rest would wait (un-transformed) until\n// the results of the previous transformed chunk were consumed.\n\n'use strict';\n\nmodule.exports = Transform;\n\nvar Duplex = require('./_stream_duplex');\n\n/*<replacement>*/\nvar util = require('core-util-is');\nutil.inherits = require('inherits');\n/*</replacement>*/\n\nutil.inherits(Transform, Duplex);\n\n\nfunction TransformState(stream) {\n  this.afterTransform = function(er, data) {\n    return afterTransform(stream, er, data);\n  };\n\n  this.needTransform = false;\n  this.transforming = false;\n  this.writecb = null;\n  this.writechunk = null;\n}\n\nfunction afterTransform(stream, er, data) {\n  var ts = stream._transformState;\n  ts.transforming = false;\n\n  var cb = ts.writecb;\n\n  if (!cb)\n    return stream.emit('error', new Error('no writecb in Transform class'));\n\n  ts.writechunk = null;\n  ts.writecb = null;\n\n  if (data !== null && data !== undefined)\n    stream.push(data);\n\n  if (cb)\n    cb(er);\n\n  var rs = stream._readableState;\n  rs.reading = false;\n  if (rs.needReadable || rs.length < rs.highWaterMark) {\n    stream._read(rs.highWaterMark);\n  }\n}\n\n\nfunction Transform(options) {\n  if (!(this instanceof Transform))\n    return new Transform(options);\n\n  Duplex.call(this, options);\n\n  this._transformState = new TransformState(this);\n\n  // when the writable side finishes, then flush out anything remaining.\n  var stream = this;\n\n  // start out asking for a readable event once data is transformed.\n  this._readableState.needReadable = true;\n\n  // we have implemented the _read method, and done the other things\n  // that Readable wants before the first _read call, so unset the\n  // sync guard flag.\n  this._readableState.sync = false;\n\n  if (options) {\n    if (typeof options.transform === 'function')\n      this._transform = options.transform;\n\n    if (typeof options.flush === 'function')\n      this._flush = options.flush;\n  }\n\n  this.once('prefinish', function() {\n    if (typeof this._flush === 'function')\n      this._flush(function(er) {\n        done(stream, er);\n      });\n    else\n      done(stream);\n  });\n}\n\nTransform.prototype.push = function(chunk, encoding) {\n  this._transformState.needTransform = false;\n  return Duplex.prototype.push.call(this, chunk, encoding);\n};\n\n// This is the part where you do stuff!\n// override this function in implementation classes.\n// 'chunk' is an input chunk.\n//\n// Call `push(newChunk)` to pass along transformed output\n// to the readable side.  You may call 'push' zero or more times.\n//\n// Call `cb(err)` when you are done with this chunk.  If you pass\n// an error, then that'll put the hurt on the whole operation.  If you\n// never call cb(), then you'll never get another chunk.\nTransform.prototype._transform = function(chunk, encoding, cb) {\n  throw new Error('not implemented');\n};\n\nTransform.prototype._write = function(chunk, encoding, cb) {\n  var ts = this._transformState;\n  ts.writecb = cb;\n  ts.writechunk = chunk;\n  ts.writeencoding = encoding;\n  if (!ts.transforming) {\n    var rs = this._readableState;\n    if (ts.needTransform ||\n        rs.needReadable ||\n        rs.length < rs.highWaterMark)\n      this._read(rs.highWaterMark);\n  }\n};\n\n// Doesn't matter what the args are here.\n// _transform does all the work.\n// That we got here means that the readable side wants more data.\nTransform.prototype._read = function(n) {\n  var ts = this._transformState;\n\n  if (ts.writechunk !== null && ts.writecb && !ts.transforming) {\n    ts.transforming = true;\n    this._transform(ts.writechunk, ts.writeencoding, ts.afterTransform);\n  } else {\n    // mark that we need a transform, so that any data that comes in\n    // will get processed, now that we've asked for it.\n    ts.needTransform = true;\n  }\n};\n\n\nfunction done(stream, er) {\n  if (er)\n    return stream.emit('error', er);\n\n  // if there's nothing in the write buffer, then that means\n  // that nothing more will ever be provided\n  var ws = stream._writableState;\n  var ts = stream._transformState;\n\n  if (ws.length)\n    throw new Error('calling transform done when ws.length != 0');\n\n  if (ts.transforming)\n    throw new Error('calling transform done when still transforming');\n\n  return stream.push(null);\n}\n","// A bit simpler than readable streams.\n// Implement an async ._write(chunk, encoding, cb), and it'll handle all\n// the drain event emission and buffering.\n\n'use strict';\n\nmodule.exports = Writable;\n\n/*<replacement>*/\nvar processNextTick = require('process-nextick-args');\n/*</replacement>*/\n\n\n/*<replacement>*/\nvar Buffer = require('buffer').Buffer;\n/*</replacement>*/\n\nWritable.WritableState = WritableState;\n\n\n/*<replacement>*/\nvar util = require('core-util-is');\nutil.inherits = require('inherits');\n/*</replacement>*/\n\n\n/*<replacement>*/\nvar internalUtil = {\n  deprecate: require('util-deprecate')\n};\n/*</replacement>*/\n\n\n\n/*<replacement>*/\nvar Stream;\n(function (){try{\n  Stream = require('st' + 'ream');\n}catch(_){}finally{\n  if (!Stream)\n    Stream = require('events').EventEmitter;\n}}())\n/*</replacement>*/\n\nvar Buffer = require('buffer').Buffer;\n\nutil.inherits(Writable, Stream);\n\nfunction nop() {}\n\nfunction WriteReq(chunk, encoding, cb) {\n  this.chunk = chunk;\n  this.encoding = encoding;\n  this.callback = cb;\n  this.next = null;\n}\n\nfunction WritableState(options, stream) {\n  var Duplex = require('./_stream_duplex');\n\n  options = options || {};\n\n  // object stream flag to indicate whether or not this stream\n  // contains buffers or objects.\n  this.objectMode = !!options.objectMode;\n\n  if (stream instanceof Duplex)\n    this.objectMode = this.objectMode || !!options.writableObjectMode;\n\n  // the point at which write() starts returning false\n  // Note: 0 is a valid value, means that we always return false if\n  // the entire buffer is not flushed immediately on write()\n  var hwm = options.highWaterMark;\n  var defaultHwm = this.objectMode ? 16 : 16 * 1024;\n  this.highWaterMark = (hwm || hwm === 0) ? hwm : defaultHwm;\n\n  // cast to ints.\n  this.highWaterMark = ~~this.highWaterMark;\n\n  this.needDrain = false;\n  // at the start of calling end()\n  this.ending = false;\n  // when end() has been called, and returned\n  this.ended = false;\n  // when 'finish' is emitted\n  this.finished = false;\n\n  // should we decode strings into buffers before passing to _write?\n  // this is here so that some node-core streams can optimize string\n  // handling at a lower level.\n  var noDecode = options.decodeStrings === false;\n  this.decodeStrings = !noDecode;\n\n  // Crypto is kind of old and crusty.  Historically, its default string\n  // encoding is 'binary' so we have to make this configurable.\n  // Everything else in the universe uses 'utf8', though.\n  this.defaultEncoding = options.defaultEncoding || 'utf8';\n\n  // not an actual buffer we keep track of, but a measurement\n  // of how much we're waiting to get pushed to some underlying\n  // socket or file.\n  this.length = 0;\n\n  // a flag to see when we're in the middle of a write.\n  this.writing = false;\n\n  // when true all writes will be buffered until .uncork() call\n  this.corked = 0;\n\n  // a flag to be able to tell if the onwrite cb is called immediately,\n  // or on a later tick.  We set this to true at first, because any\n  // actions that shouldn't happen until \"later\" should generally also\n  // not happen before the first write call.\n  this.sync = true;\n\n  // a flag to know if we're processing previously buffered items, which\n  // may call the _write() callback in the same tick, so that we don't\n  // end up in an overlapped onwrite situation.\n  this.bufferProcessing = false;\n\n  // the callback that's passed to _write(chunk,cb)\n  this.onwrite = function(er) {\n    onwrite(stream, er);\n  };\n\n  // the callback that the user supplies to write(chunk,encoding,cb)\n  this.writecb = null;\n\n  // the amount that is being written when _write is called.\n  this.writelen = 0;\n\n  this.bufferedRequest = null;\n  this.lastBufferedRequest = null;\n\n  // number of pending user-supplied write callbacks\n  // this must be 0 before 'finish' can be emitted\n  this.pendingcb = 0;\n\n  // emit prefinish if the only thing we're waiting for is _write cbs\n  // This is relevant for synchronous Transform streams\n  this.prefinished = false;\n\n  // True if the error was already emitted and should not be thrown again\n  this.errorEmitted = false;\n}\n\nWritableState.prototype.getBuffer = function writableStateGetBuffer() {\n  var current = this.bufferedRequest;\n  var out = [];\n  while (current) {\n    out.push(current);\n    current = current.next;\n  }\n  return out;\n};\n\n(function (){try {\nObject.defineProperty(WritableState.prototype, 'buffer', {\n  get: internalUtil.deprecate(function() {\n    return this.getBuffer();\n  }, '_writableState.buffer is deprecated. Use _writableState.getBuffer ' +\n     'instead.')\n});\n}catch(_){}}());\n\n\nfunction Writable(options) {\n  var Duplex = require('./_stream_duplex');\n\n  // Writable ctor is applied to Duplexes, though they're not\n  // instanceof Writable, they're instanceof Readable.\n  if (!(this instanceof Writable) && !(this instanceof Duplex))\n    return new Writable(options);\n\n  this._writableState = new WritableState(options, this);\n\n  // legacy.\n  this.writable = true;\n\n  if (options) {\n    if (typeof options.write === 'function')\n      this._write = options.write;\n\n    if (typeof options.writev === 'function')\n      this._writev = options.writev;\n  }\n\n  Stream.call(this);\n}\n\n// Otherwise people can pipe Writable streams, which is just wrong.\nWritable.prototype.pipe = function() {\n  this.emit('error', new Error('Cannot pipe. Not readable.'));\n};\n\n\nfunction writeAfterEnd(stream, cb) {\n  var er = new Error('write after end');\n  // TODO: defer error events consistently everywhere, not just the cb\n  stream.emit('error', er);\n  processNextTick(cb, er);\n}\n\n// If we get something that is not a buffer, string, null, or undefined,\n// and we're not in objectMode, then that's an error.\n// Otherwise stream chunks are all considered to be of length=1, and the\n// watermarks determine how many objects to keep in the buffer, rather than\n// how many bytes or characters.\nfunction validChunk(stream, state, chunk, cb) {\n  var valid = true;\n\n  if (!(Buffer.isBuffer(chunk)) &&\n      typeof chunk !== 'string' &&\n      chunk !== null &&\n      chunk !== undefined &&\n      !state.objectMode) {\n    var er = new TypeError('Invalid non-string/buffer chunk');\n    stream.emit('error', er);\n    processNextTick(cb, er);\n    valid = false;\n  }\n  return valid;\n}\n\nWritable.prototype.write = function(chunk, encoding, cb) {\n  var state = this._writableState;\n  var ret = false;\n\n  if (typeof encoding === 'function') {\n    cb = encoding;\n    encoding = null;\n  }\n\n  if (Buffer.isBuffer(chunk))\n    encoding = 'buffer';\n  else if (!encoding)\n    encoding = state.defaultEncoding;\n\n  if (typeof cb !== 'function')\n    cb = nop;\n\n  if (state.ended)\n    writeAfterEnd(this, cb);\n  else if (validChunk(this, state, chunk, cb)) {\n    state.pendingcb++;\n    ret = writeOrBuffer(this, state, chunk, encoding, cb);\n  }\n\n  return ret;\n};\n\nWritable.prototype.cork = function() {\n  var state = this._writableState;\n\n  state.corked++;\n};\n\nWritable.prototype.uncork = function() {\n  var state = this._writableState;\n\n  if (state.corked) {\n    state.corked--;\n\n    if (!state.writing &&\n        !state.corked &&\n        !state.finished &&\n        !state.bufferProcessing &&\n        state.bufferedRequest)\n      clearBuffer(this, state);\n  }\n};\n\nWritable.prototype.setDefaultEncoding = function setDefaultEncoding(encoding) {\n  // node::ParseEncoding() requires lower case.\n  if (typeof encoding === 'string')\n    encoding = encoding.toLowerCase();\n  if (!(['hex', 'utf8', 'utf-8', 'ascii', 'binary', 'base64',\n'ucs2', 'ucs-2','utf16le', 'utf-16le', 'raw']\n.indexOf((encoding + '').toLowerCase()) > -1))\n    throw new TypeError('Unknown encoding: ' + encoding);\n  this._writableState.defaultEncoding = encoding;\n};\n\nfunction decodeChunk(state, chunk, encoding) {\n  if (!state.objectMode &&\n      state.decodeStrings !== false &&\n      typeof chunk === 'string') {\n    chunk = new Buffer(chunk, encoding);\n  }\n  return chunk;\n}\n\n// if we're already writing something, then just put this\n// in the queue, and wait our turn.  Otherwise, call _write\n// If we return false, then we need a drain event, so set that flag.\nfunction writeOrBuffer(stream, state, chunk, encoding, cb) {\n  chunk = decodeChunk(state, chunk, encoding);\n\n  if (Buffer.isBuffer(chunk))\n    encoding = 'buffer';\n  var len = state.objectMode ? 1 : chunk.length;\n\n  state.length += len;\n\n  var ret = state.length < state.highWaterMark;\n  // we must ensure that previous needDrain will not be reset to false.\n  if (!ret)\n    state.needDrain = true;\n\n  if (state.writing || state.corked) {\n    var last = state.lastBufferedRequest;\n    state.lastBufferedRequest = new WriteReq(chunk, encoding, cb);\n    if (last) {\n      last.next = state.lastBufferedRequest;\n    } else {\n      state.bufferedRequest = state.lastBufferedRequest;\n    }\n  } else {\n    doWrite(stream, state, false, len, chunk, encoding, cb);\n  }\n\n  return ret;\n}\n\nfunction doWrite(stream, state, writev, len, chunk, encoding, cb) {\n  state.writelen = len;\n  state.writecb = cb;\n  state.writing = true;\n  state.sync = true;\n  if (writev)\n    stream._writev(chunk, state.onwrite);\n  else\n    stream._write(chunk, encoding, state.onwrite);\n  state.sync = false;\n}\n\nfunction onwriteError(stream, state, sync, er, cb) {\n  --state.pendingcb;\n  if (sync)\n    processNextTick(cb, er);\n  else\n    cb(er);\n\n  stream._writableState.errorEmitted = true;\n  stream.emit('error', er);\n}\n\nfunction onwriteStateUpdate(state) {\n  state.writing = false;\n  state.writecb = null;\n  state.length -= state.writelen;\n  state.writelen = 0;\n}\n\nfunction onwrite(stream, er) {\n  var state = stream._writableState;\n  var sync = state.sync;\n  var cb = state.writecb;\n\n  onwriteStateUpdate(state);\n\n  if (er)\n    onwriteError(stream, state, sync, er, cb);\n  else {\n    // Check if we're actually ready to finish, but don't emit yet\n    var finished = needFinish(state);\n\n    if (!finished &&\n        !state.corked &&\n        !state.bufferProcessing &&\n        state.bufferedRequest) {\n      clearBuffer(stream, state);\n    }\n\n    if (sync) {\n      processNextTick(afterWrite, stream, state, finished, cb);\n    } else {\n      afterWrite(stream, state, finished, cb);\n    }\n  }\n}\n\nfunction afterWrite(stream, state, finished, cb) {\n  if (!finished)\n    onwriteDrain(stream, state);\n  state.pendingcb--;\n  cb();\n  finishMaybe(stream, state);\n}\n\n// Must force callback to be called on nextTick, so that we don't\n// emit 'drain' before the write() consumer gets the 'false' return\n// value, and has a chance to attach a 'drain' listener.\nfunction onwriteDrain(stream, state) {\n  if (state.length === 0 && state.needDrain) {\n    state.needDrain = false;\n    stream.emit('drain');\n  }\n}\n\n\n// if there's something in the buffer waiting, then process it\nfunction clearBuffer(stream, state) {\n  state.bufferProcessing = true;\n  var entry = state.bufferedRequest;\n\n  if (stream._writev && entry && entry.next) {\n    // Fast case, write everything using _writev()\n    var buffer = [];\n    var cbs = [];\n    while (entry) {\n      cbs.push(entry.callback);\n      buffer.push(entry);\n      entry = entry.next;\n    }\n\n    // count the one we are adding, as well.\n    // TODO(isaacs) clean this up\n    state.pendingcb++;\n    state.lastBufferedRequest = null;\n    doWrite(stream, state, true, state.length, buffer, '', function(err) {\n      for (var i = 0; i < cbs.length; i++) {\n        state.pendingcb--;\n        cbs[i](err);\n      }\n    });\n\n    // Clear buffer\n  } else {\n    // Slow case, write chunks one-by-one\n    while (entry) {\n      var chunk = entry.chunk;\n      var encoding = entry.encoding;\n      var cb = entry.callback;\n      var len = state.objectMode ? 1 : chunk.length;\n\n      doWrite(stream, state, false, len, chunk, encoding, cb);\n      entry = entry.next;\n      // if we didn't call the onwrite immediately, then\n      // it means that we need to wait until it does.\n      // also, that means that the chunk and cb are currently\n      // being processed, so move the buffer counter past them.\n      if (state.writing) {\n        break;\n      }\n    }\n\n    if (entry === null)\n      state.lastBufferedRequest = null;\n  }\n  state.bufferedRequest = entry;\n  state.bufferProcessing = false;\n}\n\nWritable.prototype._write = function(chunk, encoding, cb) {\n  cb(new Error('not implemented'));\n};\n\nWritable.prototype._writev = null;\n\nWritable.prototype.end = function(chunk, encoding, cb) {\n  var state = this._writableState;\n\n  if (typeof chunk === 'function') {\n    cb = chunk;\n    chunk = null;\n    encoding = null;\n  } else if (typeof encoding === 'function') {\n    cb = encoding;\n    encoding = null;\n  }\n\n  if (chunk !== null && chunk !== undefined)\n    this.write(chunk, encoding);\n\n  // .end() fully uncorks\n  if (state.corked) {\n    state.corked = 1;\n    this.uncork();\n  }\n\n  // ignore unnecessary end() calls.\n  if (!state.ending && !state.finished)\n    endWritable(this, state, cb);\n};\n\n\nfunction needFinish(state) {\n  return (state.ending &&\n          state.length === 0 &&\n          state.bufferedRequest === null &&\n          !state.finished &&\n          !state.writing);\n}\n\nfunction prefinish(stream, state) {\n  if (!state.prefinished) {\n    state.prefinished = true;\n    stream.emit('prefinish');\n  }\n}\n\nfunction finishMaybe(stream, state) {\n  var need = needFinish(state);\n  if (need) {\n    if (state.pendingcb === 0) {\n      prefinish(stream, state);\n      state.finished = true;\n      stream.emit('finish');\n    } else {\n      prefinish(stream, state);\n    }\n  }\n  return need;\n}\n\nfunction endWritable(stream, state, cb) {\n  state.ending = true;\n  finishMaybe(stream, state);\n  if (cb) {\n    if (state.finished)\n      processNextTick(cb);\n    else\n      stream.once('finish', cb);\n  }\n  state.ended = true;\n}\n","// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n// NOTE: These type checking functions intentionally don't use `instanceof`\n// because it is fragile and can be easily faked with `Object.create()`.\n\nfunction isArray(arg) {\n  if (Array.isArray) {\n    return Array.isArray(arg);\n  }\n  return objectToString(arg) === '[object Array]';\n}\nexports.isArray = isArray;\n\nfunction isBoolean(arg) {\n  return typeof arg === 'boolean';\n}\nexports.isBoolean = isBoolean;\n\nfunction isNull(arg) {\n  return arg === null;\n}\nexports.isNull = isNull;\n\nfunction isNullOrUndefined(arg) {\n  return arg == null;\n}\nexports.isNullOrUndefined = isNullOrUndefined;\n\nfunction isNumber(arg) {\n  return typeof arg === 'number';\n}\nexports.isNumber = isNumber;\n\nfunction isString(arg) {\n  return typeof arg === 'string';\n}\nexports.isString = isString;\n\nfunction isSymbol(arg) {\n  return typeof arg === 'symbol';\n}\nexports.isSymbol = isSymbol;\n\nfunction isUndefined(arg) {\n  return arg === void 0;\n}\nexports.isUndefined = isUndefined;\n\nfunction isRegExp(re) {\n  return objectToString(re) === '[object RegExp]';\n}\nexports.isRegExp = isRegExp;\n\nfunction isObject(arg) {\n  return typeof arg === 'object' && arg !== null;\n}\nexports.isObject = isObject;\n\nfunction isDate(d) {\n  return objectToString(d) === '[object Date]';\n}\nexports.isDate = isDate;\n\nfunction isError(e) {\n  return (objectToString(e) === '[object Error]' || e instanceof Error);\n}\nexports.isError = isError;\n\nfunction isFunction(arg) {\n  return typeof arg === 'function';\n}\nexports.isFunction = isFunction;\n\nfunction isPrimitive(arg) {\n  return arg === null ||\n         typeof arg === 'boolean' ||\n         typeof arg === 'number' ||\n         typeof arg === 'string' ||\n         typeof arg === 'symbol' ||  // ES6 symbol\n         typeof arg === 'undefined';\n}\nexports.isPrimitive = isPrimitive;\n\nexports.isBuffer = Buffer.isBuffer;\n\nfunction objectToString(o) {\n  return Object.prototype.toString.call(o);\n}\n","'use strict';\n\nif (!process.version ||\n    process.version.indexOf('v0.') === 0 ||\n    process.version.indexOf('v1.') === 0 && process.version.indexOf('v1.8.') !== 0) {\n  module.exports = nextTick;\n} else {\n  module.exports = process.nextTick;\n}\n\nfunction nextTick(fn) {\n  var args = new Array(arguments.length - 1);\n  var i = 0;\n  while (i < args.length) {\n    args[i++] = arguments[i];\n  }\n  process.nextTick(function afterTick() {\n    fn.apply(null, args);\n  });\n}\n","\n/**\n * Module exports.\n */\n\nmodule.exports = deprecate;\n\n/**\n * Mark that a method should not be used.\n * Returns a modified function which warns once by default.\n *\n * If `localStorage.noDeprecation = true` is set, then it is a no-op.\n *\n * If `localStorage.throwDeprecation = true` is set, then deprecated functions\n * will throw an Error when invoked.\n *\n * If `localStorage.traceDeprecation = true` is set, then deprecated functions\n * will invoke `console.trace()` instead of `console.error()`.\n *\n * @param {Function} fn - the function to deprecate\n * @param {String} msg - the string to print to the console when `fn` is invoked\n * @returns {Function} a new \"deprecated\" version of `fn`\n * @api public\n */\n\nfunction deprecate (fn, msg) {\n  if (config('noDeprecation')) {\n    return fn;\n  }\n\n  var warned = false;\n  function deprecated() {\n    if (!warned) {\n      if (config('throwDeprecation')) {\n        throw new Error(msg);\n      } else if (config('traceDeprecation')) {\n        console.trace(msg);\n      } else {\n        console.warn(msg);\n      }\n      warned = true;\n    }\n    return fn.apply(this, arguments);\n  }\n\n  return deprecated;\n}\n\n/**\n * Checks `localStorage` for boolean values for the given `name`.\n *\n * @param {String} name\n * @returns {Boolean}\n * @api private\n */\n\nfunction config (name) {\n  // accessing global.localStorage can trigger a DOMException in sandboxed iframes\n  try {\n    if (!global.localStorage) return false;\n  } catch (_) {\n    return false;\n  }\n  var val = global.localStorage[name];\n  if (null == val) return false;\n  return String(val).toLowerCase() === 'true';\n}\n","module.exports = require(\"./lib/_stream_passthrough.js\")\n","var Stream = (function (){\n  try {\n    return require('st' + 'ream'); // hack to fix a circular dependency issue when used with browserify\n  } catch(_){}\n}());\nexports = module.exports = require('./lib/_stream_readable.js');\nexports.Stream = Stream || exports;\nexports.Readable = exports;\nexports.Writable = require('./lib/_stream_writable.js');\nexports.Duplex = require('./lib/_stream_duplex.js');\nexports.Transform = require('./lib/_stream_transform.js');\nexports.PassThrough = require('./lib/_stream_passthrough.js');\n","module.exports = require(\"./lib/_stream_transform.js\")\n","module.exports = require(\"./lib/_stream_writable.js\")\n","// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\nmodule.exports = Stream;\n\nvar EE = require('events').EventEmitter;\nvar inherits = require('inherits');\n\ninherits(Stream, EE);\nStream.Readable = require('readable-stream/readable.js');\nStream.Writable = require('readable-stream/writable.js');\nStream.Duplex = require('readable-stream/duplex.js');\nStream.Transform = require('readable-stream/transform.js');\nStream.PassThrough = require('readable-stream/passthrough.js');\n\n// Backwards-compat with node 0.4.x\nStream.Stream = Stream;\n\n\n\n// old-style streams.  Note that the pipe method (the only relevant\n// part of this class) is overridden in the Readable class.\n\nfunction Stream() {\n  EE.call(this);\n}\n\nStream.prototype.pipe = function(dest, options) {\n  var source = this;\n\n  function ondata(chunk) {\n    if (dest.writable) {\n      if (false === dest.write(chunk) && source.pause) {\n        source.pause();\n      }\n    }\n  }\n\n  source.on('data', ondata);\n\n  function ondrain() {\n    if (source.readable && source.resume) {\n      source.resume();\n    }\n  }\n\n  dest.on('drain', ondrain);\n\n  // If the 'end' option is not supplied, dest.end() will be called when\n  // source gets the 'end' or 'close' events.  Only dest.end() once.\n  if (!dest._isStdio && (!options || options.end !== false)) {\n    source.on('end', onend);\n    source.on('close', onclose);\n  }\n\n  var didOnEnd = false;\n  function onend() {\n    if (didOnEnd) return;\n    didOnEnd = true;\n\n    dest.end();\n  }\n\n\n  function onclose() {\n    if (didOnEnd) return;\n    didOnEnd = true;\n\n    if (typeof dest.destroy === 'function') dest.destroy();\n  }\n\n  // don't leave dangling pipes when there are errors.\n  function onerror(er) {\n    cleanup();\n    if (EE.listenerCount(this, 'error') === 0) {\n      throw er; // Unhandled stream error in pipe.\n    }\n  }\n\n  source.on('error', onerror);\n  dest.on('error', onerror);\n\n  // remove all the event listeners that were added.\n  function cleanup() {\n    source.removeListener('data', ondata);\n    dest.removeListener('drain', ondrain);\n\n    source.removeListener('end', onend);\n    source.removeListener('close', onclose);\n\n    source.removeListener('error', onerror);\n    dest.removeListener('error', onerror);\n\n    source.removeListener('end', cleanup);\n    source.removeListener('close', cleanup);\n\n    dest.removeListener('close', cleanup);\n  }\n\n  source.on('end', cleanup);\n  source.on('close', cleanup);\n\n  dest.on('close', cleanup);\n\n  dest.emit('pipe', source);\n\n  // Allow for unix-like usage: A.pipe(B).pipe(C)\n  return dest;\n};\n","var ClientRequest = require('./lib/request')\nvar extend = require('xtend')\nvar statusCodes = require('builtin-status-codes')\nvar url = require('url')\n\nvar http = exports\n\nhttp.request = function (opts, cb) {\n\tif (typeof opts === 'string')\n\t\topts = url.parse(opts)\n\telse\n\t\topts = extend(opts)\n\n\tvar protocol = opts.protocol || ''\n\tvar host = opts.hostname || opts.host\n\tvar port = opts.port\n\tvar path = opts.path || '/'\n\n\t// Necessary for IPv6 addresses\n\tif (host && host.indexOf(':') !== -1)\n\t\thost = '[' + host + ']'\n\n\t// This may be a relative url. The browser should always be able to interpret it correctly.\n\topts.url = (host ? (protocol + '//' + host) : '') + (port ? ':' + port : '') + path\n\topts.method = (opts.method || 'GET').toUpperCase()\n\topts.headers = opts.headers || {}\n\n\t// Also valid opts.auth, opts.mode\n\n\tvar req = new ClientRequest(opts)\n\tif (cb)\n\t\treq.on('response', cb)\n\treturn req\n}\n\nhttp.get = function get (opts, cb) {\n\tvar req = http.request(opts, cb)\n\treq.end()\n\treturn req\n}\n\nhttp.Agent = function () {}\nhttp.Agent.defaultMaxSockets = 4\n\nhttp.STATUS_CODES = statusCodes\n\nhttp.METHODS = [\n\t'CHECKOUT',\n\t'CONNECT',\n\t'COPY',\n\t'DELETE',\n\t'GET',\n\t'HEAD',\n\t'LOCK',\n\t'M-SEARCH',\n\t'MERGE',\n\t'MKACTIVITY',\n\t'MKCOL',\n\t'MOVE',\n\t'NOTIFY',\n\t'OPTIONS',\n\t'PATCH',\n\t'POST',\n\t'PROPFIND',\n\t'PROPPATCH',\n\t'PURGE',\n\t'PUT',\n\t'REPORT',\n\t'SEARCH',\n\t'SUBSCRIBE',\n\t'TRACE',\n\t'UNLOCK',\n\t'UNSUBSCRIBE'\n]","exports.fetch = isFunction(global.fetch) && isFunction(global.ReadableByteStream)\n\nexports.blobConstructor = false\ntry {\n\tnew Blob([new ArrayBuffer(1)])\n\texports.blobConstructor = true\n} catch (e) {}\n\nvar xhr = new global.XMLHttpRequest()\n// If location.host is empty, e.g. if this page/worker was loaded\n// from a Blob, then use example.com to avoid an error\nxhr.open('GET', global.location.host ? '/' : 'https://example.com')\n\nfunction checkTypeSupport (type) {\n\ttry {\n\t\txhr.responseType = type\n\t\treturn xhr.responseType === type\n\t} catch (e) {}\n\treturn false\n}\n\n// For some strange reason, Safari 7.0 reports typeof global.ArrayBuffer === 'object'.\n// Safari 7.1 appears to have fixed this bug.\nvar haveArrayBuffer = typeof global.ArrayBuffer !== 'undefined'\nvar haveSlice = haveArrayBuffer && isFunction(global.ArrayBuffer.prototype.slice)\n\nexports.arraybuffer = haveArrayBuffer && checkTypeSupport('arraybuffer')\n// These next two tests unavoidably show warnings in Chrome. Since fetch will always\n// be used if it's available, just return false for these to avoid the warnings.\nexports.msstream = !exports.fetch && haveSlice && checkTypeSupport('ms-stream')\nexports.mozchunkedarraybuffer = !exports.fetch && haveArrayBuffer &&\n\tcheckTypeSupport('moz-chunked-arraybuffer')\nexports.overrideMimeType = isFunction(xhr.overrideMimeType)\nexports.vbArray = isFunction(global.VBArray)\n\nfunction isFunction (value) {\n  return typeof value === 'function'\n}\n\nxhr = null // Help gc\n","// var Base64 = require('Base64')\nvar capability = require('./capability')\nvar inherits = require('inherits')\nvar response = require('./response')\nvar stream = require('stream')\n\nvar IncomingMessage = response.IncomingMessage\nvar rStates = response.readyStates\n\nfunction decideMode (preferBinary) {\n\tif (capability.fetch) {\n\t\treturn 'fetch'\n\t} else if (capability.mozchunkedarraybuffer) {\n\t\treturn 'moz-chunked-arraybuffer'\n\t} else if (capability.msstream) {\n\t\treturn 'ms-stream'\n\t} else if (capability.arraybuffer && preferBinary) {\n\t\treturn 'arraybuffer'\n\t} else if (capability.vbArray && preferBinary) {\n\t\treturn 'text:vbarray'\n\t} else {\n\t\treturn 'text'\n\t}\n}\n\nvar ClientRequest = module.exports = function (opts) {\n\tvar self = this\n\tstream.Writable.call(self)\n\n\tself._opts = opts\n\tself._body = []\n\tself._headers = {}\n\tif (opts.auth)\n\t\tself.setHeader('Authorization', 'Basic ' + new Buffer(opts.auth).toString('base64'))\n\tObject.keys(opts.headers).forEach(function (name) {\n\t\tself.setHeader(name, opts.headers[name])\n\t})\n\n\tvar preferBinary\n\tif (opts.mode === 'prefer-streaming') {\n\t\t// If streaming is a high priority but binary compatibility and\n\t\t// the accuracy of the 'content-type' header aren't\n\t\tpreferBinary = false\n\t} else if (opts.mode === 'allow-wrong-content-type') {\n\t\t// If streaming is more important than preserving the 'content-type' header\n\t\tpreferBinary = !capability.overrideMimeType\n\t} else if (!opts.mode || opts.mode === 'default' || opts.mode === 'prefer-fast') {\n\t\t// Use binary if text streaming may corrupt data or the content-type header, or for speed\n\t\tpreferBinary = true\n\t} else {\n\t\tthrow new Error('Invalid value for opts.mode')\n\t}\n\tself._mode = decideMode(preferBinary)\n\n\tself.on('finish', function () {\n\t\tself._onFinish()\n\t})\n}\n\ninherits(ClientRequest, stream.Writable)\n\nClientRequest.prototype.setHeader = function (name, value) {\n\tvar self = this\n\tvar lowerName = name.toLowerCase()\n\t// This check is not necessary, but it prevents warnings from browsers about setting unsafe\n\t// headers. To be honest I'm not entirely sure hiding these warnings is a good thing, but\n\t// http-browserify did it, so I will too.\n\tif (unsafeHeaders.indexOf(lowerName) !== -1)\n\t\treturn\n\n\tself._headers[lowerName] = {\n\t\tname: name,\n\t\tvalue: value\n\t}\n}\n\nClientRequest.prototype.getHeader = function (name) {\n\tvar self = this\n\treturn self._headers[name.toLowerCase()].value\n}\n\nClientRequest.prototype.removeHeader = function (name) {\n\tvar self = this\n\tdelete self._headers[name.toLowerCase()]\n}\n\nClientRequest.prototype._onFinish = function () {\n\tvar self = this\n\n\tif (self._destroyed)\n\t\treturn\n\tvar opts = self._opts\n\n\tvar headersObj = self._headers\n\tvar body\n\tif (opts.method === 'POST' || opts.method === 'PUT' || opts.method === 'PATCH') {\n\t\tif (capability.blobConstructor) {\n\t\t\tbody = new global.Blob(self._body.map(function (buffer) {\n\t\t\t\treturn buffer.toArrayBuffer()\n\t\t\t}), {\n\t\t\t\ttype: (headersObj['content-type'] || {}).value || ''\n\t\t\t})\n\t\t} else {\n\t\t\t// get utf8 string\n\t\t\tbody = Buffer.concat(self._body).toString()\n\t\t}\n\t}\n\n\tif (self._mode === 'fetch') {\n\t\tvar headers = Object.keys(headersObj).map(function (name) {\n\t\t\treturn [headersObj[name].name, headersObj[name].value]\n\t\t})\n\n\t\tglobal.fetch(self._opts.url, {\n\t\t\tmethod: self._opts.method,\n\t\t\theaders: headers,\n\t\t\tbody: body,\n\t\t\tmode: 'cors',\n\t\t\tcredentials: opts.withCredentials ? 'include' : 'same-origin'\n\t\t}).then(function (response) {\n\t\t\tself._fetchResponse = response\n\t\t\tself._connect()\n\t\t}, function (reason) {\n\t\t\tself.emit('error', reason)\n\t\t})\n\t} else {\n\t\tvar xhr = self._xhr = new global.XMLHttpRequest()\n\t\ttry {\n\t\t\txhr.open(self._opts.method, self._opts.url, true)\n\t\t} catch (err) {\n\t\t\tprocess.nextTick(function () {\n\t\t\t\tself.emit('error', err)\n\t\t\t})\n\t\t\treturn\n\t\t}\n\n\t\t// Can't set responseType on really old browsers\n\t\tif ('responseType' in xhr)\n\t\t\txhr.responseType = self._mode.split(':')[0]\n\n\t\tif ('withCredentials' in xhr)\n\t\t\txhr.withCredentials = !!opts.withCredentials\n\n\t\tif (self._mode === 'text' && 'overrideMimeType' in xhr)\n\t\t\txhr.overrideMimeType('text/plain; charset=x-user-defined')\n\n\t\tObject.keys(headersObj).forEach(function (name) {\n\t\t\txhr.setRequestHeader(headersObj[name].name, headersObj[name].value)\n\t\t})\n\n\t\tself._response = null\n\t\txhr.onreadystatechange = function () {\n\t\t\tswitch (xhr.readyState) {\n\t\t\t\tcase rStates.LOADING:\n\t\t\t\tcase rStates.DONE:\n\t\t\t\t\tself._onXHRProgress()\n\t\t\t\t\tbreak\n\t\t\t}\n\t\t}\n\t\t// Necessary for streaming in Firefox, since xhr.response is ONLY defined\n\t\t// in onprogress, not in onreadystatechange with xhr.readyState = 3\n\t\tif (self._mode === 'moz-chunked-arraybuffer') {\n\t\t\txhr.onprogress = function () {\n\t\t\t\tself._onXHRProgress()\n\t\t\t}\n\t\t}\n\n\t\txhr.onerror = function () {\n\t\t\tif (self._destroyed)\n\t\t\t\treturn\n\t\t\tself.emit('error', new Error('XHR error'))\n\t\t}\n\n\t\ttry {\n\t\t\txhr.send(body)\n\t\t} catch (err) {\n\t\t\tprocess.nextTick(function () {\n\t\t\t\tself.emit('error', err)\n\t\t\t})\n\t\t\treturn\n\t\t}\n\t}\n}\n\n/**\n * Checks if xhr.status is readable. Even though the spec says it should\n * be available in readyState 3, accessing it throws an exception in IE8\n */\nfunction statusValid (xhr) {\n\ttry {\n\t\treturn (xhr.status !== null)\n\t} catch (e) {\n\t\treturn false\n\t}\n}\n\nClientRequest.prototype._onXHRProgress = function () {\n\tvar self = this\n\n\tif (!statusValid(self._xhr) || self._destroyed)\n\t\treturn\n\n\tif (!self._response)\n\t\tself._connect()\n\n\tself._response._onXHRProgress()\n}\n\nClientRequest.prototype._connect = function () {\n\tvar self = this\n\n\tif (self._destroyed)\n\t\treturn\n\n\tself._response = new IncomingMessage(self._xhr, self._fetchResponse, self._mode)\n\tself.emit('response', self._response)\n}\n\nClientRequest.prototype._write = function (chunk, encoding, cb) {\n\tvar self = this\n\n\tself._body.push(chunk)\n\tcb()\n}\n\nClientRequest.prototype.abort = ClientRequest.prototype.destroy = function () {\n\tvar self = this\n\tself._destroyed = true\n\tif (self._response)\n\t\tself._response._destroyed = true\n\tif (self._xhr)\n\t\tself._xhr.abort()\n\t// Currently, there isn't a way to truly abort a fetch.\n\t// If you like bikeshedding, see https://github.com/whatwg/fetch/issues/27\n}\n\nClientRequest.prototype.end = function (data, encoding, cb) {\n\tvar self = this\n\tif (typeof data === 'function') {\n\t\tcb = data\n\t\tdata = undefined\n\t}\n\n\tstream.Writable.prototype.end.call(self, data, encoding, cb)\n}\n\nClientRequest.prototype.flushHeaders = function () {}\nClientRequest.prototype.setTimeout = function () {}\nClientRequest.prototype.setNoDelay = function () {}\nClientRequest.prototype.setSocketKeepAlive = function () {}\n\n// Taken from http://www.w3.org/TR/XMLHttpRequest/#the-setrequestheader%28%29-method\nvar unsafeHeaders = [\n\t'accept-charset',\n\t'accept-encoding',\n\t'access-control-request-headers',\n\t'access-control-request-method',\n\t'connection',\n\t'content-length',\n\t'cookie',\n\t'cookie2',\n\t'date',\n\t'dnt',\n\t'expect',\n\t'host',\n\t'keep-alive',\n\t'origin',\n\t'referer',\n\t'te',\n\t'trailer',\n\t'transfer-encoding',\n\t'upgrade',\n\t'user-agent',\n\t'via'\n]\n","var capability = require('./capability')\nvar inherits = require('inherits')\nvar stream = require('stream')\n\nvar rStates = exports.readyStates = {\n\tUNSENT: 0,\n\tOPENED: 1,\n\tHEADERS_RECEIVED: 2,\n\tLOADING: 3,\n\tDONE: 4\n}\n\nvar IncomingMessage = exports.IncomingMessage = function (xhr, response, mode) {\n\tvar self = this\n\tstream.Readable.call(self)\n\n\tself._mode = mode\n\tself.headers = {}\n\tself.rawHeaders = []\n\tself.trailers = {}\n\tself.rawTrailers = []\n\n\t// Fake the 'close' event, but only once 'end' fires\n\tself.on('end', function () {\n\t\t// The nextTick is necessary to prevent the 'request' module from causing an infinite loop\n\t\tprocess.nextTick(function () {\n\t\t\tself.emit('close')\n\t\t})\n\t})\n\n\tif (mode === 'fetch') {\n\t\tself._fetchResponse = response\n\n\t\tself.statusCode = response.status\n\t\tself.statusMessage = response.statusText\n\t\t// backwards compatible version of for (<item> of <iterable>):\n\t\t// for (var <item>,_i,_it = <iterable>[Symbol.iterator](); <item> = (_i = _it.next()).value,!_i.done;)\n\t\tfor (var header, _i, _it = response.headers[Symbol.iterator](); header = (_i = _it.next()).value, !_i.done;) {\n\t\t\tself.headers[header[0].toLowerCase()] = header[1]\n\t\t\tself.rawHeaders.push(header[0], header[1])\n\t\t}\n\n\t\t// TODO: this doesn't respect backpressure. Once WritableStream is available, this can be fixed\n\t\tvar reader = response.body.getReader()\n\t\tfunction read () {\n\t\t\treader.read().then(function (result) {\n\t\t\t\tif (self._destroyed)\n\t\t\t\t\treturn\n\t\t\t\tif (result.done) {\n\t\t\t\t\tself.push(null)\n\t\t\t\t\treturn\n\t\t\t\t}\n\t\t\t\tself.push(new Buffer(result.value))\n\t\t\t\tread()\n\t\t\t})\n\t\t}\n\t\tread()\n\n\t} else {\n\t\tself._xhr = xhr\n\t\tself._pos = 0\n\n\t\tself.statusCode = xhr.status\n\t\tself.statusMessage = xhr.statusText\n\t\tvar headers = xhr.getAllResponseHeaders().split(/\\r?\\n/)\n\t\theaders.forEach(function (header) {\n\t\t\tvar matches = header.match(/^([^:]+):\\s*(.*)/)\n\t\t\tif (matches) {\n\t\t\t\tvar key = matches[1].toLowerCase()\n\t\t\t\tif (self.headers[key] !== undefined)\n\t\t\t\t\tself.headers[key] += ', ' + matches[2]\n\t\t\t\telse\n\t\t\t\t\tself.headers[key] = matches[2]\n\t\t\t\tself.rawHeaders.push(matches[1], matches[2])\n\t\t\t}\n\t\t})\n\n\t\tself._charset = 'x-user-defined'\n\t\tif (!capability.overrideMimeType) {\n\t\t\tvar mimeType = self.rawHeaders['mime-type']\n\t\t\tif (mimeType) {\n\t\t\t\tvar charsetMatch = mimeType.match(/;\\s*charset=([^;])(;|$)/)\n\t\t\t\tif (charsetMatch) {\n\t\t\t\t\tself._charset = charsetMatch[1].toLowerCase()\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (!self._charset)\n\t\t\t\tself._charset = 'utf-8' // best guess\n\t\t}\n\t}\n}\n\ninherits(IncomingMessage, stream.Readable)\n\nIncomingMessage.prototype._read = function () {}\n\nIncomingMessage.prototype._onXHRProgress = function () {\n\tvar self = this\n\n\tvar xhr = self._xhr\n\n\tvar response = null\n\tswitch (self._mode) {\n\t\tcase 'text:vbarray': // For IE9\n\t\t\tif (xhr.readyState !== rStates.DONE)\n\t\t\t\tbreak\n\t\t\ttry {\n\t\t\t\t// This fails in IE8\n\t\t\t\tresponse = new global.VBArray(xhr.responseBody).toArray()\n\t\t\t} catch (e) {}\n\t\t\tif (response !== null) {\n\t\t\t\tself.push(new Buffer(response))\n\t\t\t\tbreak\n\t\t\t}\n\t\t\t// Falls through in IE8\t\n\t\tcase 'text':\n\t\t\ttry { // This will fail when readyState = 3 in IE9. Switch mode and wait for readyState = 4\n\t\t\t\tresponse = xhr.responseText\n\t\t\t} catch (e) {\n\t\t\t\tself._mode = 'text:vbarray'\n\t\t\t\tbreak\n\t\t\t}\n\t\t\tif (response.length > self._pos) {\n\t\t\t\tvar newData = response.substr(self._pos)\n\t\t\t\tif (self._charset === 'x-user-defined') {\n\t\t\t\t\tvar buffer = new Buffer(newData.length)\n\t\t\t\t\tfor (var i = 0; i < newData.length; i++)\n\t\t\t\t\t\tbuffer[i] = newData.charCodeAt(i) & 0xff\n\n\t\t\t\t\tself.push(buffer)\n\t\t\t\t} else {\n\t\t\t\t\tself.push(newData, self._charset)\n\t\t\t\t}\n\t\t\t\tself._pos = response.length\n\t\t\t}\n\t\t\tbreak\n\t\tcase 'arraybuffer':\n\t\t\tif (xhr.readyState !== rStates.DONE)\n\t\t\t\tbreak\n\t\t\tresponse = xhr.response\n\t\t\tself.push(new Buffer(new Uint8Array(response)))\n\t\t\tbreak\n\t\tcase 'moz-chunked-arraybuffer': // take whole\n\t\t\tresponse = xhr.response\n\t\t\tif (xhr.readyState !== rStates.LOADING || !response)\n\t\t\t\tbreak\n\t\t\tself.push(new Buffer(new Uint8Array(response)))\n\t\t\tbreak\n\t\tcase 'ms-stream':\n\t\t\tresponse = xhr.response\n\t\t\tif (xhr.readyState !== rStates.LOADING)\n\t\t\t\tbreak\n\t\t\tvar reader = new global.MSStreamReader()\n\t\t\treader.onprogress = function () {\n\t\t\t\tif (reader.result.byteLength > self._pos) {\n\t\t\t\t\tself.push(new Buffer(new Uint8Array(reader.result.slice(self._pos))))\n\t\t\t\t\tself._pos = reader.result.byteLength\n\t\t\t\t}\n\t\t\t}\n\t\t\treader.onload = function () {\n\t\t\t\tself.push(null)\n\t\t\t}\n\t\t\t// reader.onerror = ??? // TODO: this\n\t\t\treader.readAsArrayBuffer(response)\n\t\t\tbreak\n\t}\n\n\t// The ms-stream case handles end separately in reader.onload()\n\tif (self._xhr.readyState === rStates.DONE && self._mode !== 'ms-stream') {\n\t\tself.push(null)\n\t}\n}\n","module.exports = {\n  \"100\": \"Continue\",\n  \"101\": \"Switching Protocols\",\n  \"102\": \"Processing\",\n  \"200\": \"OK\",\n  \"201\": \"Created\",\n  \"202\": \"Accepted\",\n  \"203\": \"Non-Authoritative Information\",\n  \"204\": \"No Content\",\n  \"205\": \"Reset Content\",\n  \"206\": \"Partial Content\",\n  \"207\": \"Multi-Status\",\n  \"300\": \"Multiple Choices\",\n  \"301\": \"Moved Permanently\",\n  \"302\": \"Moved Temporarily\",\n  \"303\": \"See Other\",\n  \"304\": \"Not Modified\",\n  \"305\": \"Use Proxy\",\n  \"307\": \"Temporary Redirect\",\n  \"308\": \"Permanent Redirect\",\n  \"400\": \"Bad Request\",\n  \"401\": \"Unauthorized\",\n  \"402\": \"Payment Required\",\n  \"403\": \"Forbidden\",\n  \"404\": \"Not Found\",\n  \"405\": \"Method Not Allowed\",\n  \"406\": \"Not Acceptable\",\n  \"407\": \"Proxy Authentication Required\",\n  \"408\": \"Request Time-out\",\n  \"409\": \"Conflict\",\n  \"410\": \"Gone\",\n  \"411\": \"Length Required\",\n  \"412\": \"Precondition Failed\",\n  \"413\": \"Request Entity Too Large\",\n  \"414\": \"Request-URI Too Large\",\n  \"415\": \"Unsupported Media Type\",\n  \"416\": \"Requested Range Not Satisfiable\",\n  \"417\": \"Expectation Failed\",\n  \"418\": \"I'm a teapot\",\n  \"422\": \"Unprocessable Entity\",\n  \"423\": \"Locked\",\n  \"424\": \"Failed Dependency\",\n  \"425\": \"Unordered Collection\",\n  \"426\": \"Upgrade Required\",\n  \"428\": \"Precondition Required\",\n  \"429\": \"Too Many Requests\",\n  \"431\": \"Request Header Fields Too Large\",\n  \"500\": \"Internal Server Error\",\n  \"501\": \"Not Implemented\",\n  \"502\": \"Bad Gateway\",\n  \"503\": \"Service Unavailable\",\n  \"504\": \"Gateway Time-out\",\n  \"505\": \"HTTP Version Not Supported\",\n  \"506\": \"Variant Also Negotiates\",\n  \"507\": \"Insufficient Storage\",\n  \"509\": \"Bandwidth Limit Exceeded\",\n  \"510\": \"Not Extended\",\n  \"511\": \"Network Authentication Required\"\n}\n","// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\nvar Buffer = require('buffer').Buffer;\n\nvar isBufferEncoding = Buffer.isEncoding\n  || function(encoding) {\n       switch (encoding && encoding.toLowerCase()) {\n         case 'hex': case 'utf8': case 'utf-8': case 'ascii': case 'binary': case 'base64': case 'ucs2': case 'ucs-2': case 'utf16le': case 'utf-16le': case 'raw': return true;\n         default: return false;\n       }\n     }\n\n\nfunction assertEncoding(encoding) {\n  if (encoding && !isBufferEncoding(encoding)) {\n    throw new Error('Unknown encoding: ' + encoding);\n  }\n}\n\n// StringDecoder provides an interface for efficiently splitting a series of\n// buffers into a series of JS strings without breaking apart multi-byte\n// characters. CESU-8 is handled as part of the UTF-8 encoding.\n//\n// @TODO Handling all encodings inside a single object makes it very difficult\n// to reason about this code, so it should be split up in the future.\n// @TODO There should be a utf8-strict encoding that rejects invalid UTF-8 code\n// points as used by CESU-8.\nvar StringDecoder = exports.StringDecoder = function(encoding) {\n  this.encoding = (encoding || 'utf8').toLowerCase().replace(/[-_]/, '');\n  assertEncoding(encoding);\n  switch (this.encoding) {\n    case 'utf8':\n      // CESU-8 represents each of Surrogate Pair by 3-bytes\n      this.surrogateSize = 3;\n      break;\n    case 'ucs2':\n    case 'utf16le':\n      // UTF-16 represents each of Surrogate Pair by 2-bytes\n      this.surrogateSize = 2;\n      this.detectIncompleteChar = utf16DetectIncompleteChar;\n      break;\n    case 'base64':\n      // Base-64 stores 3 bytes in 4 chars, and pads the remainder.\n      this.surrogateSize = 3;\n      this.detectIncompleteChar = base64DetectIncompleteChar;\n      break;\n    default:\n      this.write = passThroughWrite;\n      return;\n  }\n\n  // Enough space to store all bytes of a single character. UTF-8 needs 4\n  // bytes, but CESU-8 may require up to 6 (3 bytes per surrogate).\n  this.charBuffer = new Buffer(6);\n  // Number of bytes received for the current incomplete multi-byte character.\n  this.charReceived = 0;\n  // Number of bytes expected for the current incomplete multi-byte character.\n  this.charLength = 0;\n};\n\n\n// write decodes the given buffer and returns it as JS string that is\n// guaranteed to not contain any partial multi-byte characters. Any partial\n// character found at the end of the buffer is buffered up, and will be\n// returned when calling write again with the remaining bytes.\n//\n// Note: Converting a Buffer containing an orphan surrogate to a String\n// currently works, but converting a String to a Buffer (via `new Buffer`, or\n// Buffer#write) will replace incomplete surrogates with the unicode\n// replacement character. See https://codereview.chromium.org/121173009/ .\nStringDecoder.prototype.write = function(buffer) {\n  var charStr = '';\n  // if our last write ended with an incomplete multibyte character\n  while (this.charLength) {\n    // determine how many remaining bytes this buffer has to offer for this char\n    var available = (buffer.length >= this.charLength - this.charReceived) ?\n        this.charLength - this.charReceived :\n        buffer.length;\n\n    // add the new bytes to the char buffer\n    buffer.copy(this.charBuffer, this.charReceived, 0, available);\n    this.charReceived += available;\n\n    if (this.charReceived < this.charLength) {\n      // still not enough chars in this buffer? wait for more ...\n      return '';\n    }\n\n    // remove bytes belonging to the current character from the buffer\n    buffer = buffer.slice(available, buffer.length);\n\n    // get the character that was split\n    charStr = this.charBuffer.slice(0, this.charLength).toString(this.encoding);\n\n    // CESU-8: lead surrogate (D800-DBFF) is also the incomplete character\n    var charCode = charStr.charCodeAt(charStr.length - 1);\n    if (charCode >= 0xD800 && charCode <= 0xDBFF) {\n      this.charLength += this.surrogateSize;\n      charStr = '';\n      continue;\n    }\n    this.charReceived = this.charLength = 0;\n\n    // if there are no more bytes in this buffer, just emit our char\n    if (buffer.length === 0) {\n      return charStr;\n    }\n    break;\n  }\n\n  // determine and set charLength / charReceived\n  this.detectIncompleteChar(buffer);\n\n  var end = buffer.length;\n  if (this.charLength) {\n    // buffer the incomplete character bytes we got\n    buffer.copy(this.charBuffer, 0, buffer.length - this.charReceived, end);\n    end -= this.charReceived;\n  }\n\n  charStr += buffer.toString(this.encoding, 0, end);\n\n  var end = charStr.length - 1;\n  var charCode = charStr.charCodeAt(end);\n  // CESU-8: lead surrogate (D800-DBFF) is also the incomplete character\n  if (charCode >= 0xD800 && charCode <= 0xDBFF) {\n    var size = this.surrogateSize;\n    this.charLength += size;\n    this.charReceived += size;\n    this.charBuffer.copy(this.charBuffer, size, 0, size);\n    buffer.copy(this.charBuffer, 0, 0, size);\n    return charStr.substring(0, end);\n  }\n\n  // or just emit the charStr\n  return charStr;\n};\n\n// detectIncompleteChar determines if there is an incomplete UTF-8 character at\n// the end of the given buffer. If so, it sets this.charLength to the byte\n// length that character, and sets this.charReceived to the number of bytes\n// that are available for this character.\nStringDecoder.prototype.detectIncompleteChar = function(buffer) {\n  // determine how many bytes we have to check at the end of this buffer\n  var i = (buffer.length >= 3) ? 3 : buffer.length;\n\n  // Figure out if one of the last i bytes of our buffer announces an\n  // incomplete char.\n  for (; i > 0; i--) {\n    var c = buffer[buffer.length - i];\n\n    // See http://en.wikipedia.org/wiki/UTF-8#Description\n\n    // 110XXXXX\n    if (i == 1 && c >> 5 == 0x06) {\n      this.charLength = 2;\n      break;\n    }\n\n    // 1110XXXX\n    if (i <= 2 && c >> 4 == 0x0E) {\n      this.charLength = 3;\n      break;\n    }\n\n    // 11110XXX\n    if (i <= 3 && c >> 3 == 0x1E) {\n      this.charLength = 4;\n      break;\n    }\n  }\n  this.charReceived = i;\n};\n\nStringDecoder.prototype.end = function(buffer) {\n  var res = '';\n  if (buffer && buffer.length)\n    res = this.write(buffer);\n\n  if (this.charReceived) {\n    var cr = this.charReceived;\n    var buf = this.charBuffer;\n    var enc = this.encoding;\n    res += buf.slice(0, cr).toString(enc);\n  }\n\n  return res;\n};\n\nfunction passThroughWrite(buffer) {\n  return buffer.toString(this.encoding);\n}\n\nfunction utf16DetectIncompleteChar(buffer) {\n  this.charReceived = buffer.length % 2;\n  this.charLength = this.charReceived ? 2 : 0;\n}\n\nfunction base64DetectIncompleteChar(buffer) {\n  this.charReceived = buffer.length % 3;\n  this.charLength = this.charReceived ? 3 : 0;\n}\n","// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n'use strict';\n\nvar punycode = require('punycode');\nvar util = require('./util');\n\nexports.parse = urlParse;\nexports.resolve = urlResolve;\nexports.resolveObject = urlResolveObject;\nexports.format = urlFormat;\n\nexports.Url = Url;\n\nfunction Url() {\n  this.protocol = null;\n  this.slashes = null;\n  this.auth = null;\n  this.host = null;\n  this.port = null;\n  this.hostname = null;\n  this.hash = null;\n  this.search = null;\n  this.query = null;\n  this.pathname = null;\n  this.path = null;\n  this.href = null;\n}\n\n// Reference: RFC 3986, RFC 1808, RFC 2396\n\n// define these here so at least they only have to be\n// compiled once on the first module load.\nvar protocolPattern = /^([a-z0-9.+-]+:)/i,\n    portPattern = /:[0-9]*$/,\n\n    // Special case for a simple path URL\n    simplePathPattern = /^(\\/\\/?(?!\\/)[^\\?\\s]*)(\\?[^\\s]*)?$/,\n\n    // RFC 2396: characters reserved for delimiting URLs.\n    // We actually just auto-escape these.\n    delims = ['<', '>', '\"', '`', ' ', '\\r', '\\n', '\\t'],\n\n    // RFC 2396: characters not allowed for various reasons.\n    unwise = ['{', '}', '|', '\\\\', '^', '`'].concat(delims),\n\n    // Allowed by RFCs, but cause of XSS attacks.  Always escape these.\n    autoEscape = ['\\''].concat(unwise),\n    // Characters that are never ever allowed in a hostname.\n    // Note that any invalid chars are also handled, but these\n    // are the ones that are *expected* to be seen, so we fast-path\n    // them.\n    nonHostChars = ['%', '/', '?', ';', '#'].concat(autoEscape),\n    hostEndingChars = ['/', '?', '#'],\n    hostnameMaxLen = 255,\n    hostnamePartPattern = /^[+a-z0-9A-Z_-]{0,63}$/,\n    hostnamePartStart = /^([+a-z0-9A-Z_-]{0,63})(.*)$/,\n    // protocols that can allow \"unsafe\" and \"unwise\" chars.\n    unsafeProtocol = {\n      'javascript': true,\n      'javascript:': true\n    },\n    // protocols that never have a hostname.\n    hostlessProtocol = {\n      'javascript': true,\n      'javascript:': true\n    },\n    // protocols that always contain a // bit.\n    slashedProtocol = {\n      'http': true,\n      'https': true,\n      'ftp': true,\n      'gopher': true,\n      'file': true,\n      'http:': true,\n      'https:': true,\n      'ftp:': true,\n      'gopher:': true,\n      'file:': true\n    },\n    querystring = require('querystring');\n\nfunction urlParse(url, parseQueryString, slashesDenoteHost) {\n  if (url && util.isObject(url) && url instanceof Url) return url;\n\n  var u = new Url;\n  u.parse(url, parseQueryString, slashesDenoteHost);\n  return u;\n}\n\nUrl.prototype.parse = function(url, parseQueryString, slashesDenoteHost) {\n  if (!util.isString(url)) {\n    throw new TypeError(\"Parameter 'url' must be a string, not \" + typeof url);\n  }\n\n  // Copy chrome, IE, opera backslash-handling behavior.\n  // Back slashes before the query string get converted to forward slashes\n  // See: https://code.google.com/p/chromium/issues/detail?id=25916\n  var queryIndex = url.indexOf('?'),\n      splitter =\n          (queryIndex !== -1 && queryIndex < url.indexOf('#')) ? '?' : '#',\n      uSplit = url.split(splitter),\n      slashRegex = /\\\\/g;\n  uSplit[0] = uSplit[0].replace(slashRegex, '/');\n  url = uSplit.join(splitter);\n\n  var rest = url;\n\n  // trim before proceeding.\n  // This is to support parse stuff like \"  http://foo.com  \\n\"\n  rest = rest.trim();\n\n  if (!slashesDenoteHost && url.split('#').length === 1) {\n    // Try fast path regexp\n    var simplePath = simplePathPattern.exec(rest);\n    if (simplePath) {\n      this.path = rest;\n      this.href = rest;\n      this.pathname = simplePath[1];\n      if (simplePath[2]) {\n        this.search = simplePath[2];\n        if (parseQueryString) {\n          this.query = querystring.parse(this.search.substr(1));\n        } else {\n          this.query = this.search.substr(1);\n        }\n      } else if (parseQueryString) {\n        this.search = '';\n        this.query = {};\n      }\n      return this;\n    }\n  }\n\n  var proto = protocolPattern.exec(rest);\n  if (proto) {\n    proto = proto[0];\n    var lowerProto = proto.toLowerCase();\n    this.protocol = lowerProto;\n    rest = rest.substr(proto.length);\n  }\n\n  // figure out if it's got a host\n  // user@server is *always* interpreted as a hostname, and url\n  // resolution will treat //foo/bar as host=foo,path=bar because that's\n  // how the browser resolves relative URLs.\n  if (slashesDenoteHost || proto || rest.match(/^\\/\\/[^@\\/]+@[^@\\/]+/)) {\n    var slashes = rest.substr(0, 2) === '//';\n    if (slashes && !(proto && hostlessProtocol[proto])) {\n      rest = rest.substr(2);\n      this.slashes = true;\n    }\n  }\n\n  if (!hostlessProtocol[proto] &&\n      (slashes || (proto && !slashedProtocol[proto]))) {\n\n    // there's a hostname.\n    // the first instance of /, ?, ;, or # ends the host.\n    //\n    // If there is an @ in the hostname, then non-host chars *are* allowed\n    // to the left of the last @ sign, unless some host-ending character\n    // comes *before* the @-sign.\n    // URLs are obnoxious.\n    //\n    // ex:\n    // http://a@b@c/ => user:a@b host:c\n    // http://a@b?@c => user:a host:c path:/?@c\n\n    // v0.12 TODO(isaacs): This is not quite how Chrome does things.\n    // Review our test case against browsers more comprehensively.\n\n    // find the first instance of any hostEndingChars\n    var hostEnd = -1;\n    for (var i = 0; i < hostEndingChars.length; i++) {\n      var hec = rest.indexOf(hostEndingChars[i]);\n      if (hec !== -1 && (hostEnd === -1 || hec < hostEnd))\n        hostEnd = hec;\n    }\n\n    // at this point, either we have an explicit point where the\n    // auth portion cannot go past, or the last @ char is the decider.\n    var auth, atSign;\n    if (hostEnd === -1) {\n      // atSign can be anywhere.\n      atSign = rest.lastIndexOf('@');\n    } else {\n      // atSign must be in auth portion.\n      // http://a@b/c@d => host:b auth:a path:/c@d\n      atSign = rest.lastIndexOf('@', hostEnd);\n    }\n\n    // Now we have a portion which is definitely the auth.\n    // Pull that off.\n    if (atSign !== -1) {\n      auth = rest.slice(0, atSign);\n      rest = rest.slice(atSign + 1);\n      this.auth = decodeURIComponent(auth);\n    }\n\n    // the host is the remaining to the left of the first non-host char\n    hostEnd = -1;\n    for (var i = 0; i < nonHostChars.length; i++) {\n      var hec = rest.indexOf(nonHostChars[i]);\n      if (hec !== -1 && (hostEnd === -1 || hec < hostEnd))\n        hostEnd = hec;\n    }\n    // if we still have not hit it, then the entire thing is a host.\n    if (hostEnd === -1)\n      hostEnd = rest.length;\n\n    this.host = rest.slice(0, hostEnd);\n    rest = rest.slice(hostEnd);\n\n    // pull out port.\n    this.parseHost();\n\n    // we've indicated that there is a hostname,\n    // so even if it's empty, it has to be present.\n    this.hostname = this.hostname || '';\n\n    // if hostname begins with [ and ends with ]\n    // assume that it's an IPv6 address.\n    var ipv6Hostname = this.hostname[0] === '[' &&\n        this.hostname[this.hostname.length - 1] === ']';\n\n    // validate a little.\n    if (!ipv6Hostname) {\n      var hostparts = this.hostname.split(/\\./);\n      for (var i = 0, l = hostparts.length; i < l; i++) {\n        var part = hostparts[i];\n        if (!part) continue;\n        if (!part.match(hostnamePartPattern)) {\n          var newpart = '';\n          for (var j = 0, k = part.length; j < k; j++) {\n            if (part.charCodeAt(j) > 127) {\n              // we replace non-ASCII char with a temporary placeholder\n              // we need this to make sure size of hostname is not\n              // broken by replacing non-ASCII by nothing\n              newpart += 'x';\n            } else {\n              newpart += part[j];\n            }\n          }\n          // we test again with ASCII char only\n          if (!newpart.match(hostnamePartPattern)) {\n            var validParts = hostparts.slice(0, i);\n            var notHost = hostparts.slice(i + 1);\n            var bit = part.match(hostnamePartStart);\n            if (bit) {\n              validParts.push(bit[1]);\n              notHost.unshift(bit[2]);\n            }\n            if (notHost.length) {\n              rest = '/' + notHost.join('.') + rest;\n            }\n            this.hostname = validParts.join('.');\n            break;\n          }\n        }\n      }\n    }\n\n    if (this.hostname.length > hostnameMaxLen) {\n      this.hostname = '';\n    } else {\n      // hostnames are always lower case.\n      this.hostname = this.hostname.toLowerCase();\n    }\n\n    if (!ipv6Hostname) {\n      // IDNA Support: Returns a punycoded representation of \"domain\".\n      // It only converts parts of the domain name that\n      // have non-ASCII characters, i.e. it doesn't matter if\n      // you call it with a domain that already is ASCII-only.\n      this.hostname = punycode.toASCII(this.hostname);\n    }\n\n    var p = this.port ? ':' + this.port : '';\n    var h = this.hostname || '';\n    this.host = h + p;\n    this.href += this.host;\n\n    // strip [ and ] from the hostname\n    // the host field still retains them, though\n    if (ipv6Hostname) {\n      this.hostname = this.hostname.substr(1, this.hostname.length - 2);\n      if (rest[0] !== '/') {\n        rest = '/' + rest;\n      }\n    }\n  }\n\n  // now rest is set to the post-host stuff.\n  // chop off any delim chars.\n  if (!unsafeProtocol[lowerProto]) {\n\n    // First, make 100% sure that any \"autoEscape\" chars get\n    // escaped, even if encodeURIComponent doesn't think they\n    // need to be.\n    for (var i = 0, l = autoEscape.length; i < l; i++) {\n      var ae = autoEscape[i];\n      if (rest.indexOf(ae) === -1)\n        continue;\n      var esc = encodeURIComponent(ae);\n      if (esc === ae) {\n        esc = escape(ae);\n      }\n      rest = rest.split(ae).join(esc);\n    }\n  }\n\n\n  // chop off from the tail first.\n  var hash = rest.indexOf('#');\n  if (hash !== -1) {\n    // got a fragment string.\n    this.hash = rest.substr(hash);\n    rest = rest.slice(0, hash);\n  }\n  var qm = rest.indexOf('?');\n  if (qm !== -1) {\n    this.search = rest.substr(qm);\n    this.query = rest.substr(qm + 1);\n    if (parseQueryString) {\n      this.query = querystring.parse(this.query);\n    }\n    rest = rest.slice(0, qm);\n  } else if (parseQueryString) {\n    // no query string, but parseQueryString still requested\n    this.search = '';\n    this.query = {};\n  }\n  if (rest) this.pathname = rest;\n  if (slashedProtocol[lowerProto] &&\n      this.hostname && !this.pathname) {\n    this.pathname = '/';\n  }\n\n  //to support http.request\n  if (this.pathname || this.search) {\n    var p = this.pathname || '';\n    var s = this.search || '';\n    this.path = p + s;\n  }\n\n  // finally, reconstruct the href based on what has been validated.\n  this.href = this.format();\n  return this;\n};\n\n// format a parsed object into a url string\nfunction urlFormat(obj) {\n  // ensure it's an object, and not a string url.\n  // If it's an obj, this is a no-op.\n  // this way, you can call url_format() on strings\n  // to clean up potentially wonky urls.\n  if (util.isString(obj)) obj = urlParse(obj);\n  if (!(obj instanceof Url)) return Url.prototype.format.call(obj);\n  return obj.format();\n}\n\nUrl.prototype.format = function() {\n  var auth = this.auth || '';\n  if (auth) {\n    auth = encodeURIComponent(auth);\n    auth = auth.replace(/%3A/i, ':');\n    auth += '@';\n  }\n\n  var protocol = this.protocol || '',\n      pathname = this.pathname || '',\n      hash = this.hash || '',\n      host = false,\n      query = '';\n\n  if (this.host) {\n    host = auth + this.host;\n  } else if (this.hostname) {\n    host = auth + (this.hostname.indexOf(':') === -1 ?\n        this.hostname :\n        '[' + this.hostname + ']');\n    if (this.port) {\n      host += ':' + this.port;\n    }\n  }\n\n  if (this.query &&\n      util.isObject(this.query) &&\n      Object.keys(this.query).length) {\n    query = querystring.stringify(this.query);\n  }\n\n  var search = this.search || (query && ('?' + query)) || '';\n\n  if (protocol && protocol.substr(-1) !== ':') protocol += ':';\n\n  // only the slashedProtocols get the //.  Not mailto:, xmpp:, etc.\n  // unless they had them to begin with.\n  if (this.slashes ||\n      (!protocol || slashedProtocol[protocol]) && host !== false) {\n    host = '//' + (host || '');\n    if (pathname && pathname.charAt(0) !== '/') pathname = '/' + pathname;\n  } else if (!host) {\n    host = '';\n  }\n\n  if (hash && hash.charAt(0) !== '#') hash = '#' + hash;\n  if (search && search.charAt(0) !== '?') search = '?' + search;\n\n  pathname = pathname.replace(/[?#]/g, function(match) {\n    return encodeURIComponent(match);\n  });\n  search = search.replace('#', '%23');\n\n  return protocol + host + pathname + search + hash;\n};\n\nfunction urlResolve(source, relative) {\n  return urlParse(source, false, true).resolve(relative);\n}\n\nUrl.prototype.resolve = function(relative) {\n  return this.resolveObject(urlParse(relative, false, true)).format();\n};\n\nfunction urlResolveObject(source, relative) {\n  if (!source) return relative;\n  return urlParse(source, false, true).resolveObject(relative);\n}\n\nUrl.prototype.resolveObject = function(relative) {\n  if (util.isString(relative)) {\n    var rel = new Url();\n    rel.parse(relative, false, true);\n    relative = rel;\n  }\n\n  var result = new Url();\n  var tkeys = Object.keys(this);\n  for (var tk = 0; tk < tkeys.length; tk++) {\n    var tkey = tkeys[tk];\n    result[tkey] = this[tkey];\n  }\n\n  // hash is always overridden, no matter what.\n  // even href=\"\" will remove it.\n  result.hash = relative.hash;\n\n  // if the relative url is empty, then there's nothing left to do here.\n  if (relative.href === '') {\n    result.href = result.format();\n    return result;\n  }\n\n  // hrefs like //foo/bar always cut to the protocol.\n  if (relative.slashes && !relative.protocol) {\n    // take everything except the protocol from relative\n    var rkeys = Object.keys(relative);\n    for (var rk = 0; rk < rkeys.length; rk++) {\n      var rkey = rkeys[rk];\n      if (rkey !== 'protocol')\n        result[rkey] = relative[rkey];\n    }\n\n    //urlParse appends trailing / to urls like http://www.example.com\n    if (slashedProtocol[result.protocol] &&\n        result.hostname && !result.pathname) {\n      result.path = result.pathname = '/';\n    }\n\n    result.href = result.format();\n    return result;\n  }\n\n  if (relative.protocol && relative.protocol !== result.protocol) {\n    // if it's a known url protocol, then changing\n    // the protocol does weird things\n    // first, if it's not file:, then we MUST have a host,\n    // and if there was a path\n    // to begin with, then we MUST have a path.\n    // if it is file:, then the host is dropped,\n    // because that's known to be hostless.\n    // anything else is assumed to be absolute.\n    if (!slashedProtocol[relative.protocol]) {\n      var keys = Object.keys(relative);\n      for (var v = 0; v < keys.length; v++) {\n        var k = keys[v];\n        result[k] = relative[k];\n      }\n      result.href = result.format();\n      return result;\n    }\n\n    result.protocol = relative.protocol;\n    if (!relative.host && !hostlessProtocol[relative.protocol]) {\n      var relPath = (relative.pathname || '').split('/');\n      while (relPath.length && !(relative.host = relPath.shift()));\n      if (!relative.host) relative.host = '';\n      if (!relative.hostname) relative.hostname = '';\n      if (relPath[0] !== '') relPath.unshift('');\n      if (relPath.length < 2) relPath.unshift('');\n      result.pathname = relPath.join('/');\n    } else {\n      result.pathname = relative.pathname;\n    }\n    result.search = relative.search;\n    result.query = relative.query;\n    result.host = relative.host || '';\n    result.auth = relative.auth;\n    result.hostname = relative.hostname || relative.host;\n    result.port = relative.port;\n    // to support http.request\n    if (result.pathname || result.search) {\n      var p = result.pathname || '';\n      var s = result.search || '';\n      result.path = p + s;\n    }\n    result.slashes = result.slashes || relative.slashes;\n    result.href = result.format();\n    return result;\n  }\n\n  var isSourceAbs = (result.pathname && result.pathname.charAt(0) === '/'),\n      isRelAbs = (\n          relative.host ||\n          relative.pathname && relative.pathname.charAt(0) === '/'\n      ),\n      mustEndAbs = (isRelAbs || isSourceAbs ||\n                    (result.host && relative.pathname)),\n      removeAllDots = mustEndAbs,\n      srcPath = result.pathname && result.pathname.split('/') || [],\n      relPath = relative.pathname && relative.pathname.split('/') || [],\n      psychotic = result.protocol && !slashedProtocol[result.protocol];\n\n  // if the url is a non-slashed url, then relative\n  // links like ../.. should be able\n  // to crawl up to the hostname, as well.  This is strange.\n  // result.protocol has already been set by now.\n  // Later on, put the first path part into the host field.\n  if (psychotic) {\n    result.hostname = '';\n    result.port = null;\n    if (result.host) {\n      if (srcPath[0] === '') srcPath[0] = result.host;\n      else srcPath.unshift(result.host);\n    }\n    result.host = '';\n    if (relative.protocol) {\n      relative.hostname = null;\n      relative.port = null;\n      if (relative.host) {\n        if (relPath[0] === '') relPath[0] = relative.host;\n        else relPath.unshift(relative.host);\n      }\n      relative.host = null;\n    }\n    mustEndAbs = mustEndAbs && (relPath[0] === '' || srcPath[0] === '');\n  }\n\n  if (isRelAbs) {\n    // it's absolute.\n    result.host = (relative.host || relative.host === '') ?\n                  relative.host : result.host;\n    result.hostname = (relative.hostname || relative.hostname === '') ?\n                      relative.hostname : result.hostname;\n    result.search = relative.search;\n    result.query = relative.query;\n    srcPath = relPath;\n    // fall through to the dot-handling below.\n  } else if (relPath.length) {\n    // it's relative\n    // throw away the existing file, and take the new path instead.\n    if (!srcPath) srcPath = [];\n    srcPath.pop();\n    srcPath = srcPath.concat(relPath);\n    result.search = relative.search;\n    result.query = relative.query;\n  } else if (!util.isNullOrUndefined(relative.search)) {\n    // just pull out the search.\n    // like href='?foo'.\n    // Put this after the other two cases because it simplifies the booleans\n    if (psychotic) {\n      result.hostname = result.host = srcPath.shift();\n      //occationaly the auth can get stuck only in host\n      //this especially happens in cases like\n      //url.resolveObject('mailto:local1@domain1', 'local2@domain2')\n      var authInHost = result.host && result.host.indexOf('@') > 0 ?\n                       result.host.split('@') : false;\n      if (authInHost) {\n        result.auth = authInHost.shift();\n        result.host = result.hostname = authInHost.shift();\n      }\n    }\n    result.search = relative.search;\n    result.query = relative.query;\n    //to support http.request\n    if (!util.isNull(result.pathname) || !util.isNull(result.search)) {\n      result.path = (result.pathname ? result.pathname : '') +\n                    (result.search ? result.search : '');\n    }\n    result.href = result.format();\n    return result;\n  }\n\n  if (!srcPath.length) {\n    // no path at all.  easy.\n    // we've already handled the other stuff above.\n    result.pathname = null;\n    //to support http.request\n    if (result.search) {\n      result.path = '/' + result.search;\n    } else {\n      result.path = null;\n    }\n    result.href = result.format();\n    return result;\n  }\n\n  // if a url ENDs in . or .., then it must get a trailing slash.\n  // however, if it ends in anything else non-slashy,\n  // then it must NOT get a trailing slash.\n  var last = srcPath.slice(-1)[0];\n  var hasTrailingSlash = (\n      (result.host || relative.host || srcPath.length > 1) &&\n      (last === '.' || last === '..') || last === '');\n\n  // strip single dots, resolve double dots to parent dir\n  // if the path tries to go above the root, `up` ends up > 0\n  var up = 0;\n  for (var i = srcPath.length; i >= 0; i--) {\n    last = srcPath[i];\n    if (last === '.') {\n      srcPath.splice(i, 1);\n    } else if (last === '..') {\n      srcPath.splice(i, 1);\n      up++;\n    } else if (up) {\n      srcPath.splice(i, 1);\n      up--;\n    }\n  }\n\n  // if the path is allowed to go above the root, restore leading ..s\n  if (!mustEndAbs && !removeAllDots) {\n    for (; up--; up) {\n      srcPath.unshift('..');\n    }\n  }\n\n  if (mustEndAbs && srcPath[0] !== '' &&\n      (!srcPath[0] || srcPath[0].charAt(0) !== '/')) {\n    srcPath.unshift('');\n  }\n\n  if (hasTrailingSlash && (srcPath.join('/').substr(-1) !== '/')) {\n    srcPath.push('');\n  }\n\n  var isAbsolute = srcPath[0] === '' ||\n      (srcPath[0] && srcPath[0].charAt(0) === '/');\n\n  // put the host back\n  if (psychotic) {\n    result.hostname = result.host = isAbsolute ? '' :\n                                    srcPath.length ? srcPath.shift() : '';\n    //occationaly the auth can get stuck only in host\n    //this especially happens in cases like\n    //url.resolveObject('mailto:local1@domain1', 'local2@domain2')\n    var authInHost = result.host && result.host.indexOf('@') > 0 ?\n                     result.host.split('@') : false;\n    if (authInHost) {\n      result.auth = authInHost.shift();\n      result.host = result.hostname = authInHost.shift();\n    }\n  }\n\n  mustEndAbs = mustEndAbs || (result.host && srcPath.length);\n\n  if (mustEndAbs && !isAbsolute) {\n    srcPath.unshift('');\n  }\n\n  if (!srcPath.length) {\n    result.pathname = null;\n    result.path = null;\n  } else {\n    result.pathname = srcPath.join('/');\n  }\n\n  //to support request.http\n  if (!util.isNull(result.pathname) || !util.isNull(result.search)) {\n    result.path = (result.pathname ? result.pathname : '') +\n                  (result.search ? result.search : '');\n  }\n  result.auth = relative.auth || result.auth;\n  result.slashes = result.slashes || relative.slashes;\n  result.href = result.format();\n  return result;\n};\n\nUrl.prototype.parseHost = function() {\n  var host = this.host;\n  var port = portPattern.exec(host);\n  if (port) {\n    port = port[0];\n    if (port !== ':') {\n      this.port = port.substr(1);\n    }\n    host = host.substr(0, host.length - port.length);\n  }\n  if (host) this.hostname = host;\n};\n","'use strict';\n\nmodule.exports = {\n  isString: function(arg) {\n    return typeof(arg) === 'string';\n  },\n  isObject: function(arg) {\n    return typeof(arg) === 'object' && arg !== null;\n  },\n  isNull: function(arg) {\n    return arg === null;\n  },\n  isNullOrUndefined: function(arg) {\n    return arg == null;\n  }\n};\n","module.exports = extend\n\nvar hasOwnProperty = Object.prototype.hasOwnProperty;\n\nfunction extend() {\n    var target = {}\n\n    for (var i = 0; i < arguments.length; i++) {\n        var source = arguments[i]\n\n        for (var key in source) {\n            if (hasOwnProperty.call(source, key)) {\n                target[key] = source[key]\n            }\n        }\n    }\n\n    return target\n}\n","/*!\n * escape-html\n * Copyright(c) 2012-2013 TJ Holowaychuk\n * Copyright(c) 2015 Andreas Lubbe\n * Copyright(c) 2015 Tiancheng \"Timothy\" Gu\n * MIT Licensed\n */\n\n'use strict';\n\n/**\n * Module variables.\n * @private\n */\n\nvar matchHtmlRegExp = /[\"'&<>]/;\n\n/**\n * Module exports.\n * @public\n */\n\nmodule.exports = escapeHtml;\n\n/**\n * Escape special characters in the given string of html.\n *\n * @param  {string} string The string to escape for inserting into HTML\n * @return {string}\n * @public\n */\n\nfunction escapeHtml(string) {\n  var str = '' + string;\n  var match = matchHtmlRegExp.exec(str);\n\n  if (!match) {\n    return str;\n  }\n\n  var escape;\n  var html = '';\n  var index = 0;\n  var lastIndex = 0;\n\n  for (index = match.index; index < str.length; index++) {\n    switch (str.charCodeAt(index)) {\n      case 34: // \"\n        escape = '&quot;';\n        break;\n      case 38: // &\n        escape = '&amp;';\n        break;\n      case 39: // '\n        escape = '&#39;';\n        break;\n      case 60: // <\n        escape = '&lt;';\n        break;\n      case 62: // >\n        escape = '&gt;';\n        break;\n      default:\n        continue;\n    }\n\n    if (lastIndex !== index) {\n      html += str.substring(lastIndex, index);\n    }\n\n    lastIndex = index + 1;\n    html += escape;\n  }\n\n  return lastIndex !== index\n    ? html + str.substring(lastIndex, index)\n    : html;\n}\n",";(function (sax) { // wrapper for non-node envs\n  sax.parser = function (strict, opt) { return new SAXParser(strict, opt) }\n  sax.SAXParser = SAXParser\n  sax.SAXStream = SAXStream\n  sax.createStream = createStream\n\n  // When we pass the MAX_BUFFER_LENGTH position, start checking for buffer overruns.\n  // When we check, schedule the next check for MAX_BUFFER_LENGTH - (max(buffer lengths)),\n  // since that's the earliest that a buffer overrun could occur.  This way, checks are\n  // as rare as required, but as often as necessary to ensure never crossing this bound.\n  // Furthermore, buffers are only tested at most once per write(), so passing a very\n  // large string into write() might have undesirable effects, but this is manageable by\n  // the caller, so it is assumed to be safe.  Thus, a call to write() may, in the extreme\n  // edge case, result in creating at most one complete copy of the string passed in.\n  // Set to Infinity to have unlimited buffers.\n  sax.MAX_BUFFER_LENGTH = 64 * 1024\n\n  var buffers = [\n    'comment', 'sgmlDecl', 'textNode', 'tagName', 'doctype',\n    'procInstName', 'procInstBody', 'entity', 'attribName',\n    'attribValue', 'cdata', 'script'\n  ]\n\n  sax.EVENTS = [\n    'text',\n    'processinginstruction',\n    'sgmldeclaration',\n    'doctype',\n    'comment',\n    'attribute',\n    'opentag',\n    'closetag',\n    'opencdata',\n    'cdata',\n    'closecdata',\n    'error',\n    'end',\n    'ready',\n    'script',\n    'opennamespace',\n    'closenamespace'\n  ]\n\n  function SAXParser (strict, opt) {\n    if (!(this instanceof SAXParser)) {\n      return new SAXParser(strict, opt)\n    }\n\n    var parser = this\n    clearBuffers(parser)\n    parser.q = parser.c = ''\n    parser.bufferCheckPosition = sax.MAX_BUFFER_LENGTH\n    parser.opt = opt || {}\n    parser.opt.lowercase = parser.opt.lowercase || parser.opt.lowercasetags\n    parser.looseCase = parser.opt.lowercase ? 'toLowerCase' : 'toUpperCase'\n    parser.tags = []\n    parser.closed = parser.closedRoot = parser.sawRoot = false\n    parser.tag = parser.error = null\n    parser.strict = !!strict\n    parser.noscript = !!(strict || parser.opt.noscript)\n    parser.state = S.BEGIN\n    parser.strictEntities = parser.opt.strictEntities\n    parser.ENTITIES = parser.strictEntities ? Object.create(sax.XML_ENTITIES) : Object.create(sax.ENTITIES)\n    parser.attribList = []\n\n    // namespaces form a prototype chain.\n    // it always points at the current tag,\n    // which protos to its parent tag.\n    if (parser.opt.xmlns) {\n      parser.ns = Object.create(rootNS)\n    }\n\n    // mostly just for error reporting\n    parser.trackPosition = parser.opt.position !== false\n    if (parser.trackPosition) {\n      parser.position = parser.line = parser.column = 0\n    }\n    emit(parser, 'onready')\n  }\n\n  if (!Object.create) {\n    Object.create = function (o) {\n      function F () {}\n      F.prototype = o\n      var newf = new F()\n      return newf\n    }\n  }\n\n  if (!Object.keys) {\n    Object.keys = function (o) {\n      var a = []\n      for (var i in o) if (o.hasOwnProperty(i)) a.push(i)\n      return a\n    }\n  }\n\n  function checkBufferLength (parser) {\n    var maxAllowed = Math.max(sax.MAX_BUFFER_LENGTH, 10)\n    var maxActual = 0\n    for (var i = 0, l = buffers.length; i < l; i++) {\n      var len = parser[buffers[i]].length\n      if (len > maxAllowed) {\n        // Text/cdata nodes can get big, and since they're buffered,\n        // we can get here under normal conditions.\n        // Avoid issues by emitting the text node now,\n        // so at least it won't get any bigger.\n        switch (buffers[i]) {\n          case 'textNode':\n            closeText(parser)\n            break\n\n          case 'cdata':\n            emitNode(parser, 'oncdata', parser.cdata)\n            parser.cdata = ''\n            break\n\n          case 'script':\n            emitNode(parser, 'onscript', parser.script)\n            parser.script = ''\n            break\n\n          default:\n            error(parser, 'Max buffer length exceeded: ' + buffers[i])\n        }\n      }\n      maxActual = Math.max(maxActual, len)\n    }\n    // schedule the next check for the earliest possible buffer overrun.\n    var m = sax.MAX_BUFFER_LENGTH - maxActual\n    parser.bufferCheckPosition = m + parser.position\n  }\n\n  function clearBuffers (parser) {\n    for (var i = 0, l = buffers.length; i < l; i++) {\n      parser[buffers[i]] = ''\n    }\n  }\n\n  function flushBuffers (parser) {\n    closeText(parser)\n    if (parser.cdata !== '') {\n      emitNode(parser, 'oncdata', parser.cdata)\n      parser.cdata = ''\n    }\n    if (parser.script !== '') {\n      emitNode(parser, 'onscript', parser.script)\n      parser.script = ''\n    }\n  }\n\n  SAXParser.prototype = {\n    end: function () { end(this) },\n    write: write,\n    resume: function () { this.error = null; return this },\n    close: function () { return this.write(null) },\n    flush: function () { flushBuffers(this) }\n  }\n\n  var Stream\n  try {\n    Stream = require('stream').Stream\n  } catch (ex) {\n    Stream = function () {}\n  }\n\n  var streamWraps = sax.EVENTS.filter(function (ev) {\n    return ev !== 'error' && ev !== 'end'\n  })\n\n  function createStream (strict, opt) {\n    return new SAXStream(strict, opt)\n  }\n\n  function SAXStream (strict, opt) {\n    if (!(this instanceof SAXStream)) {\n      return new SAXStream(strict, opt)\n    }\n\n    Stream.apply(this)\n\n    this._parser = new SAXParser(strict, opt)\n    this.writable = true\n    this.readable = true\n\n    var me = this\n\n    this._parser.onend = function () {\n      me.emit('end')\n    }\n\n    this._parser.onerror = function (er) {\n      me.emit('error', er)\n\n      // if didn't throw, then means error was handled.\n      // go ahead and clear error, so we can write again.\n      me._parser.error = null\n    }\n\n    this._decoder = null\n\n    streamWraps.forEach(function (ev) {\n      Object.defineProperty(me, 'on' + ev, {\n        get: function () {\n          return me._parser['on' + ev]\n        },\n        set: function (h) {\n          if (!h) {\n            me.removeAllListeners(ev)\n            me._parser['on' + ev] = h\n            return h\n          }\n          me.on(ev, h)\n        },\n        enumerable: true,\n        configurable: false\n      })\n    })\n  }\n\n  SAXStream.prototype = Object.create(Stream.prototype, {\n    constructor: {\n      value: SAXStream\n    }\n  })\n\n  SAXStream.prototype.write = function (data) {\n    if (typeof Buffer === 'function' &&\n      typeof Buffer.isBuffer === 'function' &&\n      Buffer.isBuffer(data)) {\n      if (!this._decoder) {\n        var SD = require('string_decoder').StringDecoder\n        this._decoder = new SD('utf8')\n      }\n      data = this._decoder.write(data)\n    }\n\n    this._parser.write(data.toString())\n    this.emit('data', data)\n    return true\n  }\n\n  SAXStream.prototype.end = function (chunk) {\n    if (chunk && chunk.length) {\n      this.write(chunk)\n    }\n    this._parser.end()\n    return true\n  }\n\n  SAXStream.prototype.on = function (ev, handler) {\n    var me = this\n    if (!me._parser['on' + ev] && streamWraps.indexOf(ev) !== -1) {\n      me._parser['on' + ev] = function () {\n        var args = arguments.length === 1 ? [arguments[0]] : Array.apply(null, arguments)\n        args.splice(0, 0, ev)\n        me.emit.apply(me, args)\n      }\n    }\n\n    return Stream.prototype.on.call(me, ev, handler)\n  }\n\n  // character classes and tokens\n  var whitespace = '\\r\\n\\t '\n\n  // this really needs to be replaced with character classes.\n  // XML allows all manner of ridiculous numbers and digits.\n  var number = '0124356789'\n  var letter = 'abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ'\n\n  // (Letter | \"_\" | \":\")\n  var quote = '\\'\"'\n  var attribEnd = whitespace + '>'\n  var CDATA = '[CDATA['\n  var DOCTYPE = 'DOCTYPE'\n  var XML_NAMESPACE = 'http://www.w3.org/XML/1998/namespace'\n  var XMLNS_NAMESPACE = 'http://www.w3.org/2000/xmlns/'\n  var rootNS = { xml: XML_NAMESPACE, xmlns: XMLNS_NAMESPACE }\n\n  // turn all the string character sets into character class objects.\n  whitespace = charClass(whitespace)\n  number = charClass(number)\n  letter = charClass(letter)\n\n  // http://www.w3.org/TR/REC-xml/#NT-NameStartChar\n  // This implementation works on strings, a single character at a time\n  // as such, it cannot ever support astral-plane characters (10000-EFFFF)\n  // without a significant breaking change to either this  parser, or the\n  // JavaScript language.  Implementation of an emoji-capable xml parser\n  // is left as an exercise for the reader.\n  var nameStart = /[:_A-Za-z\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD]/\n\n  var nameBody = /[:_A-Za-z\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD\\u00B7\\u0300-\\u036F\\u203F-\\u2040\\.\\d-]/\n\n  var entityStart = /[#:_A-Za-z\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD]/\n  var entityBody = /[#:_A-Za-z\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD\\u00B7\\u0300-\\u036F\\u203F-\\u2040\\.\\d-]/\n\n  quote = charClass(quote)\n  attribEnd = charClass(attribEnd)\n\n  function charClass (str) {\n    return str.split('').reduce(function (s, c) {\n      s[c] = true\n      return s\n    }, {})\n  }\n\n  function isRegExp (c) {\n    return Object.prototype.toString.call(c) === '[object RegExp]'\n  }\n\n  function is (charclass, c) {\n    return isRegExp(charclass) ? !!c.match(charclass) : charclass[c]\n  }\n\n  function not (charclass, c) {\n    return !is(charclass, c)\n  }\n\n  var S = 0\n  sax.STATE = {\n    BEGIN: S++, // leading byte order mark or whitespace\n    BEGIN_WHITESPACE: S++, // leading whitespace\n    TEXT: S++, // general stuff\n    TEXT_ENTITY: S++, // &amp and such.\n    OPEN_WAKA: S++, // <\n    SGML_DECL: S++, // <!BLARG\n    SGML_DECL_QUOTED: S++, // <!BLARG foo \"bar\n    DOCTYPE: S++, // <!DOCTYPE\n    DOCTYPE_QUOTED: S++, // <!DOCTYPE \"//blah\n    DOCTYPE_DTD: S++, // <!DOCTYPE \"//blah\" [ ...\n    DOCTYPE_DTD_QUOTED: S++, // <!DOCTYPE \"//blah\" [ \"foo\n    COMMENT_STARTING: S++, // <!-\n    COMMENT: S++, // <!--\n    COMMENT_ENDING: S++, // <!-- blah -\n    COMMENT_ENDED: S++, // <!-- blah --\n    CDATA: S++, // <![CDATA[ something\n    CDATA_ENDING: S++, // ]\n    CDATA_ENDING_2: S++, // ]]\n    PROC_INST: S++, // <?hi\n    PROC_INST_BODY: S++, // <?hi there\n    PROC_INST_ENDING: S++, // <?hi \"there\" ?\n    OPEN_TAG: S++, // <strong\n    OPEN_TAG_SLASH: S++, // <strong /\n    ATTRIB: S++, // <a\n    ATTRIB_NAME: S++, // <a foo\n    ATTRIB_NAME_SAW_WHITE: S++, // <a foo _\n    ATTRIB_VALUE: S++, // <a foo=\n    ATTRIB_VALUE_QUOTED: S++, // <a foo=\"bar\n    ATTRIB_VALUE_CLOSED: S++, // <a foo=\"bar\"\n    ATTRIB_VALUE_UNQUOTED: S++, // <a foo=bar\n    ATTRIB_VALUE_ENTITY_Q: S++, // <foo bar=\"&quot;\"\n    ATTRIB_VALUE_ENTITY_U: S++, // <foo bar=&quot\n    CLOSE_TAG: S++, // </a\n    CLOSE_TAG_SAW_WHITE: S++, // </a   >\n    SCRIPT: S++, // <script> ...\n    SCRIPT_ENDING: S++ // <script> ... <\n  }\n\n  sax.XML_ENTITIES = {\n    'amp': '&',\n    'gt': '>',\n    'lt': '<',\n    'quot': '\"',\n    'apos': \"'\"\n  }\n\n  sax.ENTITIES = {\n    'amp': '&',\n    'gt': '>',\n    'lt': '<',\n    'quot': '\"',\n    'apos': \"'\",\n    'AElig': 198,\n    'Aacute': 193,\n    'Acirc': 194,\n    'Agrave': 192,\n    'Aring': 197,\n    'Atilde': 195,\n    'Auml': 196,\n    'Ccedil': 199,\n    'ETH': 208,\n    'Eacute': 201,\n    'Ecirc': 202,\n    'Egrave': 200,\n    'Euml': 203,\n    'Iacute': 205,\n    'Icirc': 206,\n    'Igrave': 204,\n    'Iuml': 207,\n    'Ntilde': 209,\n    'Oacute': 211,\n    'Ocirc': 212,\n    'Ograve': 210,\n    'Oslash': 216,\n    'Otilde': 213,\n    'Ouml': 214,\n    'THORN': 222,\n    'Uacute': 218,\n    'Ucirc': 219,\n    'Ugrave': 217,\n    'Uuml': 220,\n    'Yacute': 221,\n    'aacute': 225,\n    'acirc': 226,\n    'aelig': 230,\n    'agrave': 224,\n    'aring': 229,\n    'atilde': 227,\n    'auml': 228,\n    'ccedil': 231,\n    'eacute': 233,\n    'ecirc': 234,\n    'egrave': 232,\n    'eth': 240,\n    'euml': 235,\n    'iacute': 237,\n    'icirc': 238,\n    'igrave': 236,\n    'iuml': 239,\n    'ntilde': 241,\n    'oacute': 243,\n    'ocirc': 244,\n    'ograve': 242,\n    'oslash': 248,\n    'otilde': 245,\n    'ouml': 246,\n    'szlig': 223,\n    'thorn': 254,\n    'uacute': 250,\n    'ucirc': 251,\n    'ugrave': 249,\n    'uuml': 252,\n    'yacute': 253,\n    'yuml': 255,\n    'copy': 169,\n    'reg': 174,\n    'nbsp': 160,\n    'iexcl': 161,\n    'cent': 162,\n    'pound': 163,\n    'curren': 164,\n    'yen': 165,\n    'brvbar': 166,\n    'sect': 167,\n    'uml': 168,\n    'ordf': 170,\n    'laquo': 171,\n    'not': 172,\n    'shy': 173,\n    'macr': 175,\n    'deg': 176,\n    'plusmn': 177,\n    'sup1': 185,\n    'sup2': 178,\n    'sup3': 179,\n    'acute': 180,\n    'micro': 181,\n    'para': 182,\n    'middot': 183,\n    'cedil': 184,\n    'ordm': 186,\n    'raquo': 187,\n    'frac14': 188,\n    'frac12': 189,\n    'frac34': 190,\n    'iquest': 191,\n    'times': 215,\n    'divide': 247,\n    'OElig': 338,\n    'oelig': 339,\n    'Scaron': 352,\n    'scaron': 353,\n    'Yuml': 376,\n    'fnof': 402,\n    'circ': 710,\n    'tilde': 732,\n    'Alpha': 913,\n    'Beta': 914,\n    'Gamma': 915,\n    'Delta': 916,\n    'Epsilon': 917,\n    'Zeta': 918,\n    'Eta': 919,\n    'Theta': 920,\n    'Iota': 921,\n    'Kappa': 922,\n    'Lambda': 923,\n    'Mu': 924,\n    'Nu': 925,\n    'Xi': 926,\n    'Omicron': 927,\n    'Pi': 928,\n    'Rho': 929,\n    'Sigma': 931,\n    'Tau': 932,\n    'Upsilon': 933,\n    'Phi': 934,\n    'Chi': 935,\n    'Psi': 936,\n    'Omega': 937,\n    'alpha': 945,\n    'beta': 946,\n    'gamma': 947,\n    'delta': 948,\n    'epsilon': 949,\n    'zeta': 950,\n    'eta': 951,\n    'theta': 952,\n    'iota': 953,\n    'kappa': 954,\n    'lambda': 955,\n    'mu': 956,\n    'nu': 957,\n    'xi': 958,\n    'omicron': 959,\n    'pi': 960,\n    'rho': 961,\n    'sigmaf': 962,\n    'sigma': 963,\n    'tau': 964,\n    'upsilon': 965,\n    'phi': 966,\n    'chi': 967,\n    'psi': 968,\n    'omega': 969,\n    'thetasym': 977,\n    'upsih': 978,\n    'piv': 982,\n    'ensp': 8194,\n    'emsp': 8195,\n    'thinsp': 8201,\n    'zwnj': 8204,\n    'zwj': 8205,\n    'lrm': 8206,\n    'rlm': 8207,\n    'ndash': 8211,\n    'mdash': 8212,\n    'lsquo': 8216,\n    'rsquo': 8217,\n    'sbquo': 8218,\n    'ldquo': 8220,\n    'rdquo': 8221,\n    'bdquo': 8222,\n    'dagger': 8224,\n    'Dagger': 8225,\n    'bull': 8226,\n    'hellip': 8230,\n    'permil': 8240,\n    'prime': 8242,\n    'Prime': 8243,\n    'lsaquo': 8249,\n    'rsaquo': 8250,\n    'oline': 8254,\n    'frasl': 8260,\n    'euro': 8364,\n    'image': 8465,\n    'weierp': 8472,\n    'real': 8476,\n    'trade': 8482,\n    'alefsym': 8501,\n    'larr': 8592,\n    'uarr': 8593,\n    'rarr': 8594,\n    'darr': 8595,\n    'harr': 8596,\n    'crarr': 8629,\n    'lArr': 8656,\n    'uArr': 8657,\n    'rArr': 8658,\n    'dArr': 8659,\n    'hArr': 8660,\n    'forall': 8704,\n    'part': 8706,\n    'exist': 8707,\n    'empty': 8709,\n    'nabla': 8711,\n    'isin': 8712,\n    'notin': 8713,\n    'ni': 8715,\n    'prod': 8719,\n    'sum': 8721,\n    'minus': 8722,\n    'lowast': 8727,\n    'radic': 8730,\n    'prop': 8733,\n    'infin': 8734,\n    'ang': 8736,\n    'and': 8743,\n    'or': 8744,\n    'cap': 8745,\n    'cup': 8746,\n    'int': 8747,\n    'there4': 8756,\n    'sim': 8764,\n    'cong': 8773,\n    'asymp': 8776,\n    'ne': 8800,\n    'equiv': 8801,\n    'le': 8804,\n    'ge': 8805,\n    'sub': 8834,\n    'sup': 8835,\n    'nsub': 8836,\n    'sube': 8838,\n    'supe': 8839,\n    'oplus': 8853,\n    'otimes': 8855,\n    'perp': 8869,\n    'sdot': 8901,\n    'lceil': 8968,\n    'rceil': 8969,\n    'lfloor': 8970,\n    'rfloor': 8971,\n    'lang': 9001,\n    'rang': 9002,\n    'loz': 9674,\n    'spades': 9824,\n    'clubs': 9827,\n    'hearts': 9829,\n    'diams': 9830\n  }\n\n  Object.keys(sax.ENTITIES).forEach(function (key) {\n    var e = sax.ENTITIES[key]\n    var s = typeof e === 'number' ? String.fromCharCode(e) : e\n    sax.ENTITIES[key] = s\n  })\n\n  for (var s in sax.STATE) {\n    sax.STATE[sax.STATE[s]] = s\n  }\n\n  // shorthand\n  S = sax.STATE\n\n  function emit (parser, event, data) {\n    parser[event] && parser[event](data)\n  }\n\n  function emitNode (parser, nodeType, data) {\n    if (parser.textNode) closeText(parser)\n    emit(parser, nodeType, data)\n  }\n\n  function closeText (parser) {\n    parser.textNode = textopts(parser.opt, parser.textNode)\n    if (parser.textNode) emit(parser, 'ontext', parser.textNode)\n    parser.textNode = ''\n  }\n\n  function textopts (opt, text) {\n    if (opt.trim) text = text.trim()\n    if (opt.normalize) text = text.replace(/\\s+/g, ' ')\n    return text\n  }\n\n  function error (parser, er) {\n    closeText(parser)\n    if (parser.trackPosition) {\n      er += '\\nLine: ' + parser.line +\n        '\\nColumn: ' + parser.column +\n        '\\nChar: ' + parser.c\n    }\n    er = new Error(er)\n    parser.error = er\n    emit(parser, 'onerror', er)\n    return parser\n  }\n\n  function end (parser) {\n    if (parser.sawRoot && !parser.closedRoot) strictFail(parser, 'Unclosed root tag')\n    if ((parser.state !== S.BEGIN) &&\n      (parser.state !== S.BEGIN_WHITESPACE) &&\n      (parser.state !== S.TEXT)) {\n      error(parser, 'Unexpected end')\n    }\n    closeText(parser)\n    parser.c = ''\n    parser.closed = true\n    emit(parser, 'onend')\n    SAXParser.call(parser, parser.strict, parser.opt)\n    return parser\n  }\n\n  function strictFail (parser, message) {\n    if (typeof parser !== 'object' || !(parser instanceof SAXParser)) {\n      throw new Error('bad call to strictFail')\n    }\n    if (parser.strict) {\n      error(parser, message)\n    }\n  }\n\n  function newTag (parser) {\n    if (!parser.strict) parser.tagName = parser.tagName[parser.looseCase]()\n    var parent = parser.tags[parser.tags.length - 1] || parser\n    var tag = parser.tag = { name: parser.tagName, attributes: {} }\n\n    // will be overridden if tag contails an xmlns=\"foo\" or xmlns:foo=\"bar\"\n    if (parser.opt.xmlns) {\n      tag.ns = parent.ns\n    }\n    parser.attribList.length = 0\n  }\n\n  function qname (name, attribute) {\n    var i = name.indexOf(':')\n    var qualName = i < 0 ? [ '', name ] : name.split(':')\n    var prefix = qualName[0]\n    var local = qualName[1]\n\n    // <x \"xmlns\"=\"http://foo\">\n    if (attribute && name === 'xmlns') {\n      prefix = 'xmlns'\n      local = ''\n    }\n\n    return { prefix: prefix, local: local }\n  }\n\n  function attrib (parser) {\n    if (!parser.strict) {\n      parser.attribName = parser.attribName[parser.looseCase]()\n    }\n\n    if (parser.attribList.indexOf(parser.attribName) !== -1 ||\n      parser.tag.attributes.hasOwnProperty(parser.attribName)) {\n      parser.attribName = parser.attribValue = ''\n      return\n    }\n\n    if (parser.opt.xmlns) {\n      var qn = qname(parser.attribName, true)\n      var prefix = qn.prefix\n      var local = qn.local\n\n      if (prefix === 'xmlns') {\n        // namespace binding attribute. push the binding into scope\n        if (local === 'xml' && parser.attribValue !== XML_NAMESPACE) {\n          strictFail(parser,\n            'xml: prefix must be bound to ' + XML_NAMESPACE + '\\n' +\n            'Actual: ' + parser.attribValue)\n        } else if (local === 'xmlns' && parser.attribValue !== XMLNS_NAMESPACE) {\n          strictFail(parser,\n            'xmlns: prefix must be bound to ' + XMLNS_NAMESPACE + '\\n' +\n            'Actual: ' + parser.attribValue)\n        } else {\n          var tag = parser.tag\n          var parent = parser.tags[parser.tags.length - 1] || parser\n          if (tag.ns === parent.ns) {\n            tag.ns = Object.create(parent.ns)\n          }\n          tag.ns[local] = parser.attribValue\n        }\n      }\n\n      // defer onattribute events until all attributes have been seen\n      // so any new bindings can take effect. preserve attribute order\n      // so deferred events can be emitted in document order\n      parser.attribList.push([parser.attribName, parser.attribValue])\n    } else {\n      // in non-xmlns mode, we can emit the event right away\n      parser.tag.attributes[parser.attribName] = parser.attribValue\n      emitNode(parser, 'onattribute', {\n        name: parser.attribName,\n        value: parser.attribValue\n      })\n    }\n\n    parser.attribName = parser.attribValue = ''\n  }\n\n  function openTag (parser, selfClosing) {\n    if (parser.opt.xmlns) {\n      // emit namespace binding events\n      var tag = parser.tag\n\n      // add namespace info to tag\n      var qn = qname(parser.tagName)\n      tag.prefix = qn.prefix\n      tag.local = qn.local\n      tag.uri = tag.ns[qn.prefix] || ''\n\n      if (tag.prefix && !tag.uri) {\n        strictFail(parser, 'Unbound namespace prefix: ' +\n          JSON.stringify(parser.tagName))\n        tag.uri = qn.prefix\n      }\n\n      var parent = parser.tags[parser.tags.length - 1] || parser\n      if (tag.ns && parent.ns !== tag.ns) {\n        Object.keys(tag.ns).forEach(function (p) {\n          emitNode(parser, 'onopennamespace', {\n            prefix: p,\n            uri: tag.ns[p]\n          })\n        })\n      }\n\n      // handle deferred onattribute events\n      // Note: do not apply default ns to attributes:\n      //   http://www.w3.org/TR/REC-xml-names/#defaulting\n      for (var i = 0, l = parser.attribList.length; i < l; i++) {\n        var nv = parser.attribList[i]\n        var name = nv[0]\n        var value = nv[1]\n        var qualName = qname(name, true)\n        var prefix = qualName.prefix\n        var local = qualName.local\n        var uri = prefix === '' ? '' : (tag.ns[prefix] || '')\n        var a = {\n          name: name,\n          value: value,\n          prefix: prefix,\n          local: local,\n          uri: uri\n        }\n\n        // if there's any attributes with an undefined namespace,\n        // then fail on them now.\n        if (prefix && prefix !== 'xmlns' && !uri) {\n          strictFail(parser, 'Unbound namespace prefix: ' +\n            JSON.stringify(prefix))\n          a.uri = prefix\n        }\n        parser.tag.attributes[name] = a\n        emitNode(parser, 'onattribute', a)\n      }\n      parser.attribList.length = 0\n    }\n\n    parser.tag.isSelfClosing = !!selfClosing\n\n    // process the tag\n    parser.sawRoot = true\n    parser.tags.push(parser.tag)\n    emitNode(parser, 'onopentag', parser.tag)\n    if (!selfClosing) {\n      // special case for <script> in non-strict mode.\n      if (!parser.noscript && parser.tagName.toLowerCase() === 'script') {\n        parser.state = S.SCRIPT\n      } else {\n        parser.state = S.TEXT\n      }\n      parser.tag = null\n      parser.tagName = ''\n    }\n    parser.attribName = parser.attribValue = ''\n    parser.attribList.length = 0\n  }\n\n  function closeTag (parser) {\n    if (!parser.tagName) {\n      strictFail(parser, 'Weird empty close tag.')\n      parser.textNode += '</>'\n      parser.state = S.TEXT\n      return\n    }\n\n    if (parser.script) {\n      if (parser.tagName !== 'script') {\n        parser.script += '</' + parser.tagName + '>'\n        parser.tagName = ''\n        parser.state = S.SCRIPT\n        return\n      }\n      emitNode(parser, 'onscript', parser.script)\n      parser.script = ''\n    }\n\n    // first make sure that the closing tag actually exists.\n    // <a><b></c></b></a> will close everything, otherwise.\n    var t = parser.tags.length\n    var tagName = parser.tagName\n    if (!parser.strict) {\n      tagName = tagName[parser.looseCase]()\n    }\n    var closeTo = tagName\n    while (t--) {\n      var close = parser.tags[t]\n      if (close.name !== closeTo) {\n        // fail the first time in strict mode\n        strictFail(parser, 'Unexpected close tag')\n      } else {\n        break\n      }\n    }\n\n    // didn't find it.  we already failed for strict, so just abort.\n    if (t < 0) {\n      strictFail(parser, 'Unmatched closing tag: ' + parser.tagName)\n      parser.textNode += '</' + parser.tagName + '>'\n      parser.state = S.TEXT\n      return\n    }\n    parser.tagName = tagName\n    var s = parser.tags.length\n    while (s-- > t) {\n      var tag = parser.tag = parser.tags.pop()\n      parser.tagName = parser.tag.name\n      emitNode(parser, 'onclosetag', parser.tagName)\n\n      var x = {}\n      for (var i in tag.ns) {\n        x[i] = tag.ns[i]\n      }\n\n      var parent = parser.tags[parser.tags.length - 1] || parser\n      if (parser.opt.xmlns && tag.ns !== parent.ns) {\n        // remove namespace bindings introduced by tag\n        Object.keys(tag.ns).forEach(function (p) {\n          var n = tag.ns[p]\n          emitNode(parser, 'onclosenamespace', { prefix: p, uri: n })\n        })\n      }\n    }\n    if (t === 0) parser.closedRoot = true\n    parser.tagName = parser.attribValue = parser.attribName = ''\n    parser.attribList.length = 0\n    parser.state = S.TEXT\n  }\n\n  function parseEntity (parser) {\n    var entity = parser.entity\n    var entityLC = entity.toLowerCase()\n    var num\n    var numStr = ''\n\n    if (parser.ENTITIES[entity]) {\n      return parser.ENTITIES[entity]\n    }\n    if (parser.ENTITIES[entityLC]) {\n      return parser.ENTITIES[entityLC]\n    }\n    entity = entityLC\n    if (entity.charAt(0) === '#') {\n      if (entity.charAt(1) === 'x') {\n        entity = entity.slice(2)\n        num = parseInt(entity, 16)\n        numStr = num.toString(16)\n      } else {\n        entity = entity.slice(1)\n        num = parseInt(entity, 10)\n        numStr = num.toString(10)\n      }\n    }\n    entity = entity.replace(/^0+/, '')\n    if (numStr.toLowerCase() !== entity) {\n      strictFail(parser, 'Invalid character entity')\n      return '&' + parser.entity + ';'\n    }\n\n    return String.fromCodePoint(num)\n  }\n\n  function beginWhiteSpace (parser, c) {\n    if (c === '<') {\n      parser.state = S.OPEN_WAKA\n      parser.startTagPosition = parser.position\n    } else if (not(whitespace, c)) {\n      // have to process this as a text node.\n      // weird, but happens.\n      strictFail(parser, 'Non-whitespace before first tag.')\n      parser.textNode = c\n      parser.state = S.TEXT\n    }\n  }\n\n  function write (chunk) {\n    var parser = this\n    if (this.error) {\n      throw this.error\n    }\n    if (parser.closed) {\n      return error(parser,\n        'Cannot write after close. Assign an onready handler.')\n    }\n    if (chunk === null) {\n      return end(parser)\n    }\n    var i = 0\n    var c = ''\n    while (true) {\n      c = chunk.charAt(i++)\n      parser.c = c\n      if (!c) {\n        break\n      }\n      if (parser.trackPosition) {\n        parser.position++\n        if (c === '\\n') {\n          parser.line++\n          parser.column = 0\n        } else {\n          parser.column++\n        }\n      }\n      switch (parser.state) {\n        case S.BEGIN:\n          parser.state = S.BEGIN_WHITESPACE\n          if (c === '\\uFEFF') {\n            continue\n          }\n          beginWhiteSpace(parser, c)\n          continue\n\n        case S.BEGIN_WHITESPACE:\n          beginWhiteSpace(parser, c)\n          continue\n\n        case S.TEXT:\n          if (parser.sawRoot && !parser.closedRoot) {\n            var starti = i - 1\n            while (c && c !== '<' && c !== '&') {\n              c = chunk.charAt(i++)\n              if (c && parser.trackPosition) {\n                parser.position++\n                if (c === '\\n') {\n                  parser.line++\n                  parser.column = 0\n                } else {\n                  parser.column++\n                }\n              }\n            }\n            parser.textNode += chunk.substring(starti, i - 1)\n          }\n          if (c === '<' && !(parser.sawRoot && parser.closedRoot && !parser.strict)) {\n            parser.state = S.OPEN_WAKA\n            parser.startTagPosition = parser.position\n          } else {\n            if (not(whitespace, c) && (!parser.sawRoot || parser.closedRoot)) {\n              strictFail(parser, 'Text data outside of root node.')\n            }\n            if (c === '&') {\n              parser.state = S.TEXT_ENTITY\n            } else {\n              parser.textNode += c\n            }\n          }\n          continue\n\n        case S.SCRIPT:\n          // only non-strict\n          if (c === '<') {\n            parser.state = S.SCRIPT_ENDING\n          } else {\n            parser.script += c\n          }\n          continue\n\n        case S.SCRIPT_ENDING:\n          if (c === '/') {\n            parser.state = S.CLOSE_TAG\n          } else {\n            parser.script += '<' + c\n            parser.state = S.SCRIPT\n          }\n          continue\n\n        case S.OPEN_WAKA:\n          // either a /, ?, !, or text is coming next.\n          if (c === '!') {\n            parser.state = S.SGML_DECL\n            parser.sgmlDecl = ''\n          } else if (is(whitespace, c)) {\n            // wait for it...\n          } else if (is(nameStart, c)) {\n            parser.state = S.OPEN_TAG\n            parser.tagName = c\n          } else if (c === '/') {\n            parser.state = S.CLOSE_TAG\n            parser.tagName = ''\n          } else if (c === '?') {\n            parser.state = S.PROC_INST\n            parser.procInstName = parser.procInstBody = ''\n          } else {\n            strictFail(parser, 'Unencoded <')\n            // if there was some whitespace, then add that in.\n            if (parser.startTagPosition + 1 < parser.position) {\n              var pad = parser.position - parser.startTagPosition\n              c = new Array(pad).join(' ') + c\n            }\n            parser.textNode += '<' + c\n            parser.state = S.TEXT\n          }\n          continue\n\n        case S.SGML_DECL:\n          if ((parser.sgmlDecl + c).toUpperCase() === CDATA) {\n            emitNode(parser, 'onopencdata')\n            parser.state = S.CDATA\n            parser.sgmlDecl = ''\n            parser.cdata = ''\n          } else if (parser.sgmlDecl + c === '--') {\n            parser.state = S.COMMENT\n            parser.comment = ''\n            parser.sgmlDecl = ''\n          } else if ((parser.sgmlDecl + c).toUpperCase() === DOCTYPE) {\n            parser.state = S.DOCTYPE\n            if (parser.doctype || parser.sawRoot) {\n              strictFail(parser,\n                'Inappropriately located doctype declaration')\n            }\n            parser.doctype = ''\n            parser.sgmlDecl = ''\n          } else if (c === '>') {\n            emitNode(parser, 'onsgmldeclaration', parser.sgmlDecl)\n            parser.sgmlDecl = ''\n            parser.state = S.TEXT\n          } else if (is(quote, c)) {\n            parser.state = S.SGML_DECL_QUOTED\n            parser.sgmlDecl += c\n          } else {\n            parser.sgmlDecl += c\n          }\n          continue\n\n        case S.SGML_DECL_QUOTED:\n          if (c === parser.q) {\n            parser.state = S.SGML_DECL\n            parser.q = ''\n          }\n          parser.sgmlDecl += c\n          continue\n\n        case S.DOCTYPE:\n          if (c === '>') {\n            parser.state = S.TEXT\n            emitNode(parser, 'ondoctype', parser.doctype)\n            parser.doctype = true // just remember that we saw it.\n          } else {\n            parser.doctype += c\n            if (c === '[') {\n              parser.state = S.DOCTYPE_DTD\n            } else if (is(quote, c)) {\n              parser.state = S.DOCTYPE_QUOTED\n              parser.q = c\n            }\n          }\n          continue\n\n        case S.DOCTYPE_QUOTED:\n          parser.doctype += c\n          if (c === parser.q) {\n            parser.q = ''\n            parser.state = S.DOCTYPE\n          }\n          continue\n\n        case S.DOCTYPE_DTD:\n          parser.doctype += c\n          if (c === ']') {\n            parser.state = S.DOCTYPE\n          } else if (is(quote, c)) {\n            parser.state = S.DOCTYPE_DTD_QUOTED\n            parser.q = c\n          }\n          continue\n\n        case S.DOCTYPE_DTD_QUOTED:\n          parser.doctype += c\n          if (c === parser.q) {\n            parser.state = S.DOCTYPE_DTD\n            parser.q = ''\n          }\n          continue\n\n        case S.COMMENT:\n          if (c === '-') {\n            parser.state = S.COMMENT_ENDING\n          } else {\n            parser.comment += c\n          }\n          continue\n\n        case S.COMMENT_ENDING:\n          if (c === '-') {\n            parser.state = S.COMMENT_ENDED\n            parser.comment = textopts(parser.opt, parser.comment)\n            if (parser.comment) {\n              emitNode(parser, 'oncomment', parser.comment)\n            }\n            parser.comment = ''\n          } else {\n            parser.comment += '-' + c\n            parser.state = S.COMMENT\n          }\n          continue\n\n        case S.COMMENT_ENDED:\n          if (c !== '>') {\n            strictFail(parser, 'Malformed comment')\n            // allow <!-- blah -- bloo --> in non-strict mode,\n            // which is a comment of \" blah -- bloo \"\n            parser.comment += '--' + c\n            parser.state = S.COMMENT\n          } else {\n            parser.state = S.TEXT\n          }\n          continue\n\n        case S.CDATA:\n          if (c === ']') {\n            parser.state = S.CDATA_ENDING\n          } else {\n            parser.cdata += c\n          }\n          continue\n\n        case S.CDATA_ENDING:\n          if (c === ']') {\n            parser.state = S.CDATA_ENDING_2\n          } else {\n            parser.cdata += ']' + c\n            parser.state = S.CDATA\n          }\n          continue\n\n        case S.CDATA_ENDING_2:\n          if (c === '>') {\n            if (parser.cdata) {\n              emitNode(parser, 'oncdata', parser.cdata)\n            }\n            emitNode(parser, 'onclosecdata')\n            parser.cdata = ''\n            parser.state = S.TEXT\n          } else if (c === ']') {\n            parser.cdata += ']'\n          } else {\n            parser.cdata += ']]' + c\n            parser.state = S.CDATA\n          }\n          continue\n\n        case S.PROC_INST:\n          if (c === '?') {\n            parser.state = S.PROC_INST_ENDING\n          } else if (is(whitespace, c)) {\n            parser.state = S.PROC_INST_BODY\n          } else {\n            parser.procInstName += c\n          }\n          continue\n\n        case S.PROC_INST_BODY:\n          if (!parser.procInstBody && is(whitespace, c)) {\n            continue\n          } else if (c === '?') {\n            parser.state = S.PROC_INST_ENDING\n          } else {\n            parser.procInstBody += c\n          }\n          continue\n\n        case S.PROC_INST_ENDING:\n          if (c === '>') {\n            emitNode(parser, 'onprocessinginstruction', {\n              name: parser.procInstName,\n              body: parser.procInstBody\n            })\n            parser.procInstName = parser.procInstBody = ''\n            parser.state = S.TEXT\n          } else {\n            parser.procInstBody += '?' + c\n            parser.state = S.PROC_INST_BODY\n          }\n          continue\n\n        case S.OPEN_TAG:\n          if (is(nameBody, c)) {\n            parser.tagName += c\n          } else {\n            newTag(parser)\n            if (c === '>') {\n              openTag(parser)\n            } else if (c === '/') {\n              parser.state = S.OPEN_TAG_SLASH\n            } else {\n              if (not(whitespace, c)) {\n                strictFail(parser, 'Invalid character in tag name')\n              }\n              parser.state = S.ATTRIB\n            }\n          }\n          continue\n\n        case S.OPEN_TAG_SLASH:\n          if (c === '>') {\n            openTag(parser, true)\n            closeTag(parser)\n          } else {\n            strictFail(parser, 'Forward-slash in opening tag not followed by >')\n            parser.state = S.ATTRIB\n          }\n          continue\n\n        case S.ATTRIB:\n          // haven't read the attribute name yet.\n          if (is(whitespace, c)) {\n            continue\n          } else if (c === '>') {\n            openTag(parser)\n          } else if (c === '/') {\n            parser.state = S.OPEN_TAG_SLASH\n          } else if (is(nameStart, c)) {\n            parser.attribName = c\n            parser.attribValue = ''\n            parser.state = S.ATTRIB_NAME\n          } else {\n            strictFail(parser, 'Invalid attribute name')\n          }\n          continue\n\n        case S.ATTRIB_NAME:\n          if (c === '=') {\n            parser.state = S.ATTRIB_VALUE\n          } else if (c === '>') {\n            strictFail(parser, 'Attribute without value')\n            parser.attribValue = parser.attribName\n            attrib(parser)\n            openTag(parser)\n          } else if (is(whitespace, c)) {\n            parser.state = S.ATTRIB_NAME_SAW_WHITE\n          } else if (is(nameBody, c)) {\n            parser.attribName += c\n          } else {\n            strictFail(parser, 'Invalid attribute name')\n          }\n          continue\n\n        case S.ATTRIB_NAME_SAW_WHITE:\n          if (c === '=') {\n            parser.state = S.ATTRIB_VALUE\n          } else if (is(whitespace, c)) {\n            continue\n          } else {\n            strictFail(parser, 'Attribute without value')\n            parser.tag.attributes[parser.attribName] = ''\n            parser.attribValue = ''\n            emitNode(parser, 'onattribute', {\n              name: parser.attribName,\n              value: ''\n            })\n            parser.attribName = ''\n            if (c === '>') {\n              openTag(parser)\n            } else if (is(nameStart, c)) {\n              parser.attribName = c\n              parser.state = S.ATTRIB_NAME\n            } else {\n              strictFail(parser, 'Invalid attribute name')\n              parser.state = S.ATTRIB\n            }\n          }\n          continue\n\n        case S.ATTRIB_VALUE:\n          if (is(whitespace, c)) {\n            continue\n          } else if (is(quote, c)) {\n            parser.q = c\n            parser.state = S.ATTRIB_VALUE_QUOTED\n          } else {\n            strictFail(parser, 'Unquoted attribute value')\n            parser.state = S.ATTRIB_VALUE_UNQUOTED\n            parser.attribValue = c\n          }\n          continue\n\n        case S.ATTRIB_VALUE_QUOTED:\n          if (c !== parser.q) {\n            if (c === '&') {\n              parser.state = S.ATTRIB_VALUE_ENTITY_Q\n            } else {\n              parser.attribValue += c\n            }\n            continue\n          }\n          attrib(parser)\n          parser.q = ''\n          parser.state = S.ATTRIB_VALUE_CLOSED\n          continue\n\n        case S.ATTRIB_VALUE_CLOSED:\n          if (is(whitespace, c)) {\n            parser.state = S.ATTRIB\n          } else if (c === '>') {\n            openTag(parser)\n          } else if (c === '/') {\n            parser.state = S.OPEN_TAG_SLASH\n          } else if (is(nameStart, c)) {\n            strictFail(parser, 'No whitespace between attributes')\n            parser.attribName = c\n            parser.attribValue = ''\n            parser.state = S.ATTRIB_NAME\n          } else {\n            strictFail(parser, 'Invalid attribute name')\n          }\n          continue\n\n        case S.ATTRIB_VALUE_UNQUOTED:\n          if (not(attribEnd, c)) {\n            if (c === '&') {\n              parser.state = S.ATTRIB_VALUE_ENTITY_U\n            } else {\n              parser.attribValue += c\n            }\n            continue\n          }\n          attrib(parser)\n          if (c === '>') {\n            openTag(parser)\n          } else {\n            parser.state = S.ATTRIB\n          }\n          continue\n\n        case S.CLOSE_TAG:\n          if (!parser.tagName) {\n            if (is(whitespace, c)) {\n              continue\n            } else if (not(nameStart, c)) {\n              if (parser.script) {\n                parser.script += '</' + c\n                parser.state = S.SCRIPT\n              } else {\n                strictFail(parser, 'Invalid tagname in closing tag.')\n              }\n            } else {\n              parser.tagName = c\n            }\n          } else if (c === '>') {\n            closeTag(parser)\n          } else if (is(nameBody, c)) {\n            parser.tagName += c\n          } else if (parser.script) {\n            parser.script += '</' + parser.tagName\n            parser.tagName = ''\n            parser.state = S.SCRIPT\n          } else {\n            if (not(whitespace, c)) {\n              strictFail(parser, 'Invalid tagname in closing tag')\n            }\n            parser.state = S.CLOSE_TAG_SAW_WHITE\n          }\n          continue\n\n        case S.CLOSE_TAG_SAW_WHITE:\n          if (is(whitespace, c)) {\n            continue\n          }\n          if (c === '>') {\n            closeTag(parser)\n          } else {\n            strictFail(parser, 'Invalid characters in closing tag')\n          }\n          continue\n\n        case S.TEXT_ENTITY:\n        case S.ATTRIB_VALUE_ENTITY_Q:\n        case S.ATTRIB_VALUE_ENTITY_U:\n          var returnState\n          var buffer\n          switch (parser.state) {\n            case S.TEXT_ENTITY:\n              returnState = S.TEXT\n              buffer = 'textNode'\n              break\n\n            case S.ATTRIB_VALUE_ENTITY_Q:\n              returnState = S.ATTRIB_VALUE_QUOTED\n              buffer = 'attribValue'\n              break\n\n            case S.ATTRIB_VALUE_ENTITY_U:\n              returnState = S.ATTRIB_VALUE_UNQUOTED\n              buffer = 'attribValue'\n              break\n          }\n\n          if (c === ';') {\n            parser[buffer] += parseEntity(parser)\n            parser.entity = ''\n            parser.state = returnState\n          } else if (is(parser.entity.length ? entityBody : entityStart, c)) {\n            parser.entity += c\n          } else {\n            strictFail(parser, 'Invalid character in entity name')\n            parser[buffer] += '&' + parser.entity + c\n            parser.entity = ''\n            parser.state = returnState\n          }\n\n          continue\n\n        default:\n          throw new Error(parser, 'Unknown state: ' + parser.state)\n      }\n    } // while\n\n    if (parser.position >= parser.bufferCheckPosition) {\n      checkBufferLength(parser)\n    }\n    return parser\n  }\n\n  /*! http://mths.be/fromcodepoint v0.1.0 by @mathias */\n  if (!String.fromCodePoint) {\n    (function () {\n      var stringFromCharCode = String.fromCharCode\n      var floor = Math.floor\n      var fromCodePoint = function () {\n        var MAX_SIZE = 0x4000\n        var codeUnits = []\n        var highSurrogate\n        var lowSurrogate\n        var index = -1\n        var length = arguments.length\n        if (!length) {\n          return ''\n        }\n        var result = ''\n        while (++index < length) {\n          var codePoint = Number(arguments[index])\n          if (\n            !isFinite(codePoint) || // `NaN`, `+Infinity`, or `-Infinity`\n            codePoint < 0 || // not a valid Unicode code point\n            codePoint > 0x10FFFF || // not a valid Unicode code point\n            floor(codePoint) !== codePoint // not an integer\n          ) {\n            throw RangeError('Invalid code point: ' + codePoint)\n          }\n          if (codePoint <= 0xFFFF) { // BMP code point\n            codeUnits.push(codePoint)\n          } else { // Astral code point; split in surrogate halves\n            // http://mathiasbynens.be/notes/javascript-encoding#surrogate-formulae\n            codePoint -= 0x10000\n            highSurrogate = (codePoint >> 10) + 0xD800\n            lowSurrogate = (codePoint % 0x400) + 0xDC00\n            codeUnits.push(highSurrogate, lowSurrogate)\n          }\n          if (index + 1 === length || codeUnits.length > MAX_SIZE) {\n            result += stringFromCharCode.apply(null, codeUnits)\n            codeUnits.length = 0\n          }\n        }\n        return result\n      }\n      if (Object.defineProperty) {\n        Object.defineProperty(String, 'fromCodePoint', {\n          value: fromCodePoint,\n          configurable: true,\n          writable: true\n        })\n      } else {\n        String.fromCodePoint = fromCodePoint\n      }\n    }())\n  }\n})(typeof exports === 'undefined' ? this.sax = {} : exports)\n"],"sourceRoot":"/source/"}