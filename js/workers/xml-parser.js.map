{"version":3,"sources":["workers/node_modules/browserify/node_modules/browser-pack/_prelude.js","client/js/workers/xml-parser.js","workers/xml-parser.js","client/jsx/reader/backend/lawly-bot.js","workers/node_modules/browserify/node_modules/buffer/index.js","workers/node_modules/browserify/node_modules/buffer/node_modules/base64-js/lib/b64.js","workers/node_modules/browserify/node_modules/buffer/node_modules/ieee754/index.js","workers/node_modules/browserify/node_modules/buffer/node_modules/isarray/index.js","workers/node_modules/browserify/node_modules/events/events.js","workers/node_modules/browserify/node_modules/https-browserify/index.js","workers/node_modules/browserify/node_modules/inherits/inherits_browser.js","workers/node_modules/browserify/node_modules/insert-module-globals/node_modules/is-buffer/index.js","workers/node_modules/browserify/node_modules/isarray/index.js","workers/node_modules/browserify/node_modules/process/browser.js","workers/node_modules/browserify/node_modules/punycode/punycode.js","workers/node_modules/browserify/node_modules/querystring-es3/decode.js","workers/node_modules/browserify/node_modules/querystring-es3/encode.js","workers/node_modules/browserify/node_modules/querystring-es3/index.js","workers/node_modules/browserify/node_modules/readable-stream/duplex.js","workers/node_modules/browserify/node_modules/readable-stream/lib/_stream_duplex.js","workers/node_modules/browserify/node_modules/readable-stream/lib/_stream_passthrough.js","workers/node_modules/browserify/node_modules/readable-stream/lib/_stream_readable.js","workers/node_modules/browserify/node_modules/readable-stream/lib/_stream_transform.js","workers/node_modules/browserify/node_modules/readable-stream/lib/_stream_writable.js","workers/node_modules/browserify/node_modules/readable-stream/node_modules/core-util-is/lib/util.js","workers/node_modules/browserify/node_modules/readable-stream/node_modules/process-nextick-args/index.js","workers/node_modules/browserify/node_modules/readable-stream/node_modules/util-deprecate/browser.js","workers/node_modules/browserify/node_modules/readable-stream/passthrough.js","workers/node_modules/browserify/node_modules/readable-stream/readable.js","workers/node_modules/browserify/node_modules/readable-stream/transform.js","workers/node_modules/browserify/node_modules/readable-stream/writable.js","workers/node_modules/browserify/node_modules/stream-browserify/index.js","workers/node_modules/browserify/node_modules/stream-http/index.js","workers/node_modules/browserify/node_modules/stream-http/lib/capability.js","workers/node_modules/browserify/node_modules/stream-http/lib/request.js","workers/node_modules/browserify/node_modules/stream-http/lib/response.js","workers/node_modules/browserify/node_modules/stream-http/node_modules/builtin-status-codes/browser.js","workers/node_modules/browserify/node_modules/string_decoder/index.js","workers/node_modules/browserify/node_modules/url/url.js","workers/node_modules/browserify/node_modules/url/util.js","workers/node_modules/browserify/node_modules/xtend/immutable.js","workers/node_modules/escape-html/index.js","workers/node_modules/sax/lib/sax.js"],"names":["e","t","n","r","s","o","u","a","require","i","f","Error","code","l","exports","call","length",1,"module","peek","stack","createElement","name","xmlTag","attrs","children","xml","setAttr","xmlKey","xmlAttrs","htmlKey","htmlAttrs","escapeHtml","getHtmlAttributes","node","className","nas","attributes","match","key","hasOwnProperty","simpleNodeHtml","htmlTag","setAnchor","xmlNode","htmlNode","postMessageToSource","d","postMessage","parse","inStream","currentElHasIgnoredParent","elementStack","ignored","shouldIgnore","ignoredElements","xmlNodeToHtmlNode","nm","tagName","htmlMappings","htmlNod","result","rootNode","saxStream","sax","createStream","strict","options","on","console","error","this","_parser","resume","str","_WHITESPACE","newNode","push","nodeName","element","pop","pipe","https","lawlyBot","jcis","jci","alias-titels","meta-data","metadata","al","lijst","nadruk","intitule","titel","title","tussenkop","label","nr","lidnr","artikel","dagtekening","plaats","datum","functie","redactie","naam","voornaam","achternaam","organisatie","sup","sub","intref","extref","illustratie","table","colspec","thead","tfoot","entrytbl","tbody","li","kop","row","onmessage","data","bwbId","expressionId","slowUrl","URL_LAWLY_BOT","get","log","../../jsx/reader/backend/lawly-bot","escape-html",2,"URL_LAWLY_BOT_HOST","URL_LAWLY_BOT_API_PATH",3,4,"global","typedArraySupport","Bar","arr","Uint8Array","foo","constructor","subarray","byteLength","kMaxLength","Buffer","TYPED_ARRAY_SUPPORT","arg","parent","undefined","fromNumber","fromString","arguments","fromObject","that","allocate","checked","string","encoding","write","object","isBuffer","fromBuffer","isArray","fromArray","TypeError","ArrayBuffer","buffer","fromTypedArray","fromArrayBuffer","fromArrayLike","fromJsonObject","copy","array","_augment","type","__proto__","prototype","_isBuffer","fromPool","poolSize","rootParent","RangeError","toString","SlowBuffer","subject","buf","len","loweredCase","utf8ToBytes","base64ToBytes","toLowerCase","slowToString","start","end","Infinity","hexSlice","utf8Slice","asciiSlice","binarySlice","base64Slice","utf16leSlice","hexWrite","offset","Number","remaining","strLen","parsed","parseInt","substr","isNaN","utf8Write","blitBuffer","asciiWrite","asciiToBytes","binaryWrite","base64Write","ucs2Write","utf16leToBytes","base64","fromByteArray","slice","Math","min","res","firstByte","codePoint","bytesPerSequence","secondByte","thirdByte","fourthByte","tempCodePoint","decodeCodePointsArray","codePoints","MAX_ARGUMENTS_LENGTH","String","fromCharCode","apply","ret","out","toHex","bytes","checkOffset","ext","checkInt","value","max","objectWriteUInt16","littleEndian","j","objectWriteUInt32","checkIEEE754","writeFloat","noAssert","ieee754","writeDouble","base64clean","stringtrim","replace","INVALID_BASE64_RE","trim","units","leadSurrogate","charCodeAt","byteArray","c","hi","lo","toByteArray","src","dst","INSPECT_MAX_BYTES","b","compare","x","y","isEncoding","concat","list","pos","item","equals","inspect","join","indexOf","val","byteOffset","arrayIndexOf","foundIndex","readUInt8","set","v","writeUInt8","isFinite","swap","toJSON","Array","_arr","newBuf","sliceLen","readUIntLE","mul","readUIntBE","readUInt16LE","readUInt16BE","readUInt32LE","readUInt32BE","readIntLE","pow","readIntBE","readInt8","readInt16LE","readInt16BE","readInt32LE","readInt32BE","readFloatLE","read","readFloatBE","readDoubleLE","readDoubleBE","writeUIntLE","writeUIntBE","floor","writeUInt16LE","writeUInt16BE","writeUInt32LE","writeUInt32BE","writeIntLE","limit","writeIntBE","writeInt8","writeInt16LE","writeInt16BE","writeInt32LE","writeInt32BE","writeFloatLE","writeFloatBE","writeDoubleLE","writeDoubleBE","target","targetStart","_set","fill","toArrayBuffer","BP","toLocaleString","self","window","base64-js","isarray",5,"lookup","decode","elt","PLUS","PLUS_URL_SAFE","SLASH","SLASH_URL_SAFE","NUMBER","UPPER","LOWER","b64ToByteArray","b64","L","tmp","placeHolders","charAt","Arr","uint8ToBase64","uint8","encode","num","tripletToBase64","temp","extraBytes","output","base64js",6,"isLE","mLen","nBytes","m","eLen","eMax","eBias","nBits","NaN","rt","abs","LN2",7,8,"EventEmitter","_events","_maxListeners","isFunction","isNumber","isObject","isUndefined","defaultMaxListeners","setMaxListeners","emit","er","handler","args","listeners","addListener","listener","newListener","warned","trace","once","g","removeListener","fired","position","splice","removeAllListeners","listenerCount","evlistener","emitter",9,"http","request","params","cb","scheme","protocol",10,"Object","create","ctor","superCtor","super_","enumerable","writable","configurable","TempCtor",11,"obj",12,13,"cleanUpNextTick","draining","currentQueue","queue","queueIndex","drainQueue","timeout","setTimeout","run","clearTimeout","Item","fun","noop","process","nextTick","browser","env","argv","version","versions","off","binding","cwd","chdir","dir","umask",14,"root","errors","map","fn","mapDomain","parts","split","regexSeparators","labels","encoded","ucs2decode","extra","counter","ucs2encode","stringFromCharCode","basicToDigit","base","digitToBasic","digit","flag","adapt","delta","numPoints","firstTime","k","damp","baseMinusTMin","tMax","skew","input","basic","index","oldi","w","baseMinusT","inputLength","initialN","bias","initialBias","lastIndexOf","delimiter","maxInt","tMin","handledCPCount","basicLength","q","currentValue","handledCPCountPlusOne","qMinusT","toUnicode","regexPunycode","test","toASCII","regexNonASCII","freeExports","nodeType","freeModule","freeGlobal","punycode","overflow","not-basic","invalid-input","ucs2","define","amd",15,"prop","qs","sep","eq","regexp","maxKeys","kstr","vstr","idx","decodeURIComponent","xs",16,"stringifyPrimitive","objectKeys","ks","encodeURIComponent","keys",17,"stringify","./decode","./encode",18,"./lib/_stream_duplex.js",19,"Duplex","Readable","Writable","readable","allowHalfOpen","onend","_writableState","ended","processNextTick","onEndNT","util","inherits","method","./_stream_readable","./_stream_writable","core-util-is","process-nextick-args",20,"PassThrough","Transform","_transform","chunk","./_stream_transform",21,"ReadableState","stream","objectMode","readableObjectMode","hwm","highWaterMark","defaultHwm","pipes","pipesCount","flowing","endEmitted","reading","sync","needReadable","emittedReadable","readableListening","defaultEncoding","ranOut","awaitDrain","readingMore","decoder","StringDecoder","_readableState","_read","Stream","readableAddChunk","state","addToFront","chunkInvalid","onEofChunk","unshift","emitReadable","maybeReadMore","needMoreData","computeNewHighWaterMark","MAX_HWM","howMuchToRead","debug","emitReadable_","flow","maybeReadMore_","pipeOnDrain","EElistenerCount","nReadingNextTick","resumeScheduled","resume_","fromList","stringMode","shift","cpy","endReadable","endReadableNT","forEach","_","debugUtil","debuglog","isPaused","setEncoding","enc","nOrig","doRead","dest","pipeOpts","onunpipe","cleanup","onclose","onfinish","ondrain","onerror","ondata","cleanedUp","needDrain","pause","unpipe","doEnd","stdout","stderr","endFn","dests","ev","wrap","paused","events","bind","_fromList","./_stream_duplex","_process","string_decoder/",22,"TransformState","afterTransform","needTransform","transforming","writecb","writechunk","ts","_transformState","rs","transform","flush","_flush","done","ws","_write","writeencoding",23,"nop","WriteReq","callback","next","WritableState","writableObjectMode","ending","finished","noDecode","decodeStrings","writing","corked","bufferProcessing","onwrite","writelen","bufferedRequest","lastBufferedRequest","pendingcb","prefinished","errorEmitted","writev","_writev","writeAfterEnd","validChunk","valid","decodeChunk","writeOrBuffer","last","doWrite","onwriteError","onwriteStateUpdate","needFinish","clearBuffer","afterWrite","onwriteDrain","finishMaybe","entry","cbs","err","prefinish","need","endWritable","internalUtil","deprecate","getBuffer","current","defineProperty","cork","uncork","setDefaultEncoding","util-deprecate",24,"objectToString","isBoolean","isNull","isNullOrUndefined","isString","isSymbol","isRegExp","re","isDate","isError","isPrimitive","../../../../insert-module-globals/node_modules/is-buffer/index.js",25,26,"msg","deprecated","config","warn","localStorage",27,"./lib/_stream_passthrough.js",28,"./lib/_stream_readable.js","./lib/_stream_transform.js","./lib/_stream_writable.js",29,30,31,"EE","source","didOnEnd","destroy","_isStdio","readable-stream/duplex.js","readable-stream/passthrough.js","readable-stream/readable.js","readable-stream/transform.js","readable-stream/writable.js",32,"ClientRequest","extend","statusCodes","url","opts","host","hostname","port","path","toUpperCase","headers","req","Agent","defaultMaxSockets","STATUS_CODES","METHODS","./lib/request","builtin-status-codes","xtend",33,"checkTypeSupport","xhr","responseType","fetch","ReadableByteStream","blobConstructor","Blob","XMLHttpRequest","open","location","haveArrayBuffer","haveSlice","arraybuffer","msstream","mozchunkedarraybuffer","overrideMimeType","vbArray","VBArray",34,"decideMode","preferBinary","capability","statusValid","status","response","IncomingMessage","rStates","readyStates","_opts","_body","_headers","auth","setHeader","mode","_mode","_onFinish","lowerName","unsafeHeaders","getHeader","removeHeader","_destroyed","body","headersObj","credentials","withCredentials","then","_fetchResponse","_connect","reason","_xhr","setRequestHeader","_response","onreadystatechange","readyState","LOADING","DONE","_onXHRProgress","onprogress","send","abort","flushHeaders","setNoDelay","setSocketKeepAlive","./capability","./response",35,"UNSENT","OPENED","HEADERS_RECEIVED","reader","rawHeaders","trailers","rawTrailers","statusCode","statusMessage","statusText","header","_i","_it","Symbol","iterator","getReader","_pos","getAllResponseHeaders","matches","_charset","mimeType","charsetMatch","responseBody","toArray","responseText","newData","MSStreamReader","onload","readAsArrayBuffer",36,"100","101","102","200","201","202","203","204","205","206","207","300","301","302","303","304","305","307","308","400","401","402","403","404","405","406","407","408","409","410","411","412","413","414","415","416","417","418","422","423","424","425","426","428","429","431","500","501","502","503","504","505","506","507","509","510","511",37,"assertEncoding","isBufferEncoding","passThroughWrite","utf16DetectIncompleteChar","charReceived","charLength","base64DetectIncompleteChar","surrogateSize","detectIncompleteChar","charBuffer","charStr","available","charCode","size","substring","cr",38,"Url","slashes","hash","search","query","pathname","href","urlParse","parseQueryString","slashesDenoteHost","urlFormat","format","urlResolve","relative","resolve","urlResolveObject","resolveObject","protocolPattern","portPattern","simplePathPattern","delims","unwise","autoEscape","nonHostChars","hostEndingChars","hostnameMaxLen","hostnamePartPattern","hostnamePartStart","unsafeProtocol","javascript","javascript:","hostlessProtocol","slashedProtocol","ftp","gopher","file","http:","https:","ftp:","gopher:","file:","querystring","queryIndex","splitter","uSplit","slashRegex","rest","simplePath","exec","proto","lowerProto","hostEnd","hec","atSign","parseHost","ipv6Hostname","hostparts","part","newpart","validParts","notHost","bit","p","h","ae","esc","escape","qm","rel","tkeys","tk","tkey","rkeys","rk","rkey","relPath","isSourceAbs","isRelAbs","mustEndAbs","removeAllDots","srcPath","psychotic","authInHost","hasTrailingSlash","up","isAbsolute","./util",39,40,41,"matchHtmlRegExp","html","lastIndex",42,"SAXParser","opt","parser","clearBuffers","bufferCheckPosition","MAX_BUFFER_LENGTH","lowercase","lowercasetags","looseCase","tags","closed","closedRoot","sawRoot","tag","noscript","S","BEGIN","strictEntities","ENTITIES","XML_ENTITIES","attribList","xmlns","ns","rootNS","trackPosition","line","column","checkBufferLength","maxAllowed","maxActual","buffers","closeText","emitNode","cdata","script","flushBuffers","SAXStream","me","_decoder","streamWraps","charClass","reduce","is","charclass","not","event","textNode","textopts","text","normalize","strictFail","BEGIN_WHITESPACE","TEXT","message","newTag","qname","attribute","qualName","prefix","local","attrib","attribName","attribValue","qn","XML_NAMESPACE","XMLNS_NAMESPACE","openTag","selfClosing","uri","JSON","nv","isSelfClosing","SCRIPT","closeTag","closeTo","close","parseEntity","entity","entityLC","numStr","fromCodePoint","beginWhiteSpace","OPEN_WAKA","startTagPosition","whitespace","starti","TEXT_ENTITY","SCRIPT_ENDING","CLOSE_TAG","SGML_DECL","sgmlDecl","nameStart","OPEN_TAG","PROC_INST","procInstName","procInstBody","pad","CDATA","COMMENT","comment","DOCTYPE","doctype","quote","SGML_DECL_QUOTED","DOCTYPE_DTD","DOCTYPE_QUOTED","DOCTYPE_DTD_QUOTED","COMMENT_ENDING","COMMENT_ENDED","CDATA_ENDING","CDATA_ENDING_2","PROC_INST_ENDING","PROC_INST_BODY","nameBody","OPEN_TAG_SLASH","ATTRIB","ATTRIB_NAME","ATTRIB_VALUE","ATTRIB_NAME_SAW_WHITE","ATTRIB_VALUE_QUOTED","ATTRIB_VALUE_UNQUOTED","ATTRIB_VALUE_ENTITY_Q","ATTRIB_VALUE_CLOSED","attribEnd","ATTRIB_VALUE_ENTITY_U","CLOSE_TAG_SAW_WHITE","returnState","entityBody","entityStart","EVENTS","F","newf","ex","filter","SD","number","letter","STATE","COMMENT_STARTING","amp","gt","lt","quot","apos","AElig","Aacute","Acirc","Agrave","Aring","Atilde","Auml","Ccedil","ETH","Eacute","Ecirc","Egrave","Euml","Iacute","Icirc","Igrave","Iuml","Ntilde","Oacute","Ocirc","Ograve","Oslash","Otilde","Ouml","THORN","Uacute","Ucirc","Ugrave","Uuml","Yacute","aacute","acirc","aelig","agrave","aring","atilde","auml","ccedil","eacute","ecirc","egrave","eth","euml","iacute","icirc","igrave","iuml","ntilde","oacute","ocirc","ograve","oslash","otilde","ouml","szlig","thorn","uacute","ucirc","ugrave","uuml","yacute","yuml","reg","nbsp","iexcl","cent","pound","curren","yen","brvbar","sect","uml","ordf","laquo","shy","macr","deg","plusmn","sup1","sup2","sup3","acute","micro","para","middot","cedil","ordm","raquo","frac14","frac12","frac34","iquest","times","divide","OElig","oelig","Scaron","scaron","Yuml","fnof","circ","tilde","Alpha","Beta","Gamma","Delta","Epsilon","Zeta","Eta","Theta","Iota","Kappa","Lambda","Mu","Nu","Xi","Omicron","Pi","Rho","Sigma","Tau","Upsilon","Phi","Chi","Psi","Omega","alpha","beta","gamma","epsilon","zeta","eta","theta","iota","kappa","lambda","mu","nu","xi","omicron","pi","rho","sigmaf","sigma","tau","upsilon","phi","chi","psi","omega","thetasym","upsih","piv","ensp","emsp","thinsp","zwnj","zwj","lrm","rlm","ndash","mdash","lsquo","rsquo","sbquo","ldquo","rdquo","bdquo","dagger","Dagger","bull","hellip","permil","prime","Prime","lsaquo","rsaquo","oline","frasl","euro","image","weierp","real","trade","alefsym","larr","uarr","rarr","darr","harr","crarr","lArr","uArr","rArr","dArr","hArr","forall","exist","empty","nabla","isin","notin","ni","prod","sum","minus","lowast","radic","infin","ang","and","or","cap","cup","int","there4","sim","cong","asymp","ne","equiv","le","ge","nsub","sube","supe","oplus","otimes","perp","sdot","lceil","rceil","lfloor","rfloor","lang","rang","loz","spades","clubs","hearts","diams","highSurrogate","lowSurrogate","MAX_SIZE","codeUnits","string_decoder"],"mappings":"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","file":"workers/xml-parser.js","sourcesContent":["(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require==\"function\"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error(\"Cannot find module '\"+o+\"'\");throw f.code=\"MODULE_NOT_FOUND\",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require==\"function\"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})","var sax = require(\"sax\");\nvar https = require(\"https\");\nvar escapeHtml = require('escape-html');\nvar lawlyBot = require('../../jsx/reader/backend/lawly-bot');\n//var Immutable = require('immutable');\n\nvar strict = true;\nvar options = {};\nvar _WHITESPACE = ' ';\n\n/**\n *\n * @param stack Given array\n * @returns {*} last element of given array\n */\nfunction peek(stack) {\n    return stack.length > 0 ? stack[stack.length - 1] : null;\n}\n\nvar ignoredElements = {\n    'jcis': true,\n    'jci': true,\n    'alias-titels': true,\n    'meta-data': true,\n    'metadata': true\n};\nvar htmlMappings = {\n    al: 'p',\n    lijst: 'ul',\n    nadruk: 'em',\n    intitule: 'h1',\n    titel: 'h3',\n    title: 'h3',\n    tussenkop: 'h3',\n    label: 'h3',\n    nr: 'h3',\n    lidnr: 'h4',\n    artikel: 'article',\n    dagtekening: 'div',\n    plaats: 'span',\n    datum: 'span',\n    functie: 'span',\n    redactie: 'span',\n    naam: 'span',\n    voornaam: 'span',\n    achternaam: 'span',\n    organisatie: 'span',\n    sup: 'sup',\n    sub: 'sub',\n    intref: 'a', // TODO handle intrefgroep\n    extref: 'a', // TODO handle extrefgroep\n    illustratie: 'img', // TODO properly handle get src url\n    table: 'div', // TODO handle the myriad table attrs\n    colspec: 'col',\n    thead: 'thead',\n    tfoot: 'tfoot',\n    entrytbl: 'table',\n    tbody: 'tbody',\n    li: 'li',\n    kop: 'header',\n    row: 'tr'\n};\n\n/**\n *\n * @param name tagname string\n * @param xmlTag xml tag name string\n * @param attrs string to string map\n * @param children Array of strings\n * @returns {{name: *, attrs: *, children: *}}\n */\nfunction createElement(name, xmlTag, attrs, children) {\n    return {\n        name: name,\n        xml: xmlTag,\n        attrs: attrs,\n        children: children\n    };\n}\n\nfunction setAttr(xmlKey, xmlAttrs, htmlKey, htmlAttrs) {\n    htmlAttrs[htmlKey] = escapeHtml(xmlAttrs[xmlKey]);\n}\nfunction getHtmlAttributes(node) {\n    var attrs = {\n        'className': node.name\n        //'data-xml-tag': xmlTag\n    };\n    var nas = node.attributes;\n    if (nas['bwb-ng-variabel-deel'] && !(node.name.match(/(int?|ext)ref/))) {\n        setAttr('bwb-ng-variabel-deel', nas, 'id', attrs);\n    } else if (nas['if']) {\n        setAttr('id', nas, 'id', attrs);\n    }\n\n    for (var key in nas) {\n        if (nas.hasOwnProperty(key))\n            if (key == 'id') {\n                setAttr(key, nas, 'data-id', attrs);\n            } else if (key == 'stam-id') {\n                setAttr(key, nas, 'data-stam-id', attrs);\n            } else if (key == 'versie-id') {\n                setAttr(key, nas, 'data-versie-id', attrs);\n            } else if (key == 'label-id') {\n                setAttr(key, nas, 'data-label-id', attrs);\n                //doc=\"32004L0017\" label=\"richtlijn\" reeks=\"Celex\"\n                //verwijzing-id=\"2556878\" doc=\"\" bwb-id=\"\" label-id=\"12115324\"\n            } else if (key == 'bwb-id') {\n                setAttr(key, nas, 'data-bwb-id', attrs);\n            } else if (key == 'verwijzing-id') {\n                setAttr(key, nas, 'data-verwijzing-id', attrs);\n            } else if (key == 'label') {\n                setAttr(key, nas, 'data-label', attrs);\n            } else if (key == 'reeks') {\n                setAttr(key, nas, 'data-reeks', attrs);\n            } else if (key == 'doc') {\n                setAttr(key, nas, 'data-doc', attrs);\n\n            } else {\n                //console.log(attr);\n            }\n    }\n    return attrs;\n}\n\nfunction simpleNodeHtml(htmlTag, node) {\n    return createElement(htmlTag, node.name, getHtmlAttributes(node), []);\n}\n\n\nfunction getAttributesAsString(attrs) {\n    if (attrs.length <= 0) {\n        return ''\n    } else {\n        var ss = [];\n        for (var key in attrs) {\n            if (attrs.hasOwnProperty(key))\n                ss.push('' + key + '=\"' + attrs[key] + '\"');\n        }\n        return ' ' + ss.join(' ');\n    }\n}\n\nfunction setAnchor(xmlNode, htmlNode) {\n    // TODO parse version (jcil); CELEX, etc.\n    var nas = xmlNode.attributes;\n    if (nas['bwb-id']) {\n        htmlNode.attrs['href'] = '../reader/?bwbId=' + nas['bwb-id'];\n    }\n}\n\nfunction postMessageToSource(d) {\n    postMessage(d);\n}\n\n\n/**\n *\n * @param inStream xml input stream\n */\nfunction parse(inStream) {\n    var elementStack = [];\n    result = [];\n    var rootNode = createElement(\"article\", \"wetgeving\", {\n        'className': \"wetgeving legal-document wrapper\"\n    }, []);\n\n    function currentElHasIgnoredParent() {\n        if (peek(elementStack)) {\n            return peek(elementStack).ignored;\n        }\n        return false;\n    }\n\n    function shouldIgnore(name) {\n        return !!(!!ignoredElements[name] || !!currentElHasIgnoredParent());\n    }\n\n    function xmlNodeToHtmlNode(node) {\n        var nm = node.name;\n\n        if ('entry' == nm) {\n            if (peek(elementStack) && peek(elementStack).xml == 'thead')\n                return simpleNodeHtml('th', node);\n            if (peek(elementStack) && peek(elementStack).xml == 'tbody')\n                return simpleNodeHtml('td', node);\n            if (peek(elementStack) && peek(elementStack).xml == 'row')\n                return simpleNodeHtml('td', node);\n        }\n\n\n        // Check if there is a simple mapping\n        for (var tagName in htmlMappings) {\n            if (tagName == nm && htmlMappings.hasOwnProperty(tagName)) {\n                var htmlNod = simpleNodeHtml(htmlMappings[tagName], node);\n                if (tagName == 'extref') {\n                    setAnchor(node, htmlNod);\n                }\n                return htmlNod;\n            }\n        }\n\n        if ('tgroup' == nm) {\n            // TODO <tgroup align=\"left\" char=\"\" charoff=\"50\" cols=\"3\" colsep=\"0\" rowsep=\"0\">\n            return simpleNodeHtml('table', node);\n        }\n\n        if ('meta' == nm) {\n            // TODO handle meta tag\n        }\n\n        // Default: just make a <div>\n        return simpleNodeHtml('div', node);\n    }\n\n    var saxStream = sax.createStream(strict, options);\n    saxStream.on(\"error\", function (e) {\n        // unhandled errors will throw, since this is a proper node\n        // event emitter.\n        console.error(\"error!\", e);\n\n        // clear the error\n        this._parser.error = null;\n        this._parser.resume()\n    });\n\n    saxStream.on(\"text\", function (str) {\n        if (peek(elementStack) && !currentElHasIgnoredParent()) {\n            if (str.match(/^\\s+$/)) {\n                // Replace multiple whitespace characters by a single space\n                postMessageToSource([\"text\", _WHITESPACE]);\n            } else {\n                postMessageToSource([\"text\", str]);\n            }\n        }\n    });\n\n    saxStream.on(\"opentag\", function (node) {\n            //console.log(\"Open \"+node.name);\n\n            if (elementStack.length <= 0 && node.name != 'wetgeving') {\n                // We haven't even started yet\n            } else {\n                var newNode = {xml: node.name, ignored: shouldIgnore(node.name)};\n                elementStack.push(newNode);\n                //console.log(\"open \" + node.name + \" ignore: \" + shouldIgnore(node.name));\n                if (!newNode.ignored) {\n                    if (node.name == 'wetgeving') {\n                        /**\n                         * Root node\n                         */\n                            //console.log('rootnode set: ' + rootNode);\n                        newNode = rootNode;\n                    }\n\n                    if (elementStack.length > 0) {\n                        newNode = xmlNodeToHtmlNode(node);\n                    }\n\n                    postMessageToSource([\"opentag\", newNode]);\n                }\n            }\n        }\n    );\n\n    saxStream.on(\"closetag\", function (nodeName) {\n        //console.log(\"Close \" + nodeName);\n        if (elementStack.length <= 0) {\n            //Already done\n        } else {\n            var element = elementStack.pop();\n            if (nodeName != element.xml) {\n                console.error(\"Expected \" + element.xml + \", but read \" + nodeName);\n            }\n            if (!element.ignored) {\n                postMessageToSource([\"closetag\", nodeName]);\n            }\n        }\n    });\n    saxStream.on(\"end\", function () {\n        postMessage([\"end\", result]);\n    });\n\n    // Pipe stream to parser\n    inStream.pipe(saxStream);\n}\n\nonmessage = function (e) {\n    if (!e.data && e.data.length != 2) console.error(\"No data specified\");\n\n    var bwbId = e.data[0];\n    var expressionId = e.data[1];\n\n    var slowUrl = lawlyBot.URL_LAWLY_BOT + bwbId + '/' + expressionId +\n        '/xml/' + bwbId + \"_\" + expressionId + \".xml\";\n\n    https.get(slowUrl, parse);\n\n    console.log('Started parsing ' + (slowUrl));\n};\n","(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require==\"function\"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error(\"Cannot find module '\"+o+\"'\");throw f.code=\"MODULE_NOT_FOUND\",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require==\"function\"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(require,module,exports){\nvar sax = require(\"sax\");\nvar https = require(\"https\");\nvar escapeHtml = require('escape-html');\nvar lawlyBot = require('../../jsx/reader/backend/lawly-bot');\n//var Immutable = require('immutable');\n\nvar strict = true;\nvar options = {};\nvar _WHITESPACE = ' ';\n\n/**\n *\n * @param stack Given array\n * @returns {*} last element of given array\n */\nfunction peek(stack) {\n    return stack.length > 0 ? stack[stack.length - 1] : null;\n}\n\nvar ignoredElements = {\n    'jcis': true,\n    'jci': true,\n    'alias-titels': true,\n    'meta-data': true,\n    'metadata': true\n};\nvar htmlMappings = {\n    al: 'p',\n    lijst: 'ul',\n    nadruk: 'em',\n    intitule: 'h1',\n    titel: 'h3',\n    title: 'h3',\n    tussenkop: 'h3',\n    label: 'h3',\n    nr: 'h3',\n    lidnr: 'h4',\n    artikel: 'article',\n    dagtekening: 'div',\n    plaats: 'span',\n    datum: 'span',\n    functie: 'span',\n    redactie: 'span',\n    naam: 'span',\n    voornaam: 'span',\n    achternaam: 'span',\n    organisatie: 'span',\n    sup: 'sup',\n    sub: 'sub',\n    intref: 'a', // TODO handle intrefgroep\n    extref: 'a', // TODO handle extrefgroep\n    illustratie: 'img', // TODO properly handle get src url\n    table: 'div', // TODO handle the myriad table attrs\n    colspec: 'col',\n    thead: 'thead',\n    tfoot: 'tfoot',\n    entrytbl: 'table',\n    tbody: 'tbody',\n    li: 'li',\n    kop: 'header',\n    row: 'tr'\n};\n\n/**\n *\n * @param name tagname string\n * @param xmlTag xml tag name string\n * @param attrs string to string map\n * @param children Array of strings\n * @returns {{name: *, attrs: *, children: *}}\n */\nfunction createElement(name, xmlTag, attrs, children) {\n    return {\n        name: name,\n        xml: xmlTag,\n        attrs: attrs,\n        children: children\n    };\n}\n\nfunction setAttr(xmlKey, xmlAttrs, htmlKey, htmlAttrs) {\n    htmlAttrs[htmlKey] = escapeHtml(xmlAttrs[xmlKey]);\n}\nfunction getHtmlAttributes(node) {\n    var attrs = {\n        'className': node.name\n        //'data-xml-tag': xmlTag\n    };\n    var nas = node.attributes;\n    if (nas['bwb-ng-variabel-deel'] && !(node.name.match(/(int?|ext)ref/))) {\n        setAttr('bwb-ng-variabel-deel', nas, 'id', attrs);\n    } else if (nas['if']) {\n        setAttr('id', nas, 'id', attrs);\n    }\n\n    for (var key in nas) {\n        if (nas.hasOwnProperty(key))\n            if (key == 'id') {\n                setAttr(key, nas, 'data-id', attrs);\n            } else if (key == 'stam-id') {\n                setAttr(key, nas, 'data-stam-id', attrs);\n            } else if (key == 'versie-id') {\n                setAttr(key, nas, 'data-versie-id', attrs);\n            } else if (key == 'label-id') {\n                setAttr(key, nas, 'data-label-id', attrs);\n                //doc=\"32004L0017\" label=\"richtlijn\" reeks=\"Celex\"\n                //verwijzing-id=\"2556878\" doc=\"\" bwb-id=\"\" label-id=\"12115324\"\n            } else if (key == 'bwb-id') {\n                setAttr(key, nas, 'data-bwb-id', attrs);\n            } else if (key == 'verwijzing-id') {\n                setAttr(key, nas, 'data-verwijzing-id', attrs);\n            } else if (key == 'label') {\n                setAttr(key, nas, 'data-label', attrs);\n            } else if (key == 'reeks') {\n                setAttr(key, nas, 'data-reeks', attrs);\n            } else if (key == 'doc') {\n                setAttr(key, nas, 'data-doc', attrs);\n\n            } else {\n                //console.log(attr);\n            }\n    }\n    return attrs;\n}\n\nfunction simpleNodeHtml(htmlTag, node) {\n    return createElement(htmlTag, node.name, getHtmlAttributes(node), []);\n}\n\n\nfunction getAttributesAsString(attrs) {\n    if (attrs.length <= 0) {\n        return ''\n    } else {\n        var ss = [];\n        for (var key in attrs) {\n            if (attrs.hasOwnProperty(key))\n                ss.push('' + key + '=\"' + attrs[key] + '\"');\n        }\n        return ' ' + ss.join(' ');\n    }\n}\n\nfunction setAnchor(xmlNode, htmlNode) {\n    // TODO parse version (jcil); CELEX, etc.\n    var nas = xmlNode.attributes;\n    if (nas['bwb-id']) {\n        htmlNode.attrs['href'] = '../reader/?bwbId=' + nas['bwb-id'];\n    }\n}\n\nfunction postMessageToSource(d) {\n    postMessage(d);\n}\n\n\n/**\n *\n * @param inStream xml input stream\n */\nfunction parse(inStream) {\n    var elementStack = [];\n    result = [];\n    var rootNode = createElement(\"article\", \"wetgeving\", {\n        'className': \"wetgeving legal-document wrapper\"\n    }, []);\n\n    function currentElHasIgnoredParent() {\n        if (peek(elementStack)) {\n            return peek(elementStack).ignored;\n        }\n        return false;\n    }\n\n    function shouldIgnore(name) {\n        return !!(!!ignoredElements[name] || !!currentElHasIgnoredParent());\n    }\n\n    function xmlNodeToHtmlNode(node) {\n        var nm = node.name;\n\n        if ('entry' == nm) {\n            if (peek(elementStack) && peek(elementStack).xml == 'thead')\n                return simpleNodeHtml('th', node);\n            if (peek(elementStack) && peek(elementStack).xml == 'tbody')\n                return simpleNodeHtml('td', node);\n            if (peek(elementStack) && peek(elementStack).xml == 'row')\n                return simpleNodeHtml('td', node);\n        }\n\n\n        // Check if there is a simple mapping\n        for (var tagName in htmlMappings) {\n            if (tagName == nm && htmlMappings.hasOwnProperty(tagName)) {\n                var htmlNod = simpleNodeHtml(htmlMappings[tagName], node);\n                if (tagName == 'extref') {\n                    setAnchor(node, htmlNod);\n                }\n                return htmlNod;\n            }\n        }\n\n        if ('tgroup' == nm) {\n            // TODO <tgroup align=\"left\" char=\"\" charoff=\"50\" cols=\"3\" colsep=\"0\" rowsep=\"0\">\n            return simpleNodeHtml('table', node);\n        }\n\n        if ('meta' == nm) {\n            // TODO handle meta tag\n        }\n\n        // Default: just make a <div>\n        return simpleNodeHtml('div', node);\n    }\n\n    var saxStream = sax.createStream(strict, options);\n    saxStream.on(\"error\", function (e) {\n        // unhandled errors will throw, since this is a proper node\n        // event emitter.\n        console.error(\"error!\", e);\n\n        // clear the error\n        this._parser.error = null;\n        this._parser.resume()\n    });\n\n    saxStream.on(\"text\", function (str) {\n        if (peek(elementStack) && !currentElHasIgnoredParent()) {\n            if (str.match(/^\\s+$/)) {\n                // Replace multiple whitespace characters by a single space\n                postMessageToSource([\"text\", _WHITESPACE]);\n            } else {\n                postMessageToSource([\"text\", str]);\n            }\n        }\n    });\n\n    saxStream.on(\"opentag\", function (node) {\n            //console.log(\"Open \"+node.name);\n\n            if (elementStack.length <= 0 && node.name != 'wetgeving') {\n                // We haven't even started yet\n            } else {\n                var newNode = {xml: node.name, ignored: shouldIgnore(node.name)};\n                elementStack.push(newNode);\n                //console.log(\"open \" + node.name + \" ignore: \" + shouldIgnore(node.name));\n                if (!newNode.ignored) {\n                    if (node.name == 'wetgeving') {\n                        /**\n                         * Root node\n                         */\n                            //console.log('rootnode set: ' + rootNode);\n                        newNode = rootNode;\n                    }\n\n                    if (elementStack.length > 0) {\n                        newNode = xmlNodeToHtmlNode(node);\n                    }\n\n                    postMessageToSource([\"opentag\", newNode]);\n                }\n            }\n        }\n    );\n\n    saxStream.on(\"closetag\", function (nodeName) {\n        //console.log(\"Close \" + nodeName);\n        if (elementStack.length <= 0) {\n            //Already done\n        } else {\n            var element = elementStack.pop();\n            if (nodeName != element.xml) {\n                console.error(\"Expected \" + element.xml + \", but read \" + nodeName);\n            }\n            if (!element.ignored) {\n                postMessageToSource([\"closetag\", nodeName]);\n            }\n        }\n    });\n    saxStream.on(\"end\", function () {\n        postMessage([\"end\", result]);\n    });\n\n    // Pipe stream to parser\n    inStream.pipe(saxStream);\n}\n\nonmessage = function (e) {\n    if (!e.data && e.data.length != 2) console.error(\"No data specified\");\n\n    var bwbId = e.data[0];\n    var expressionId = e.data[1];\n\n    var slowUrl = lawlyBot.URL_LAWLY_BOT + bwbId + '/' + expressionId +\n        '/xml/' + bwbId + \"_\" + expressionId + \".xml\";\n\n    https.get(slowUrl, parse);\n\n    console.log('Started parsing ' + (slowUrl));\n};\n\n},{\"../../jsx/reader/backend/lawly-bot\":2,\"escape-html\":41,\"https\":9,\"sax\":42}],2:[function(require,module,exports){\nconst URL_LAWLY_BOT_HOST = 'lawlybot.herokuapp.com',\n    URL_LAWLY_BOT_API_PATH = '/api/bwb/',\n    URL_LAWLY_BOT = 'https://' + URL_LAWLY_BOT_HOST + URL_LAWLY_BOT_API_PATH;\n\nmodule.exports = {\n    URL_LAWLY_BOT_HOST: URL_LAWLY_BOT_HOST,\n    URL_LAWLY_BOT_API_PATH: URL_LAWLY_BOT_API_PATH,\n    URL_LAWLY_BOT: URL_LAWLY_BOT\n};\n\n},{}],3:[function(require,module,exports){\n\n},{}],4:[function(require,module,exports){\n(function (global){\n/*!\n * The buffer module from node.js, for the browser.\n *\n * @author   Feross Aboukhadijeh <feross@feross.org> <http://feross.org>\n * @license  MIT\n */\n/* eslint-disable no-proto */\n\nvar base64 = require('base64-js')\nvar ieee754 = require('ieee754')\nvar isArray = require('isarray')\n\nexports.Buffer = Buffer\nexports.SlowBuffer = SlowBuffer\nexports.INSPECT_MAX_BYTES = 50\nBuffer.poolSize = 8192 // not used by this implementation\n\nvar rootParent = {}\n\n/**\n * If `Buffer.TYPED_ARRAY_SUPPORT`:\n *   === true    Use Uint8Array implementation (fastest)\n *   === false   Use Object implementation (most compatible, even IE6)\n *\n * Browsers that support typed arrays are IE 10+, Firefox 4+, Chrome 7+, Safari 5.1+,\n * Opera 11.6+, iOS 4.2+.\n *\n * Due to various browser bugs, sometimes the Object implementation will be used even\n * when the browser supports typed arrays.\n *\n * Note:\n *\n *   - Firefox 4-29 lacks support for adding new properties to `Uint8Array` instances,\n *     See: https://bugzilla.mozilla.org/show_bug.cgi?id=695438.\n *\n *   - Safari 5-7 lacks support for changing the `Object.prototype.constructor` property\n *     on objects.\n *\n *   - Chrome 9-10 is missing the `TypedArray.prototype.subarray` function.\n *\n *   - IE10 has a broken `TypedArray.prototype.subarray` function which returns arrays of\n *     incorrect length in some situations.\n\n * We detect these buggy browsers and set `Buffer.TYPED_ARRAY_SUPPORT` to `false` so they\n * get the Object implementation, which is slower but behaves correctly.\n */\nBuffer.TYPED_ARRAY_SUPPORT = global.TYPED_ARRAY_SUPPORT !== undefined\n  ? global.TYPED_ARRAY_SUPPORT\n  : typedArraySupport()\n\nfunction typedArraySupport () {\n  function Bar () {}\n  try {\n    var arr = new Uint8Array(1)\n    arr.foo = function () { return 42 }\n    arr.constructor = Bar\n    return arr.foo() === 42 && // typed array instances can be augmented\n        arr.constructor === Bar && // constructor can be set\n        typeof arr.subarray === 'function' && // chrome 9-10 lack `subarray`\n        arr.subarray(1, 1).byteLength === 0 // ie10 has broken `subarray`\n  } catch (e) {\n    return false\n  }\n}\n\nfunction kMaxLength () {\n  return Buffer.TYPED_ARRAY_SUPPORT\n    ? 0x7fffffff\n    : 0x3fffffff\n}\n\n/**\n * Class: Buffer\n * =============\n *\n * The Buffer constructor returns instances of `Uint8Array` that are augmented\n * with function properties for all the node `Buffer` API functions. We use\n * `Uint8Array` so that square bracket notation works as expected -- it returns\n * a single octet.\n *\n * By augmenting the instances, we can avoid modifying the `Uint8Array`\n * prototype.\n */\nfunction Buffer (arg) {\n  if (!(this instanceof Buffer)) {\n    // Avoid going through an ArgumentsAdaptorTrampoline in the common case.\n    if (arguments.length > 1) return new Buffer(arg, arguments[1])\n    return new Buffer(arg)\n  }\n\n  this.length = 0\n  this.parent = undefined\n\n  // Common case.\n  if (typeof arg === 'number') {\n    return fromNumber(this, arg)\n  }\n\n  // Slightly less common case.\n  if (typeof arg === 'string') {\n    return fromString(this, arg, arguments.length > 1 ? arguments[1] : 'utf8')\n  }\n\n  // Unusual.\n  return fromObject(this, arg)\n}\n\nfunction fromNumber (that, length) {\n  that = allocate(that, length < 0 ? 0 : checked(length) | 0)\n  if (!Buffer.TYPED_ARRAY_SUPPORT) {\n    for (var i = 0; i < length; i++) {\n      that[i] = 0\n    }\n  }\n  return that\n}\n\nfunction fromString (that, string, encoding) {\n  if (typeof encoding !== 'string' || encoding === '') encoding = 'utf8'\n\n  // Assumption: byteLength() return value is always < kMaxLength.\n  var length = byteLength(string, encoding) | 0\n  that = allocate(that, length)\n\n  that.write(string, encoding)\n  return that\n}\n\nfunction fromObject (that, object) {\n  if (Buffer.isBuffer(object)) return fromBuffer(that, object)\n\n  if (isArray(object)) return fromArray(that, object)\n\n  if (object == null) {\n    throw new TypeError('must start with number, buffer, array or string')\n  }\n\n  if (typeof ArrayBuffer !== 'undefined') {\n    if (object.buffer instanceof ArrayBuffer) {\n      return fromTypedArray(that, object)\n    }\n    if (object instanceof ArrayBuffer) {\n      return fromArrayBuffer(that, object)\n    }\n  }\n\n  if (object.length) return fromArrayLike(that, object)\n\n  return fromJsonObject(that, object)\n}\n\nfunction fromBuffer (that, buffer) {\n  var length = checked(buffer.length) | 0\n  that = allocate(that, length)\n  buffer.copy(that, 0, 0, length)\n  return that\n}\n\nfunction fromArray (that, array) {\n  var length = checked(array.length) | 0\n  that = allocate(that, length)\n  for (var i = 0; i < length; i += 1) {\n    that[i] = array[i] & 255\n  }\n  return that\n}\n\n// Duplicate of fromArray() to keep fromArray() monomorphic.\nfunction fromTypedArray (that, array) {\n  var length = checked(array.length) | 0\n  that = allocate(that, length)\n  // Truncating the elements is probably not what people expect from typed\n  // arrays with BYTES_PER_ELEMENT > 1 but it's compatible with the behavior\n  // of the old Buffer constructor.\n  for (var i = 0; i < length; i += 1) {\n    that[i] = array[i] & 255\n  }\n  return that\n}\n\nfunction fromArrayBuffer (that, array) {\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    // Return an augmented `Uint8Array` instance, for best performance\n    array.byteLength\n    that = Buffer._augment(new Uint8Array(array))\n  } else {\n    // Fallback: Return an object instance of the Buffer class\n    that = fromTypedArray(that, new Uint8Array(array))\n  }\n  return that\n}\n\nfunction fromArrayLike (that, array) {\n  var length = checked(array.length) | 0\n  that = allocate(that, length)\n  for (var i = 0; i < length; i += 1) {\n    that[i] = array[i] & 255\n  }\n  return that\n}\n\n// Deserialize { type: 'Buffer', data: [1,2,3,...] } into a Buffer object.\n// Returns a zero-length buffer for inputs that don't conform to the spec.\nfunction fromJsonObject (that, object) {\n  var array\n  var length = 0\n\n  if (object.type === 'Buffer' && isArray(object.data)) {\n    array = object.data\n    length = checked(array.length) | 0\n  }\n  that = allocate(that, length)\n\n  for (var i = 0; i < length; i += 1) {\n    that[i] = array[i] & 255\n  }\n  return that\n}\n\nif (Buffer.TYPED_ARRAY_SUPPORT) {\n  Buffer.prototype.__proto__ = Uint8Array.prototype\n  Buffer.__proto__ = Uint8Array\n}\n\nfunction allocate (that, length) {\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    // Return an augmented `Uint8Array` instance, for best performance\n    that = Buffer._augment(new Uint8Array(length))\n    that.__proto__ = Buffer.prototype\n  } else {\n    // Fallback: Return an object instance of the Buffer class\n    that.length = length\n    that._isBuffer = true\n  }\n\n  var fromPool = length !== 0 && length <= Buffer.poolSize >>> 1\n  if (fromPool) that.parent = rootParent\n\n  return that\n}\n\nfunction checked (length) {\n  // Note: cannot use `length < kMaxLength` here because that fails when\n  // length is NaN (which is otherwise coerced to zero.)\n  if (length >= kMaxLength()) {\n    throw new RangeError('Attempt to allocate Buffer larger than maximum ' +\n                         'size: 0x' + kMaxLength().toString(16) + ' bytes')\n  }\n  return length | 0\n}\n\nfunction SlowBuffer (subject, encoding) {\n  if (!(this instanceof SlowBuffer)) return new SlowBuffer(subject, encoding)\n\n  var buf = new Buffer(subject, encoding)\n  delete buf.parent\n  return buf\n}\n\nBuffer.isBuffer = function isBuffer (b) {\n  return !!(b != null && b._isBuffer)\n}\n\nBuffer.compare = function compare (a, b) {\n  if (!Buffer.isBuffer(a) || !Buffer.isBuffer(b)) {\n    throw new TypeError('Arguments must be Buffers')\n  }\n\n  if (a === b) return 0\n\n  var x = a.length\n  var y = b.length\n\n  var i = 0\n  var len = Math.min(x, y)\n  while (i < len) {\n    if (a[i] !== b[i]) break\n\n    ++i\n  }\n\n  if (i !== len) {\n    x = a[i]\n    y = b[i]\n  }\n\n  if (x < y) return -1\n  if (y < x) return 1\n  return 0\n}\n\nBuffer.isEncoding = function isEncoding (encoding) {\n  switch (String(encoding).toLowerCase()) {\n    case 'hex':\n    case 'utf8':\n    case 'utf-8':\n    case 'ascii':\n    case 'binary':\n    case 'base64':\n    case 'raw':\n    case 'ucs2':\n    case 'ucs-2':\n    case 'utf16le':\n    case 'utf-16le':\n      return true\n    default:\n      return false\n  }\n}\n\nBuffer.concat = function concat (list, length) {\n  if (!isArray(list)) throw new TypeError('list argument must be an Array of Buffers.')\n\n  if (list.length === 0) {\n    return new Buffer(0)\n  }\n\n  var i\n  if (length === undefined) {\n    length = 0\n    for (i = 0; i < list.length; i++) {\n      length += list[i].length\n    }\n  }\n\n  var buf = new Buffer(length)\n  var pos = 0\n  for (i = 0; i < list.length; i++) {\n    var item = list[i]\n    item.copy(buf, pos)\n    pos += item.length\n  }\n  return buf\n}\n\nfunction byteLength (string, encoding) {\n  if (typeof string !== 'string') string = '' + string\n\n  var len = string.length\n  if (len === 0) return 0\n\n  // Use a for loop to avoid recursion\n  var loweredCase = false\n  for (;;) {\n    switch (encoding) {\n      case 'ascii':\n      case 'binary':\n      // Deprecated\n      case 'raw':\n      case 'raws':\n        return len\n      case 'utf8':\n      case 'utf-8':\n        return utf8ToBytes(string).length\n      case 'ucs2':\n      case 'ucs-2':\n      case 'utf16le':\n      case 'utf-16le':\n        return len * 2\n      case 'hex':\n        return len >>> 1\n      case 'base64':\n        return base64ToBytes(string).length\n      default:\n        if (loweredCase) return utf8ToBytes(string).length // assume utf8\n        encoding = ('' + encoding).toLowerCase()\n        loweredCase = true\n    }\n  }\n}\nBuffer.byteLength = byteLength\n\n// pre-set for values that may exist in the future\nBuffer.prototype.length = undefined\nBuffer.prototype.parent = undefined\n\nfunction slowToString (encoding, start, end) {\n  var loweredCase = false\n\n  start = start | 0\n  end = end === undefined || end === Infinity ? this.length : end | 0\n\n  if (!encoding) encoding = 'utf8'\n  if (start < 0) start = 0\n  if (end > this.length) end = this.length\n  if (end <= start) return ''\n\n  while (true) {\n    switch (encoding) {\n      case 'hex':\n        return hexSlice(this, start, end)\n\n      case 'utf8':\n      case 'utf-8':\n        return utf8Slice(this, start, end)\n\n      case 'ascii':\n        return asciiSlice(this, start, end)\n\n      case 'binary':\n        return binarySlice(this, start, end)\n\n      case 'base64':\n        return base64Slice(this, start, end)\n\n      case 'ucs2':\n      case 'ucs-2':\n      case 'utf16le':\n      case 'utf-16le':\n        return utf16leSlice(this, start, end)\n\n      default:\n        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)\n        encoding = (encoding + '').toLowerCase()\n        loweredCase = true\n    }\n  }\n}\n\nBuffer.prototype.toString = function toString () {\n  var length = this.length | 0\n  if (length === 0) return ''\n  if (arguments.length === 0) return utf8Slice(this, 0, length)\n  return slowToString.apply(this, arguments)\n}\n\nBuffer.prototype.equals = function equals (b) {\n  if (!Buffer.isBuffer(b)) throw new TypeError('Argument must be a Buffer')\n  if (this === b) return true\n  return Buffer.compare(this, b) === 0\n}\n\nBuffer.prototype.inspect = function inspect () {\n  var str = ''\n  var max = exports.INSPECT_MAX_BYTES\n  if (this.length > 0) {\n    str = this.toString('hex', 0, max).match(/.{2}/g).join(' ')\n    if (this.length > max) str += ' ... '\n  }\n  return '<Buffer ' + str + '>'\n}\n\nBuffer.prototype.compare = function compare (b) {\n  if (!Buffer.isBuffer(b)) throw new TypeError('Argument must be a Buffer')\n  if (this === b) return 0\n  return Buffer.compare(this, b)\n}\n\nBuffer.prototype.indexOf = function indexOf (val, byteOffset) {\n  if (byteOffset > 0x7fffffff) byteOffset = 0x7fffffff\n  else if (byteOffset < -0x80000000) byteOffset = -0x80000000\n  byteOffset >>= 0\n\n  if (this.length === 0) return -1\n  if (byteOffset >= this.length) return -1\n\n  // Negative offsets start from the end of the buffer\n  if (byteOffset < 0) byteOffset = Math.max(this.length + byteOffset, 0)\n\n  if (typeof val === 'string') {\n    if (val.length === 0) return -1 // special case: looking for empty string always fails\n    return String.prototype.indexOf.call(this, val, byteOffset)\n  }\n  if (Buffer.isBuffer(val)) {\n    return arrayIndexOf(this, val, byteOffset)\n  }\n  if (typeof val === 'number') {\n    if (Buffer.TYPED_ARRAY_SUPPORT && Uint8Array.prototype.indexOf === 'function') {\n      return Uint8Array.prototype.indexOf.call(this, val, byteOffset)\n    }\n    return arrayIndexOf(this, [ val ], byteOffset)\n  }\n\n  function arrayIndexOf (arr, val, byteOffset) {\n    var foundIndex = -1\n    for (var i = 0; byteOffset + i < arr.length; i++) {\n      if (arr[byteOffset + i] === val[foundIndex === -1 ? 0 : i - foundIndex]) {\n        if (foundIndex === -1) foundIndex = i\n        if (i - foundIndex + 1 === val.length) return byteOffset + foundIndex\n      } else {\n        foundIndex = -1\n      }\n    }\n    return -1\n  }\n\n  throw new TypeError('val must be string, number or Buffer')\n}\n\n// `get` is deprecated\nBuffer.prototype.get = function get (offset) {\n  console.log('.get() is deprecated. Access using array indexes instead.')\n  return this.readUInt8(offset)\n}\n\n// `set` is deprecated\nBuffer.prototype.set = function set (v, offset) {\n  console.log('.set() is deprecated. Access using array indexes instead.')\n  return this.writeUInt8(v, offset)\n}\n\nfunction hexWrite (buf, string, offset, length) {\n  offset = Number(offset) || 0\n  var remaining = buf.length - offset\n  if (!length) {\n    length = remaining\n  } else {\n    length = Number(length)\n    if (length > remaining) {\n      length = remaining\n    }\n  }\n\n  // must be an even number of digits\n  var strLen = string.length\n  if (strLen % 2 !== 0) throw new Error('Invalid hex string')\n\n  if (length > strLen / 2) {\n    length = strLen / 2\n  }\n  for (var i = 0; i < length; i++) {\n    var parsed = parseInt(string.substr(i * 2, 2), 16)\n    if (isNaN(parsed)) throw new Error('Invalid hex string')\n    buf[offset + i] = parsed\n  }\n  return i\n}\n\nfunction utf8Write (buf, string, offset, length) {\n  return blitBuffer(utf8ToBytes(string, buf.length - offset), buf, offset, length)\n}\n\nfunction asciiWrite (buf, string, offset, length) {\n  return blitBuffer(asciiToBytes(string), buf, offset, length)\n}\n\nfunction binaryWrite (buf, string, offset, length) {\n  return asciiWrite(buf, string, offset, length)\n}\n\nfunction base64Write (buf, string, offset, length) {\n  return blitBuffer(base64ToBytes(string), buf, offset, length)\n}\n\nfunction ucs2Write (buf, string, offset, length) {\n  return blitBuffer(utf16leToBytes(string, buf.length - offset), buf, offset, length)\n}\n\nBuffer.prototype.write = function write (string, offset, length, encoding) {\n  // Buffer#write(string)\n  if (offset === undefined) {\n    encoding = 'utf8'\n    length = this.length\n    offset = 0\n  // Buffer#write(string, encoding)\n  } else if (length === undefined && typeof offset === 'string') {\n    encoding = offset\n    length = this.length\n    offset = 0\n  // Buffer#write(string, offset[, length][, encoding])\n  } else if (isFinite(offset)) {\n    offset = offset | 0\n    if (isFinite(length)) {\n      length = length | 0\n      if (encoding === undefined) encoding = 'utf8'\n    } else {\n      encoding = length\n      length = undefined\n    }\n  // legacy write(string, encoding, offset, length) - remove in v0.13\n  } else {\n    var swap = encoding\n    encoding = offset\n    offset = length | 0\n    length = swap\n  }\n\n  var remaining = this.length - offset\n  if (length === undefined || length > remaining) length = remaining\n\n  if ((string.length > 0 && (length < 0 || offset < 0)) || offset > this.length) {\n    throw new RangeError('attempt to write outside buffer bounds')\n  }\n\n  if (!encoding) encoding = 'utf8'\n\n  var loweredCase = false\n  for (;;) {\n    switch (encoding) {\n      case 'hex':\n        return hexWrite(this, string, offset, length)\n\n      case 'utf8':\n      case 'utf-8':\n        return utf8Write(this, string, offset, length)\n\n      case 'ascii':\n        return asciiWrite(this, string, offset, length)\n\n      case 'binary':\n        return binaryWrite(this, string, offset, length)\n\n      case 'base64':\n        // Warning: maxLength not taken into account in base64Write\n        return base64Write(this, string, offset, length)\n\n      case 'ucs2':\n      case 'ucs-2':\n      case 'utf16le':\n      case 'utf-16le':\n        return ucs2Write(this, string, offset, length)\n\n      default:\n        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)\n        encoding = ('' + encoding).toLowerCase()\n        loweredCase = true\n    }\n  }\n}\n\nBuffer.prototype.toJSON = function toJSON () {\n  return {\n    type: 'Buffer',\n    data: Array.prototype.slice.call(this._arr || this, 0)\n  }\n}\n\nfunction base64Slice (buf, start, end) {\n  if (start === 0 && end === buf.length) {\n    return base64.fromByteArray(buf)\n  } else {\n    return base64.fromByteArray(buf.slice(start, end))\n  }\n}\n\nfunction utf8Slice (buf, start, end) {\n  end = Math.min(buf.length, end)\n  var res = []\n\n  var i = start\n  while (i < end) {\n    var firstByte = buf[i]\n    var codePoint = null\n    var bytesPerSequence = (firstByte > 0xEF) ? 4\n      : (firstByte > 0xDF) ? 3\n      : (firstByte > 0xBF) ? 2\n      : 1\n\n    if (i + bytesPerSequence <= end) {\n      var secondByte, thirdByte, fourthByte, tempCodePoint\n\n      switch (bytesPerSequence) {\n        case 1:\n          if (firstByte < 0x80) {\n            codePoint = firstByte\n          }\n          break\n        case 2:\n          secondByte = buf[i + 1]\n          if ((secondByte & 0xC0) === 0x80) {\n            tempCodePoint = (firstByte & 0x1F) << 0x6 | (secondByte & 0x3F)\n            if (tempCodePoint > 0x7F) {\n              codePoint = tempCodePoint\n            }\n          }\n          break\n        case 3:\n          secondByte = buf[i + 1]\n          thirdByte = buf[i + 2]\n          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80) {\n            tempCodePoint = (firstByte & 0xF) << 0xC | (secondByte & 0x3F) << 0x6 | (thirdByte & 0x3F)\n            if (tempCodePoint > 0x7FF && (tempCodePoint < 0xD800 || tempCodePoint > 0xDFFF)) {\n              codePoint = tempCodePoint\n            }\n          }\n          break\n        case 4:\n          secondByte = buf[i + 1]\n          thirdByte = buf[i + 2]\n          fourthByte = buf[i + 3]\n          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80 && (fourthByte & 0xC0) === 0x80) {\n            tempCodePoint = (firstByte & 0xF) << 0x12 | (secondByte & 0x3F) << 0xC | (thirdByte & 0x3F) << 0x6 | (fourthByte & 0x3F)\n            if (tempCodePoint > 0xFFFF && tempCodePoint < 0x110000) {\n              codePoint = tempCodePoint\n            }\n          }\n      }\n    }\n\n    if (codePoint === null) {\n      // we did not generate a valid codePoint so insert a\n      // replacement char (U+FFFD) and advance only 1 byte\n      codePoint = 0xFFFD\n      bytesPerSequence = 1\n    } else if (codePoint > 0xFFFF) {\n      // encode to utf16 (surrogate pair dance)\n      codePoint -= 0x10000\n      res.push(codePoint >>> 10 & 0x3FF | 0xD800)\n      codePoint = 0xDC00 | codePoint & 0x3FF\n    }\n\n    res.push(codePoint)\n    i += bytesPerSequence\n  }\n\n  return decodeCodePointsArray(res)\n}\n\n// Based on http://stackoverflow.com/a/22747272/680742, the browser with\n// the lowest limit is Chrome, with 0x10000 args.\n// We go 1 magnitude less, for safety\nvar MAX_ARGUMENTS_LENGTH = 0x1000\n\nfunction decodeCodePointsArray (codePoints) {\n  var len = codePoints.length\n  if (len <= MAX_ARGUMENTS_LENGTH) {\n    return String.fromCharCode.apply(String, codePoints) // avoid extra slice()\n  }\n\n  // Decode in chunks to avoid \"call stack size exceeded\".\n  var res = ''\n  var i = 0\n  while (i < len) {\n    res += String.fromCharCode.apply(\n      String,\n      codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH)\n    )\n  }\n  return res\n}\n\nfunction asciiSlice (buf, start, end) {\n  var ret = ''\n  end = Math.min(buf.length, end)\n\n  for (var i = start; i < end; i++) {\n    ret += String.fromCharCode(buf[i] & 0x7F)\n  }\n  return ret\n}\n\nfunction binarySlice (buf, start, end) {\n  var ret = ''\n  end = Math.min(buf.length, end)\n\n  for (var i = start; i < end; i++) {\n    ret += String.fromCharCode(buf[i])\n  }\n  return ret\n}\n\nfunction hexSlice (buf, start, end) {\n  var len = buf.length\n\n  if (!start || start < 0) start = 0\n  if (!end || end < 0 || end > len) end = len\n\n  var out = ''\n  for (var i = start; i < end; i++) {\n    out += toHex(buf[i])\n  }\n  return out\n}\n\nfunction utf16leSlice (buf, start, end) {\n  var bytes = buf.slice(start, end)\n  var res = ''\n  for (var i = 0; i < bytes.length; i += 2) {\n    res += String.fromCharCode(bytes[i] + bytes[i + 1] * 256)\n  }\n  return res\n}\n\nBuffer.prototype.slice = function slice (start, end) {\n  var len = this.length\n  start = ~~start\n  end = end === undefined ? len : ~~end\n\n  if (start < 0) {\n    start += len\n    if (start < 0) start = 0\n  } else if (start > len) {\n    start = len\n  }\n\n  if (end < 0) {\n    end += len\n    if (end < 0) end = 0\n  } else if (end > len) {\n    end = len\n  }\n\n  if (end < start) end = start\n\n  var newBuf\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    newBuf = Buffer._augment(this.subarray(start, end))\n  } else {\n    var sliceLen = end - start\n    newBuf = new Buffer(sliceLen, undefined)\n    for (var i = 0; i < sliceLen; i++) {\n      newBuf[i] = this[i + start]\n    }\n  }\n\n  if (newBuf.length) newBuf.parent = this.parent || this\n\n  return newBuf\n}\n\n/*\n * Need to make sure that buffer isn't trying to write out of bounds.\n */\nfunction checkOffset (offset, ext, length) {\n  if ((offset % 1) !== 0 || offset < 0) throw new RangeError('offset is not uint')\n  if (offset + ext > length) throw new RangeError('Trying to access beyond buffer length')\n}\n\nBuffer.prototype.readUIntLE = function readUIntLE (offset, byteLength, noAssert) {\n  offset = offset | 0\n  byteLength = byteLength | 0\n  if (!noAssert) checkOffset(offset, byteLength, this.length)\n\n  var val = this[offset]\n  var mul = 1\n  var i = 0\n  while (++i < byteLength && (mul *= 0x100)) {\n    val += this[offset + i] * mul\n  }\n\n  return val\n}\n\nBuffer.prototype.readUIntBE = function readUIntBE (offset, byteLength, noAssert) {\n  offset = offset | 0\n  byteLength = byteLength | 0\n  if (!noAssert) {\n    checkOffset(offset, byteLength, this.length)\n  }\n\n  var val = this[offset + --byteLength]\n  var mul = 1\n  while (byteLength > 0 && (mul *= 0x100)) {\n    val += this[offset + --byteLength] * mul\n  }\n\n  return val\n}\n\nBuffer.prototype.readUInt8 = function readUInt8 (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 1, this.length)\n  return this[offset]\n}\n\nBuffer.prototype.readUInt16LE = function readUInt16LE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 2, this.length)\n  return this[offset] | (this[offset + 1] << 8)\n}\n\nBuffer.prototype.readUInt16BE = function readUInt16BE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 2, this.length)\n  return (this[offset] << 8) | this[offset + 1]\n}\n\nBuffer.prototype.readUInt32LE = function readUInt32LE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 4, this.length)\n\n  return ((this[offset]) |\n      (this[offset + 1] << 8) |\n      (this[offset + 2] << 16)) +\n      (this[offset + 3] * 0x1000000)\n}\n\nBuffer.prototype.readUInt32BE = function readUInt32BE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 4, this.length)\n\n  return (this[offset] * 0x1000000) +\n    ((this[offset + 1] << 16) |\n    (this[offset + 2] << 8) |\n    this[offset + 3])\n}\n\nBuffer.prototype.readIntLE = function readIntLE (offset, byteLength, noAssert) {\n  offset = offset | 0\n  byteLength = byteLength | 0\n  if (!noAssert) checkOffset(offset, byteLength, this.length)\n\n  var val = this[offset]\n  var mul = 1\n  var i = 0\n  while (++i < byteLength && (mul *= 0x100)) {\n    val += this[offset + i] * mul\n  }\n  mul *= 0x80\n\n  if (val >= mul) val -= Math.pow(2, 8 * byteLength)\n\n  return val\n}\n\nBuffer.prototype.readIntBE = function readIntBE (offset, byteLength, noAssert) {\n  offset = offset | 0\n  byteLength = byteLength | 0\n  if (!noAssert) checkOffset(offset, byteLength, this.length)\n\n  var i = byteLength\n  var mul = 1\n  var val = this[offset + --i]\n  while (i > 0 && (mul *= 0x100)) {\n    val += this[offset + --i] * mul\n  }\n  mul *= 0x80\n\n  if (val >= mul) val -= Math.pow(2, 8 * byteLength)\n\n  return val\n}\n\nBuffer.prototype.readInt8 = function readInt8 (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 1, this.length)\n  if (!(this[offset] & 0x80)) return (this[offset])\n  return ((0xff - this[offset] + 1) * -1)\n}\n\nBuffer.prototype.readInt16LE = function readInt16LE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 2, this.length)\n  var val = this[offset] | (this[offset + 1] << 8)\n  return (val & 0x8000) ? val | 0xFFFF0000 : val\n}\n\nBuffer.prototype.readInt16BE = function readInt16BE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 2, this.length)\n  var val = this[offset + 1] | (this[offset] << 8)\n  return (val & 0x8000) ? val | 0xFFFF0000 : val\n}\n\nBuffer.prototype.readInt32LE = function readInt32LE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 4, this.length)\n\n  return (this[offset]) |\n    (this[offset + 1] << 8) |\n    (this[offset + 2] << 16) |\n    (this[offset + 3] << 24)\n}\n\nBuffer.prototype.readInt32BE = function readInt32BE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 4, this.length)\n\n  return (this[offset] << 24) |\n    (this[offset + 1] << 16) |\n    (this[offset + 2] << 8) |\n    (this[offset + 3])\n}\n\nBuffer.prototype.readFloatLE = function readFloatLE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 4, this.length)\n  return ieee754.read(this, offset, true, 23, 4)\n}\n\nBuffer.prototype.readFloatBE = function readFloatBE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 4, this.length)\n  return ieee754.read(this, offset, false, 23, 4)\n}\n\nBuffer.prototype.readDoubleLE = function readDoubleLE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 8, this.length)\n  return ieee754.read(this, offset, true, 52, 8)\n}\n\nBuffer.prototype.readDoubleBE = function readDoubleBE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 8, this.length)\n  return ieee754.read(this, offset, false, 52, 8)\n}\n\nfunction checkInt (buf, value, offset, ext, max, min) {\n  if (!Buffer.isBuffer(buf)) throw new TypeError('buffer must be a Buffer instance')\n  if (value > max || value < min) throw new RangeError('value is out of bounds')\n  if (offset + ext > buf.length) throw new RangeError('index out of range')\n}\n\nBuffer.prototype.writeUIntLE = function writeUIntLE (value, offset, byteLength, noAssert) {\n  value = +value\n  offset = offset | 0\n  byteLength = byteLength | 0\n  if (!noAssert) checkInt(this, value, offset, byteLength, Math.pow(2, 8 * byteLength), 0)\n\n  var mul = 1\n  var i = 0\n  this[offset] = value & 0xFF\n  while (++i < byteLength && (mul *= 0x100)) {\n    this[offset + i] = (value / mul) & 0xFF\n  }\n\n  return offset + byteLength\n}\n\nBuffer.prototype.writeUIntBE = function writeUIntBE (value, offset, byteLength, noAssert) {\n  value = +value\n  offset = offset | 0\n  byteLength = byteLength | 0\n  if (!noAssert) checkInt(this, value, offset, byteLength, Math.pow(2, 8 * byteLength), 0)\n\n  var i = byteLength - 1\n  var mul = 1\n  this[offset + i] = value & 0xFF\n  while (--i >= 0 && (mul *= 0x100)) {\n    this[offset + i] = (value / mul) & 0xFF\n  }\n\n  return offset + byteLength\n}\n\nBuffer.prototype.writeUInt8 = function writeUInt8 (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 1, 0xff, 0)\n  if (!Buffer.TYPED_ARRAY_SUPPORT) value = Math.floor(value)\n  this[offset] = (value & 0xff)\n  return offset + 1\n}\n\nfunction objectWriteUInt16 (buf, value, offset, littleEndian) {\n  if (value < 0) value = 0xffff + value + 1\n  for (var i = 0, j = Math.min(buf.length - offset, 2); i < j; i++) {\n    buf[offset + i] = (value & (0xff << (8 * (littleEndian ? i : 1 - i)))) >>>\n      (littleEndian ? i : 1 - i) * 8\n  }\n}\n\nBuffer.prototype.writeUInt16LE = function writeUInt16LE (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    this[offset] = (value & 0xff)\n    this[offset + 1] = (value >>> 8)\n  } else {\n    objectWriteUInt16(this, value, offset, true)\n  }\n  return offset + 2\n}\n\nBuffer.prototype.writeUInt16BE = function writeUInt16BE (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    this[offset] = (value >>> 8)\n    this[offset + 1] = (value & 0xff)\n  } else {\n    objectWriteUInt16(this, value, offset, false)\n  }\n  return offset + 2\n}\n\nfunction objectWriteUInt32 (buf, value, offset, littleEndian) {\n  if (value < 0) value = 0xffffffff + value + 1\n  for (var i = 0, j = Math.min(buf.length - offset, 4); i < j; i++) {\n    buf[offset + i] = (value >>> (littleEndian ? i : 3 - i) * 8) & 0xff\n  }\n}\n\nBuffer.prototype.writeUInt32LE = function writeUInt32LE (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    this[offset + 3] = (value >>> 24)\n    this[offset + 2] = (value >>> 16)\n    this[offset + 1] = (value >>> 8)\n    this[offset] = (value & 0xff)\n  } else {\n    objectWriteUInt32(this, value, offset, true)\n  }\n  return offset + 4\n}\n\nBuffer.prototype.writeUInt32BE = function writeUInt32BE (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    this[offset] = (value >>> 24)\n    this[offset + 1] = (value >>> 16)\n    this[offset + 2] = (value >>> 8)\n    this[offset + 3] = (value & 0xff)\n  } else {\n    objectWriteUInt32(this, value, offset, false)\n  }\n  return offset + 4\n}\n\nBuffer.prototype.writeIntLE = function writeIntLE (value, offset, byteLength, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) {\n    var limit = Math.pow(2, 8 * byteLength - 1)\n\n    checkInt(this, value, offset, byteLength, limit - 1, -limit)\n  }\n\n  var i = 0\n  var mul = 1\n  var sub = value < 0 ? 1 : 0\n  this[offset] = value & 0xFF\n  while (++i < byteLength && (mul *= 0x100)) {\n    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF\n  }\n\n  return offset + byteLength\n}\n\nBuffer.prototype.writeIntBE = function writeIntBE (value, offset, byteLength, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) {\n    var limit = Math.pow(2, 8 * byteLength - 1)\n\n    checkInt(this, value, offset, byteLength, limit - 1, -limit)\n  }\n\n  var i = byteLength - 1\n  var mul = 1\n  var sub = value < 0 ? 1 : 0\n  this[offset + i] = value & 0xFF\n  while (--i >= 0 && (mul *= 0x100)) {\n    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF\n  }\n\n  return offset + byteLength\n}\n\nBuffer.prototype.writeInt8 = function writeInt8 (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 1, 0x7f, -0x80)\n  if (!Buffer.TYPED_ARRAY_SUPPORT) value = Math.floor(value)\n  if (value < 0) value = 0xff + value + 1\n  this[offset] = (value & 0xff)\n  return offset + 1\n}\n\nBuffer.prototype.writeInt16LE = function writeInt16LE (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    this[offset] = (value & 0xff)\n    this[offset + 1] = (value >>> 8)\n  } else {\n    objectWriteUInt16(this, value, offset, true)\n  }\n  return offset + 2\n}\n\nBuffer.prototype.writeInt16BE = function writeInt16BE (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    this[offset] = (value >>> 8)\n    this[offset + 1] = (value & 0xff)\n  } else {\n    objectWriteUInt16(this, value, offset, false)\n  }\n  return offset + 2\n}\n\nBuffer.prototype.writeInt32LE = function writeInt32LE (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    this[offset] = (value & 0xff)\n    this[offset + 1] = (value >>> 8)\n    this[offset + 2] = (value >>> 16)\n    this[offset + 3] = (value >>> 24)\n  } else {\n    objectWriteUInt32(this, value, offset, true)\n  }\n  return offset + 4\n}\n\nBuffer.prototype.writeInt32BE = function writeInt32BE (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)\n  if (value < 0) value = 0xffffffff + value + 1\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    this[offset] = (value >>> 24)\n    this[offset + 1] = (value >>> 16)\n    this[offset + 2] = (value >>> 8)\n    this[offset + 3] = (value & 0xff)\n  } else {\n    objectWriteUInt32(this, value, offset, false)\n  }\n  return offset + 4\n}\n\nfunction checkIEEE754 (buf, value, offset, ext, max, min) {\n  if (value > max || value < min) throw new RangeError('value is out of bounds')\n  if (offset + ext > buf.length) throw new RangeError('index out of range')\n  if (offset < 0) throw new RangeError('index out of range')\n}\n\nfunction writeFloat (buf, value, offset, littleEndian, noAssert) {\n  if (!noAssert) {\n    checkIEEE754(buf, value, offset, 4, 3.4028234663852886e+38, -3.4028234663852886e+38)\n  }\n  ieee754.write(buf, value, offset, littleEndian, 23, 4)\n  return offset + 4\n}\n\nBuffer.prototype.writeFloatLE = function writeFloatLE (value, offset, noAssert) {\n  return writeFloat(this, value, offset, true, noAssert)\n}\n\nBuffer.prototype.writeFloatBE = function writeFloatBE (value, offset, noAssert) {\n  return writeFloat(this, value, offset, false, noAssert)\n}\n\nfunction writeDouble (buf, value, offset, littleEndian, noAssert) {\n  if (!noAssert) {\n    checkIEEE754(buf, value, offset, 8, 1.7976931348623157E+308, -1.7976931348623157E+308)\n  }\n  ieee754.write(buf, value, offset, littleEndian, 52, 8)\n  return offset + 8\n}\n\nBuffer.prototype.writeDoubleLE = function writeDoubleLE (value, offset, noAssert) {\n  return writeDouble(this, value, offset, true, noAssert)\n}\n\nBuffer.prototype.writeDoubleBE = function writeDoubleBE (value, offset, noAssert) {\n  return writeDouble(this, value, offset, false, noAssert)\n}\n\n// copy(targetBuffer, targetStart=0, sourceStart=0, sourceEnd=buffer.length)\nBuffer.prototype.copy = function copy (target, targetStart, start, end) {\n  if (!start) start = 0\n  if (!end && end !== 0) end = this.length\n  if (targetStart >= target.length) targetStart = target.length\n  if (!targetStart) targetStart = 0\n  if (end > 0 && end < start) end = start\n\n  // Copy 0 bytes; we're done\n  if (end === start) return 0\n  if (target.length === 0 || this.length === 0) return 0\n\n  // Fatal error conditions\n  if (targetStart < 0) {\n    throw new RangeError('targetStart out of bounds')\n  }\n  if (start < 0 || start >= this.length) throw new RangeError('sourceStart out of bounds')\n  if (end < 0) throw new RangeError('sourceEnd out of bounds')\n\n  // Are we oob?\n  if (end > this.length) end = this.length\n  if (target.length - targetStart < end - start) {\n    end = target.length - targetStart + start\n  }\n\n  var len = end - start\n  var i\n\n  if (this === target && start < targetStart && targetStart < end) {\n    // descending copy from end\n    for (i = len - 1; i >= 0; i--) {\n      target[i + targetStart] = this[i + start]\n    }\n  } else if (len < 1000 || !Buffer.TYPED_ARRAY_SUPPORT) {\n    // ascending copy from start\n    for (i = 0; i < len; i++) {\n      target[i + targetStart] = this[i + start]\n    }\n  } else {\n    target._set(this.subarray(start, start + len), targetStart)\n  }\n\n  return len\n}\n\n// fill(value, start=0, end=buffer.length)\nBuffer.prototype.fill = function fill (value, start, end) {\n  if (!value) value = 0\n  if (!start) start = 0\n  if (!end) end = this.length\n\n  if (end < start) throw new RangeError('end < start')\n\n  // Fill 0 bytes; we're done\n  if (end === start) return\n  if (this.length === 0) return\n\n  if (start < 0 || start >= this.length) throw new RangeError('start out of bounds')\n  if (end < 0 || end > this.length) throw new RangeError('end out of bounds')\n\n  var i\n  if (typeof value === 'number') {\n    for (i = start; i < end; i++) {\n      this[i] = value\n    }\n  } else {\n    var bytes = utf8ToBytes(value.toString())\n    var len = bytes.length\n    for (i = start; i < end; i++) {\n      this[i] = bytes[i % len]\n    }\n  }\n\n  return this\n}\n\n/**\n * Creates a new `ArrayBuffer` with the *copied* memory of the buffer instance.\n * Added in Node 0.12. Only available in browsers that support ArrayBuffer.\n */\nBuffer.prototype.toArrayBuffer = function toArrayBuffer () {\n  if (typeof Uint8Array !== 'undefined') {\n    if (Buffer.TYPED_ARRAY_SUPPORT) {\n      return (new Buffer(this)).buffer\n    } else {\n      var buf = new Uint8Array(this.length)\n      for (var i = 0, len = buf.length; i < len; i += 1) {\n        buf[i] = this[i]\n      }\n      return buf.buffer\n    }\n  } else {\n    throw new TypeError('Buffer.toArrayBuffer not supported in this browser')\n  }\n}\n\n// HELPER FUNCTIONS\n// ================\n\nvar BP = Buffer.prototype\n\n/**\n * Augment a Uint8Array *instance* (not the Uint8Array class!) with Buffer methods\n */\nBuffer._augment = function _augment (arr) {\n  arr.constructor = Buffer\n  arr._isBuffer = true\n\n  // save reference to original Uint8Array set method before overwriting\n  arr._set = arr.set\n\n  // deprecated\n  arr.get = BP.get\n  arr.set = BP.set\n\n  arr.write = BP.write\n  arr.toString = BP.toString\n  arr.toLocaleString = BP.toString\n  arr.toJSON = BP.toJSON\n  arr.equals = BP.equals\n  arr.compare = BP.compare\n  arr.indexOf = BP.indexOf\n  arr.copy = BP.copy\n  arr.slice = BP.slice\n  arr.readUIntLE = BP.readUIntLE\n  arr.readUIntBE = BP.readUIntBE\n  arr.readUInt8 = BP.readUInt8\n  arr.readUInt16LE = BP.readUInt16LE\n  arr.readUInt16BE = BP.readUInt16BE\n  arr.readUInt32LE = BP.readUInt32LE\n  arr.readUInt32BE = BP.readUInt32BE\n  arr.readIntLE = BP.readIntLE\n  arr.readIntBE = BP.readIntBE\n  arr.readInt8 = BP.readInt8\n  arr.readInt16LE = BP.readInt16LE\n  arr.readInt16BE = BP.readInt16BE\n  arr.readInt32LE = BP.readInt32LE\n  arr.readInt32BE = BP.readInt32BE\n  arr.readFloatLE = BP.readFloatLE\n  arr.readFloatBE = BP.readFloatBE\n  arr.readDoubleLE = BP.readDoubleLE\n  arr.readDoubleBE = BP.readDoubleBE\n  arr.writeUInt8 = BP.writeUInt8\n  arr.writeUIntLE = BP.writeUIntLE\n  arr.writeUIntBE = BP.writeUIntBE\n  arr.writeUInt16LE = BP.writeUInt16LE\n  arr.writeUInt16BE = BP.writeUInt16BE\n  arr.writeUInt32LE = BP.writeUInt32LE\n  arr.writeUInt32BE = BP.writeUInt32BE\n  arr.writeIntLE = BP.writeIntLE\n  arr.writeIntBE = BP.writeIntBE\n  arr.writeInt8 = BP.writeInt8\n  arr.writeInt16LE = BP.writeInt16LE\n  arr.writeInt16BE = BP.writeInt16BE\n  arr.writeInt32LE = BP.writeInt32LE\n  arr.writeInt32BE = BP.writeInt32BE\n  arr.writeFloatLE = BP.writeFloatLE\n  arr.writeFloatBE = BP.writeFloatBE\n  arr.writeDoubleLE = BP.writeDoubleLE\n  arr.writeDoubleBE = BP.writeDoubleBE\n  arr.fill = BP.fill\n  arr.inspect = BP.inspect\n  arr.toArrayBuffer = BP.toArrayBuffer\n\n  return arr\n}\n\nvar INVALID_BASE64_RE = /[^+\\/0-9A-Za-z-_]/g\n\nfunction base64clean (str) {\n  // Node strips out invalid characters like \\n and \\t from the string, base64-js does not\n  str = stringtrim(str).replace(INVALID_BASE64_RE, '')\n  // Node converts strings with length < 2 to ''\n  if (str.length < 2) return ''\n  // Node allows for non-padded base64 strings (missing trailing ===), base64-js does not\n  while (str.length % 4 !== 0) {\n    str = str + '='\n  }\n  return str\n}\n\nfunction stringtrim (str) {\n  if (str.trim) return str.trim()\n  return str.replace(/^\\s+|\\s+$/g, '')\n}\n\nfunction toHex (n) {\n  if (n < 16) return '0' + n.toString(16)\n  return n.toString(16)\n}\n\nfunction utf8ToBytes (string, units) {\n  units = units || Infinity\n  var codePoint\n  var length = string.length\n  var leadSurrogate = null\n  var bytes = []\n\n  for (var i = 0; i < length; i++) {\n    codePoint = string.charCodeAt(i)\n\n    // is surrogate component\n    if (codePoint > 0xD7FF && codePoint < 0xE000) {\n      // last char was a lead\n      if (!leadSurrogate) {\n        // no lead yet\n        if (codePoint > 0xDBFF) {\n          // unexpected trail\n          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)\n          continue\n        } else if (i + 1 === length) {\n          // unpaired lead\n          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)\n          continue\n        }\n\n        // valid lead\n        leadSurrogate = codePoint\n\n        continue\n      }\n\n      // 2 leads in a row\n      if (codePoint < 0xDC00) {\n        if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)\n        leadSurrogate = codePoint\n        continue\n      }\n\n      // valid surrogate pair\n      codePoint = (leadSurrogate - 0xD800 << 10 | codePoint - 0xDC00) + 0x10000\n    } else if (leadSurrogate) {\n      // valid bmp char, but last char was a lead\n      if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)\n    }\n\n    leadSurrogate = null\n\n    // encode utf8\n    if (codePoint < 0x80) {\n      if ((units -= 1) < 0) break\n      bytes.push(codePoint)\n    } else if (codePoint < 0x800) {\n      if ((units -= 2) < 0) break\n      bytes.push(\n        codePoint >> 0x6 | 0xC0,\n        codePoint & 0x3F | 0x80\n      )\n    } else if (codePoint < 0x10000) {\n      if ((units -= 3) < 0) break\n      bytes.push(\n        codePoint >> 0xC | 0xE0,\n        codePoint >> 0x6 & 0x3F | 0x80,\n        codePoint & 0x3F | 0x80\n      )\n    } else if (codePoint < 0x110000) {\n      if ((units -= 4) < 0) break\n      bytes.push(\n        codePoint >> 0x12 | 0xF0,\n        codePoint >> 0xC & 0x3F | 0x80,\n        codePoint >> 0x6 & 0x3F | 0x80,\n        codePoint & 0x3F | 0x80\n      )\n    } else {\n      throw new Error('Invalid code point')\n    }\n  }\n\n  return bytes\n}\n\nfunction asciiToBytes (str) {\n  var byteArray = []\n  for (var i = 0; i < str.length; i++) {\n    // Node's code seems to be doing this and not & 0x7F..\n    byteArray.push(str.charCodeAt(i) & 0xFF)\n  }\n  return byteArray\n}\n\nfunction utf16leToBytes (str, units) {\n  var c, hi, lo\n  var byteArray = []\n  for (var i = 0; i < str.length; i++) {\n    if ((units -= 2) < 0) break\n\n    c = str.charCodeAt(i)\n    hi = c >> 8\n    lo = c % 256\n    byteArray.push(lo)\n    byteArray.push(hi)\n  }\n\n  return byteArray\n}\n\nfunction base64ToBytes (str) {\n  return base64.toByteArray(base64clean(str))\n}\n\nfunction blitBuffer (src, dst, offset, length) {\n  for (var i = 0; i < length; i++) {\n    if ((i + offset >= dst.length) || (i >= src.length)) break\n    dst[i + offset] = src[i]\n  }\n  return i\n}\n\n}).call(this,typeof global !== \"undefined\" ? global : typeof self !== \"undefined\" ? self : typeof window !== \"undefined\" ? window : {})\n\n},{\"base64-js\":5,\"ieee754\":6,\"isarray\":7}],5:[function(require,module,exports){\nvar lookup = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';\n\n;(function (exports) {\n\t'use strict';\n\n  var Arr = (typeof Uint8Array !== 'undefined')\n    ? Uint8Array\n    : Array\n\n\tvar PLUS   = '+'.charCodeAt(0)\n\tvar SLASH  = '/'.charCodeAt(0)\n\tvar NUMBER = '0'.charCodeAt(0)\n\tvar LOWER  = 'a'.charCodeAt(0)\n\tvar UPPER  = 'A'.charCodeAt(0)\n\tvar PLUS_URL_SAFE = '-'.charCodeAt(0)\n\tvar SLASH_URL_SAFE = '_'.charCodeAt(0)\n\n\tfunction decode (elt) {\n\t\tvar code = elt.charCodeAt(0)\n\t\tif (code === PLUS ||\n\t\t    code === PLUS_URL_SAFE)\n\t\t\treturn 62 // '+'\n\t\tif (code === SLASH ||\n\t\t    code === SLASH_URL_SAFE)\n\t\t\treturn 63 // '/'\n\t\tif (code < NUMBER)\n\t\t\treturn -1 //no match\n\t\tif (code < NUMBER + 10)\n\t\t\treturn code - NUMBER + 26 + 26\n\t\tif (code < UPPER + 26)\n\t\t\treturn code - UPPER\n\t\tif (code < LOWER + 26)\n\t\t\treturn code - LOWER + 26\n\t}\n\n\tfunction b64ToByteArray (b64) {\n\t\tvar i, j, l, tmp, placeHolders, arr\n\n\t\tif (b64.length % 4 > 0) {\n\t\t\tthrow new Error('Invalid string. Length must be a multiple of 4')\n\t\t}\n\n\t\t// the number of equal signs (place holders)\n\t\t// if there are two placeholders, than the two characters before it\n\t\t// represent one byte\n\t\t// if there is only one, then the three characters before it represent 2 bytes\n\t\t// this is just a cheap hack to not do indexOf twice\n\t\tvar len = b64.length\n\t\tplaceHolders = '=' === b64.charAt(len - 2) ? 2 : '=' === b64.charAt(len - 1) ? 1 : 0\n\n\t\t// base64 is 4/3 + up to two characters of the original data\n\t\tarr = new Arr(b64.length * 3 / 4 - placeHolders)\n\n\t\t// if there are placeholders, only get up to the last complete 4 chars\n\t\tl = placeHolders > 0 ? b64.length - 4 : b64.length\n\n\t\tvar L = 0\n\n\t\tfunction push (v) {\n\t\t\tarr[L++] = v\n\t\t}\n\n\t\tfor (i = 0, j = 0; i < l; i += 4, j += 3) {\n\t\t\ttmp = (decode(b64.charAt(i)) << 18) | (decode(b64.charAt(i + 1)) << 12) | (decode(b64.charAt(i + 2)) << 6) | decode(b64.charAt(i + 3))\n\t\t\tpush((tmp & 0xFF0000) >> 16)\n\t\t\tpush((tmp & 0xFF00) >> 8)\n\t\t\tpush(tmp & 0xFF)\n\t\t}\n\n\t\tif (placeHolders === 2) {\n\t\t\ttmp = (decode(b64.charAt(i)) << 2) | (decode(b64.charAt(i + 1)) >> 4)\n\t\t\tpush(tmp & 0xFF)\n\t\t} else if (placeHolders === 1) {\n\t\t\ttmp = (decode(b64.charAt(i)) << 10) | (decode(b64.charAt(i + 1)) << 4) | (decode(b64.charAt(i + 2)) >> 2)\n\t\t\tpush((tmp >> 8) & 0xFF)\n\t\t\tpush(tmp & 0xFF)\n\t\t}\n\n\t\treturn arr\n\t}\n\n\tfunction uint8ToBase64 (uint8) {\n\t\tvar i,\n\t\t\textraBytes = uint8.length % 3, // if we have 1 byte left, pad 2 bytes\n\t\t\toutput = \"\",\n\t\t\ttemp, length\n\n\t\tfunction encode (num) {\n\t\t\treturn lookup.charAt(num)\n\t\t}\n\n\t\tfunction tripletToBase64 (num) {\n\t\t\treturn encode(num >> 18 & 0x3F) + encode(num >> 12 & 0x3F) + encode(num >> 6 & 0x3F) + encode(num & 0x3F)\n\t\t}\n\n\t\t// go through the array every three bytes, we'll deal with trailing stuff later\n\t\tfor (i = 0, length = uint8.length - extraBytes; i < length; i += 3) {\n\t\t\ttemp = (uint8[i] << 16) + (uint8[i + 1] << 8) + (uint8[i + 2])\n\t\t\toutput += tripletToBase64(temp)\n\t\t}\n\n\t\t// pad the end with zeros, but make sure to not forget the extra bytes\n\t\tswitch (extraBytes) {\n\t\t\tcase 1:\n\t\t\t\ttemp = uint8[uint8.length - 1]\n\t\t\t\toutput += encode(temp >> 2)\n\t\t\t\toutput += encode((temp << 4) & 0x3F)\n\t\t\t\toutput += '=='\n\t\t\t\tbreak\n\t\t\tcase 2:\n\t\t\t\ttemp = (uint8[uint8.length - 2] << 8) + (uint8[uint8.length - 1])\n\t\t\t\toutput += encode(temp >> 10)\n\t\t\t\toutput += encode((temp >> 4) & 0x3F)\n\t\t\t\toutput += encode((temp << 2) & 0x3F)\n\t\t\t\toutput += '='\n\t\t\t\tbreak\n\t\t}\n\n\t\treturn output\n\t}\n\n\texports.toByteArray = b64ToByteArray\n\texports.fromByteArray = uint8ToBase64\n}(typeof exports === 'undefined' ? (this.base64js = {}) : exports))\n\n},{}],6:[function(require,module,exports){\nexports.read = function (buffer, offset, isLE, mLen, nBytes) {\n  var e, m\n  var eLen = nBytes * 8 - mLen - 1\n  var eMax = (1 << eLen) - 1\n  var eBias = eMax >> 1\n  var nBits = -7\n  var i = isLE ? (nBytes - 1) : 0\n  var d = isLE ? -1 : 1\n  var s = buffer[offset + i]\n\n  i += d\n\n  e = s & ((1 << (-nBits)) - 1)\n  s >>= (-nBits)\n  nBits += eLen\n  for (; nBits > 0; e = e * 256 + buffer[offset + i], i += d, nBits -= 8) {}\n\n  m = e & ((1 << (-nBits)) - 1)\n  e >>= (-nBits)\n  nBits += mLen\n  for (; nBits > 0; m = m * 256 + buffer[offset + i], i += d, nBits -= 8) {}\n\n  if (e === 0) {\n    e = 1 - eBias\n  } else if (e === eMax) {\n    return m ? NaN : ((s ? -1 : 1) * Infinity)\n  } else {\n    m = m + Math.pow(2, mLen)\n    e = e - eBias\n  }\n  return (s ? -1 : 1) * m * Math.pow(2, e - mLen)\n}\n\nexports.write = function (buffer, value, offset, isLE, mLen, nBytes) {\n  var e, m, c\n  var eLen = nBytes * 8 - mLen - 1\n  var eMax = (1 << eLen) - 1\n  var eBias = eMax >> 1\n  var rt = (mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0)\n  var i = isLE ? 0 : (nBytes - 1)\n  var d = isLE ? 1 : -1\n  var s = value < 0 || (value === 0 && 1 / value < 0) ? 1 : 0\n\n  value = Math.abs(value)\n\n  if (isNaN(value) || value === Infinity) {\n    m = isNaN(value) ? 1 : 0\n    e = eMax\n  } else {\n    e = Math.floor(Math.log(value) / Math.LN2)\n    if (value * (c = Math.pow(2, -e)) < 1) {\n      e--\n      c *= 2\n    }\n    if (e + eBias >= 1) {\n      value += rt / c\n    } else {\n      value += rt * Math.pow(2, 1 - eBias)\n    }\n    if (value * c >= 2) {\n      e++\n      c /= 2\n    }\n\n    if (e + eBias >= eMax) {\n      m = 0\n      e = eMax\n    } else if (e + eBias >= 1) {\n      m = (value * c - 1) * Math.pow(2, mLen)\n      e = e + eBias\n    } else {\n      m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen)\n      e = 0\n    }\n  }\n\n  for (; mLen >= 8; buffer[offset + i] = m & 0xff, i += d, m /= 256, mLen -= 8) {}\n\n  e = (e << mLen) | m\n  eLen += mLen\n  for (; eLen > 0; buffer[offset + i] = e & 0xff, i += d, e /= 256, eLen -= 8) {}\n\n  buffer[offset + i - d] |= s * 128\n}\n\n},{}],7:[function(require,module,exports){\nvar toString = {}.toString;\n\nmodule.exports = Array.isArray || function (arr) {\n  return toString.call(arr) == '[object Array]';\n};\n\n},{}],8:[function(require,module,exports){\n// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\nfunction EventEmitter() {\n  this._events = this._events || {};\n  this._maxListeners = this._maxListeners || undefined;\n}\nmodule.exports = EventEmitter;\n\n// Backwards-compat with node 0.10.x\nEventEmitter.EventEmitter = EventEmitter;\n\nEventEmitter.prototype._events = undefined;\nEventEmitter.prototype._maxListeners = undefined;\n\n// By default EventEmitters will print a warning if more than 10 listeners are\n// added to it. This is a useful default which helps finding memory leaks.\nEventEmitter.defaultMaxListeners = 10;\n\n// Obviously not all Emitters should be limited to 10. This function allows\n// that to be increased. Set to zero for unlimited.\nEventEmitter.prototype.setMaxListeners = function(n) {\n  if (!isNumber(n) || n < 0 || isNaN(n))\n    throw TypeError('n must be a positive number');\n  this._maxListeners = n;\n  return this;\n};\n\nEventEmitter.prototype.emit = function(type) {\n  var er, handler, len, args, i, listeners;\n\n  if (!this._events)\n    this._events = {};\n\n  // If there is no 'error' event listener then throw.\n  if (type === 'error') {\n    if (!this._events.error ||\n        (isObject(this._events.error) && !this._events.error.length)) {\n      er = arguments[1];\n      if (er instanceof Error) {\n        throw er; // Unhandled 'error' event\n      }\n      throw TypeError('Uncaught, unspecified \"error\" event.');\n    }\n  }\n\n  handler = this._events[type];\n\n  if (isUndefined(handler))\n    return false;\n\n  if (isFunction(handler)) {\n    switch (arguments.length) {\n      // fast cases\n      case 1:\n        handler.call(this);\n        break;\n      case 2:\n        handler.call(this, arguments[1]);\n        break;\n      case 3:\n        handler.call(this, arguments[1], arguments[2]);\n        break;\n      // slower\n      default:\n        args = Array.prototype.slice.call(arguments, 1);\n        handler.apply(this, args);\n    }\n  } else if (isObject(handler)) {\n    args = Array.prototype.slice.call(arguments, 1);\n    listeners = handler.slice();\n    len = listeners.length;\n    for (i = 0; i < len; i++)\n      listeners[i].apply(this, args);\n  }\n\n  return true;\n};\n\nEventEmitter.prototype.addListener = function(type, listener) {\n  var m;\n\n  if (!isFunction(listener))\n    throw TypeError('listener must be a function');\n\n  if (!this._events)\n    this._events = {};\n\n  // To avoid recursion in the case that type === \"newListener\"! Before\n  // adding it to the listeners, first emit \"newListener\".\n  if (this._events.newListener)\n    this.emit('newListener', type,\n              isFunction(listener.listener) ?\n              listener.listener : listener);\n\n  if (!this._events[type])\n    // Optimize the case of one listener. Don't need the extra array object.\n    this._events[type] = listener;\n  else if (isObject(this._events[type]))\n    // If we've already got an array, just append.\n    this._events[type].push(listener);\n  else\n    // Adding the second element, need to change to array.\n    this._events[type] = [this._events[type], listener];\n\n  // Check for listener leak\n  if (isObject(this._events[type]) && !this._events[type].warned) {\n    if (!isUndefined(this._maxListeners)) {\n      m = this._maxListeners;\n    } else {\n      m = EventEmitter.defaultMaxListeners;\n    }\n\n    if (m && m > 0 && this._events[type].length > m) {\n      this._events[type].warned = true;\n      console.error('(node) warning: possible EventEmitter memory ' +\n                    'leak detected. %d listeners added. ' +\n                    'Use emitter.setMaxListeners() to increase limit.',\n                    this._events[type].length);\n      if (typeof console.trace === 'function') {\n        // not supported in IE 10\n        console.trace();\n      }\n    }\n  }\n\n  return this;\n};\n\nEventEmitter.prototype.on = EventEmitter.prototype.addListener;\n\nEventEmitter.prototype.once = function(type, listener) {\n  if (!isFunction(listener))\n    throw TypeError('listener must be a function');\n\n  var fired = false;\n\n  function g() {\n    this.removeListener(type, g);\n\n    if (!fired) {\n      fired = true;\n      listener.apply(this, arguments);\n    }\n  }\n\n  g.listener = listener;\n  this.on(type, g);\n\n  return this;\n};\n\n// emits a 'removeListener' event iff the listener was removed\nEventEmitter.prototype.removeListener = function(type, listener) {\n  var list, position, length, i;\n\n  if (!isFunction(listener))\n    throw TypeError('listener must be a function');\n\n  if (!this._events || !this._events[type])\n    return this;\n\n  list = this._events[type];\n  length = list.length;\n  position = -1;\n\n  if (list === listener ||\n      (isFunction(list.listener) && list.listener === listener)) {\n    delete this._events[type];\n    if (this._events.removeListener)\n      this.emit('removeListener', type, listener);\n\n  } else if (isObject(list)) {\n    for (i = length; i-- > 0;) {\n      if (list[i] === listener ||\n          (list[i].listener && list[i].listener === listener)) {\n        position = i;\n        break;\n      }\n    }\n\n    if (position < 0)\n      return this;\n\n    if (list.length === 1) {\n      list.length = 0;\n      delete this._events[type];\n    } else {\n      list.splice(position, 1);\n    }\n\n    if (this._events.removeListener)\n      this.emit('removeListener', type, listener);\n  }\n\n  return this;\n};\n\nEventEmitter.prototype.removeAllListeners = function(type) {\n  var key, listeners;\n\n  if (!this._events)\n    return this;\n\n  // not listening for removeListener, no need to emit\n  if (!this._events.removeListener) {\n    if (arguments.length === 0)\n      this._events = {};\n    else if (this._events[type])\n      delete this._events[type];\n    return this;\n  }\n\n  // emit removeListener for all listeners on all events\n  if (arguments.length === 0) {\n    for (key in this._events) {\n      if (key === 'removeListener') continue;\n      this.removeAllListeners(key);\n    }\n    this.removeAllListeners('removeListener');\n    this._events = {};\n    return this;\n  }\n\n  listeners = this._events[type];\n\n  if (isFunction(listeners)) {\n    this.removeListener(type, listeners);\n  } else if (listeners) {\n    // LIFO order\n    while (listeners.length)\n      this.removeListener(type, listeners[listeners.length - 1]);\n  }\n  delete this._events[type];\n\n  return this;\n};\n\nEventEmitter.prototype.listeners = function(type) {\n  var ret;\n  if (!this._events || !this._events[type])\n    ret = [];\n  else if (isFunction(this._events[type]))\n    ret = [this._events[type]];\n  else\n    ret = this._events[type].slice();\n  return ret;\n};\n\nEventEmitter.prototype.listenerCount = function(type) {\n  if (this._events) {\n    var evlistener = this._events[type];\n\n    if (isFunction(evlistener))\n      return 1;\n    else if (evlistener)\n      return evlistener.length;\n  }\n  return 0;\n};\n\nEventEmitter.listenerCount = function(emitter, type) {\n  return emitter.listenerCount(type);\n};\n\nfunction isFunction(arg) {\n  return typeof arg === 'function';\n}\n\nfunction isNumber(arg) {\n  return typeof arg === 'number';\n}\n\nfunction isObject(arg) {\n  return typeof arg === 'object' && arg !== null;\n}\n\nfunction isUndefined(arg) {\n  return arg === void 0;\n}\n\n},{}],9:[function(require,module,exports){\nvar http = require('http');\n\nvar https = module.exports;\n\nfor (var key in http) {\n    if (http.hasOwnProperty(key)) https[key] = http[key];\n};\n\nhttps.request = function (params, cb) {\n    if (!params) params = {};\n    params.scheme = 'https';\n    params.protocol = 'https:';\n    return http.request.call(this, params, cb);\n}\n\n},{\"http\":32}],10:[function(require,module,exports){\nif (typeof Object.create === 'function') {\n  // implementation from standard node.js 'util' module\n  module.exports = function inherits(ctor, superCtor) {\n    ctor.super_ = superCtor\n    ctor.prototype = Object.create(superCtor.prototype, {\n      constructor: {\n        value: ctor,\n        enumerable: false,\n        writable: true,\n        configurable: true\n      }\n    });\n  };\n} else {\n  // old school shim for old browsers\n  module.exports = function inherits(ctor, superCtor) {\n    ctor.super_ = superCtor\n    var TempCtor = function () {}\n    TempCtor.prototype = superCtor.prototype\n    ctor.prototype = new TempCtor()\n    ctor.prototype.constructor = ctor\n  }\n}\n\n},{}],11:[function(require,module,exports){\n/**\n * Determine if an object is Buffer\n *\n * Author:   Feross Aboukhadijeh <feross@feross.org> <http://feross.org>\n * License:  MIT\n *\n * `npm install is-buffer`\n */\n\nmodule.exports = function (obj) {\n  return !!(obj != null &&\n    (obj._isBuffer || // For Safari 5-7 (missing Object.prototype.constructor)\n      (obj.constructor &&\n      typeof obj.constructor.isBuffer === 'function' &&\n      obj.constructor.isBuffer(obj))\n    ))\n}\n\n},{}],12:[function(require,module,exports){\nmodule.exports = Array.isArray || function (arr) {\n  return Object.prototype.toString.call(arr) == '[object Array]';\n};\n\n},{}],13:[function(require,module,exports){\n// shim for using process in browser\n\nvar process = module.exports = {};\nvar queue = [];\nvar draining = false;\nvar currentQueue;\nvar queueIndex = -1;\n\nfunction cleanUpNextTick() {\n    draining = false;\n    if (currentQueue.length) {\n        queue = currentQueue.concat(queue);\n    } else {\n        queueIndex = -1;\n    }\n    if (queue.length) {\n        drainQueue();\n    }\n}\n\nfunction drainQueue() {\n    if (draining) {\n        return;\n    }\n    var timeout = setTimeout(cleanUpNextTick);\n    draining = true;\n\n    var len = queue.length;\n    while(len) {\n        currentQueue = queue;\n        queue = [];\n        while (++queueIndex < len) {\n            if (currentQueue) {\n                currentQueue[queueIndex].run();\n            }\n        }\n        queueIndex = -1;\n        len = queue.length;\n    }\n    currentQueue = null;\n    draining = false;\n    clearTimeout(timeout);\n}\n\nprocess.nextTick = function (fun) {\n    var args = new Array(arguments.length - 1);\n    if (arguments.length > 1) {\n        for (var i = 1; i < arguments.length; i++) {\n            args[i - 1] = arguments[i];\n        }\n    }\n    queue.push(new Item(fun, args));\n    if (queue.length === 1 && !draining) {\n        setTimeout(drainQueue, 0);\n    }\n};\n\n// v8 likes predictible objects\nfunction Item(fun, array) {\n    this.fun = fun;\n    this.array = array;\n}\nItem.prototype.run = function () {\n    this.fun.apply(null, this.array);\n};\nprocess.title = 'browser';\nprocess.browser = true;\nprocess.env = {};\nprocess.argv = [];\nprocess.version = ''; // empty string to avoid regexp issues\nprocess.versions = {};\n\nfunction noop() {}\n\nprocess.on = noop;\nprocess.addListener = noop;\nprocess.once = noop;\nprocess.off = noop;\nprocess.removeListener = noop;\nprocess.removeAllListeners = noop;\nprocess.emit = noop;\n\nprocess.binding = function (name) {\n    throw new Error('process.binding is not supported');\n};\n\nprocess.cwd = function () { return '/' };\nprocess.chdir = function (dir) {\n    throw new Error('process.chdir is not supported');\n};\nprocess.umask = function() { return 0; };\n\n},{}],14:[function(require,module,exports){\n(function (global){\n/*! https://mths.be/punycode v1.4.0 by @mathias */\n;(function(root) {\n\n\t/** Detect free variables */\n\tvar freeExports = typeof exports == 'object' && exports &&\n\t\t!exports.nodeType && exports;\n\tvar freeModule = typeof module == 'object' && module &&\n\t\t!module.nodeType && module;\n\tvar freeGlobal = typeof global == 'object' && global;\n\tif (\n\t\tfreeGlobal.global === freeGlobal ||\n\t\tfreeGlobal.window === freeGlobal ||\n\t\tfreeGlobal.self === freeGlobal\n\t) {\n\t\troot = freeGlobal;\n\t}\n\n\t/**\n\t * The `punycode` object.\n\t * @name punycode\n\t * @type Object\n\t */\n\tvar punycode,\n\n\t/** Highest positive signed 32-bit float value */\n\tmaxInt = 2147483647, // aka. 0x7FFFFFFF or 2^31-1\n\n\t/** Bootstring parameters */\n\tbase = 36,\n\ttMin = 1,\n\ttMax = 26,\n\tskew = 38,\n\tdamp = 700,\n\tinitialBias = 72,\n\tinitialN = 128, // 0x80\n\tdelimiter = '-', // '\\x2D'\n\n\t/** Regular expressions */\n\tregexPunycode = /^xn--/,\n\tregexNonASCII = /[^\\x20-\\x7E]/, // unprintable ASCII chars + non-ASCII chars\n\tregexSeparators = /[\\x2E\\u3002\\uFF0E\\uFF61]/g, // RFC 3490 separators\n\n\t/** Error messages */\n\terrors = {\n\t\t'overflow': 'Overflow: input needs wider integers to process',\n\t\t'not-basic': 'Illegal input >= 0x80 (not a basic code point)',\n\t\t'invalid-input': 'Invalid input'\n\t},\n\n\t/** Convenience shortcuts */\n\tbaseMinusTMin = base - tMin,\n\tfloor = Math.floor,\n\tstringFromCharCode = String.fromCharCode,\n\n\t/** Temporary variable */\n\tkey;\n\n\t/*--------------------------------------------------------------------------*/\n\n\t/**\n\t * A generic error utility function.\n\t * @private\n\t * @param {String} type The error type.\n\t * @returns {Error} Throws a `RangeError` with the applicable error message.\n\t */\n\tfunction error(type) {\n\t\tthrow new RangeError(errors[type]);\n\t}\n\n\t/**\n\t * A generic `Array#map` utility function.\n\t * @private\n\t * @param {Array} array The array to iterate over.\n\t * @param {Function} callback The function that gets called for every array\n\t * item.\n\t * @returns {Array} A new array of values returned by the callback function.\n\t */\n\tfunction map(array, fn) {\n\t\tvar length = array.length;\n\t\tvar result = [];\n\t\twhile (length--) {\n\t\t\tresult[length] = fn(array[length]);\n\t\t}\n\t\treturn result;\n\t}\n\n\t/**\n\t * A simple `Array#map`-like wrapper to work with domain name strings or email\n\t * addresses.\n\t * @private\n\t * @param {String} domain The domain name or email address.\n\t * @param {Function} callback The function that gets called for every\n\t * character.\n\t * @returns {Array} A new string of characters returned by the callback\n\t * function.\n\t */\n\tfunction mapDomain(string, fn) {\n\t\tvar parts = string.split('@');\n\t\tvar result = '';\n\t\tif (parts.length > 1) {\n\t\t\t// In email addresses, only the domain name should be punycoded. Leave\n\t\t\t// the local part (i.e. everything up to `@`) intact.\n\t\t\tresult = parts[0] + '@';\n\t\t\tstring = parts[1];\n\t\t}\n\t\t// Avoid `split(regex)` for IE8 compatibility. See #17.\n\t\tstring = string.replace(regexSeparators, '\\x2E');\n\t\tvar labels = string.split('.');\n\t\tvar encoded = map(labels, fn).join('.');\n\t\treturn result + encoded;\n\t}\n\n\t/**\n\t * Creates an array containing the numeric code points of each Unicode\n\t * character in the string. While JavaScript uses UCS-2 internally,\n\t * this function will convert a pair of surrogate halves (each of which\n\t * UCS-2 exposes as separate characters) into a single code point,\n\t * matching UTF-16.\n\t * @see `punycode.ucs2.encode`\n\t * @see <https://mathiasbynens.be/notes/javascript-encoding>\n\t * @memberOf punycode.ucs2\n\t * @name decode\n\t * @param {String} string The Unicode input string (UCS-2).\n\t * @returns {Array} The new array of code points.\n\t */\n\tfunction ucs2decode(string) {\n\t\tvar output = [],\n\t\t    counter = 0,\n\t\t    length = string.length,\n\t\t    value,\n\t\t    extra;\n\t\twhile (counter < length) {\n\t\t\tvalue = string.charCodeAt(counter++);\n\t\t\tif (value >= 0xD800 && value <= 0xDBFF && counter < length) {\n\t\t\t\t// high surrogate, and there is a next character\n\t\t\t\textra = string.charCodeAt(counter++);\n\t\t\t\tif ((extra & 0xFC00) == 0xDC00) { // low surrogate\n\t\t\t\t\toutput.push(((value & 0x3FF) << 10) + (extra & 0x3FF) + 0x10000);\n\t\t\t\t} else {\n\t\t\t\t\t// unmatched surrogate; only append this code unit, in case the next\n\t\t\t\t\t// code unit is the high surrogate of a surrogate pair\n\t\t\t\t\toutput.push(value);\n\t\t\t\t\tcounter--;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\toutput.push(value);\n\t\t\t}\n\t\t}\n\t\treturn output;\n\t}\n\n\t/**\n\t * Creates a string based on an array of numeric code points.\n\t * @see `punycode.ucs2.decode`\n\t * @memberOf punycode.ucs2\n\t * @name encode\n\t * @param {Array} codePoints The array of numeric code points.\n\t * @returns {String} The new Unicode string (UCS-2).\n\t */\n\tfunction ucs2encode(array) {\n\t\treturn map(array, function(value) {\n\t\t\tvar output = '';\n\t\t\tif (value > 0xFFFF) {\n\t\t\t\tvalue -= 0x10000;\n\t\t\t\toutput += stringFromCharCode(value >>> 10 & 0x3FF | 0xD800);\n\t\t\t\tvalue = 0xDC00 | value & 0x3FF;\n\t\t\t}\n\t\t\toutput += stringFromCharCode(value);\n\t\t\treturn output;\n\t\t}).join('');\n\t}\n\n\t/**\n\t * Converts a basic code point into a digit/integer.\n\t * @see `digitToBasic()`\n\t * @private\n\t * @param {Number} codePoint The basic numeric code point value.\n\t * @returns {Number} The numeric value of a basic code point (for use in\n\t * representing integers) in the range `0` to `base - 1`, or `base` if\n\t * the code point does not represent a value.\n\t */\n\tfunction basicToDigit(codePoint) {\n\t\tif (codePoint - 48 < 10) {\n\t\t\treturn codePoint - 22;\n\t\t}\n\t\tif (codePoint - 65 < 26) {\n\t\t\treturn codePoint - 65;\n\t\t}\n\t\tif (codePoint - 97 < 26) {\n\t\t\treturn codePoint - 97;\n\t\t}\n\t\treturn base;\n\t}\n\n\t/**\n\t * Converts a digit/integer into a basic code point.\n\t * @see `basicToDigit()`\n\t * @private\n\t * @param {Number} digit The numeric value of a basic code point.\n\t * @returns {Number} The basic code point whose value (when used for\n\t * representing integers) is `digit`, which needs to be in the range\n\t * `0` to `base - 1`. If `flag` is non-zero, the uppercase form is\n\t * used; else, the lowercase form is used. The behavior is undefined\n\t * if `flag` is non-zero and `digit` has no uppercase form.\n\t */\n\tfunction digitToBasic(digit, flag) {\n\t\t//  0..25 map to ASCII a..z or A..Z\n\t\t// 26..35 map to ASCII 0..9\n\t\treturn digit + 22 + 75 * (digit < 26) - ((flag != 0) << 5);\n\t}\n\n\t/**\n\t * Bias adaptation function as per section 3.4 of RFC 3492.\n\t * https://tools.ietf.org/html/rfc3492#section-3.4\n\t * @private\n\t */\n\tfunction adapt(delta, numPoints, firstTime) {\n\t\tvar k = 0;\n\t\tdelta = firstTime ? floor(delta / damp) : delta >> 1;\n\t\tdelta += floor(delta / numPoints);\n\t\tfor (/* no initialization */; delta > baseMinusTMin * tMax >> 1; k += base) {\n\t\t\tdelta = floor(delta / baseMinusTMin);\n\t\t}\n\t\treturn floor(k + (baseMinusTMin + 1) * delta / (delta + skew));\n\t}\n\n\t/**\n\t * Converts a Punycode string of ASCII-only symbols to a string of Unicode\n\t * symbols.\n\t * @memberOf punycode\n\t * @param {String} input The Punycode string of ASCII-only symbols.\n\t * @returns {String} The resulting string of Unicode symbols.\n\t */\n\tfunction decode(input) {\n\t\t// Don't use UCS-2\n\t\tvar output = [],\n\t\t    inputLength = input.length,\n\t\t    out,\n\t\t    i = 0,\n\t\t    n = initialN,\n\t\t    bias = initialBias,\n\t\t    basic,\n\t\t    j,\n\t\t    index,\n\t\t    oldi,\n\t\t    w,\n\t\t    k,\n\t\t    digit,\n\t\t    t,\n\t\t    /** Cached calculation results */\n\t\t    baseMinusT;\n\n\t\t// Handle the basic code points: let `basic` be the number of input code\n\t\t// points before the last delimiter, or `0` if there is none, then copy\n\t\t// the first basic code points to the output.\n\n\t\tbasic = input.lastIndexOf(delimiter);\n\t\tif (basic < 0) {\n\t\t\tbasic = 0;\n\t\t}\n\n\t\tfor (j = 0; j < basic; ++j) {\n\t\t\t// if it's not a basic code point\n\t\t\tif (input.charCodeAt(j) >= 0x80) {\n\t\t\t\terror('not-basic');\n\t\t\t}\n\t\t\toutput.push(input.charCodeAt(j));\n\t\t}\n\n\t\t// Main decoding loop: start just after the last delimiter if any basic code\n\t\t// points were copied; start at the beginning otherwise.\n\n\t\tfor (index = basic > 0 ? basic + 1 : 0; index < inputLength; /* no final expression */) {\n\n\t\t\t// `index` is the index of the next character to be consumed.\n\t\t\t// Decode a generalized variable-length integer into `delta`,\n\t\t\t// which gets added to `i`. The overflow checking is easier\n\t\t\t// if we increase `i` as we go, then subtract off its starting\n\t\t\t// value at the end to obtain `delta`.\n\t\t\tfor (oldi = i, w = 1, k = base; /* no condition */; k += base) {\n\n\t\t\t\tif (index >= inputLength) {\n\t\t\t\t\terror('invalid-input');\n\t\t\t\t}\n\n\t\t\t\tdigit = basicToDigit(input.charCodeAt(index++));\n\n\t\t\t\tif (digit >= base || digit > floor((maxInt - i) / w)) {\n\t\t\t\t\terror('overflow');\n\t\t\t\t}\n\n\t\t\t\ti += digit * w;\n\t\t\t\tt = k <= bias ? tMin : (k >= bias + tMax ? tMax : k - bias);\n\n\t\t\t\tif (digit < t) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\tbaseMinusT = base - t;\n\t\t\t\tif (w > floor(maxInt / baseMinusT)) {\n\t\t\t\t\terror('overflow');\n\t\t\t\t}\n\n\t\t\t\tw *= baseMinusT;\n\n\t\t\t}\n\n\t\t\tout = output.length + 1;\n\t\t\tbias = adapt(i - oldi, out, oldi == 0);\n\n\t\t\t// `i` was supposed to wrap around from `out` to `0`,\n\t\t\t// incrementing `n` each time, so we'll fix that now:\n\t\t\tif (floor(i / out) > maxInt - n) {\n\t\t\t\terror('overflow');\n\t\t\t}\n\n\t\t\tn += floor(i / out);\n\t\t\ti %= out;\n\n\t\t\t// Insert `n` at position `i` of the output\n\t\t\toutput.splice(i++, 0, n);\n\n\t\t}\n\n\t\treturn ucs2encode(output);\n\t}\n\n\t/**\n\t * Converts a string of Unicode symbols (e.g. a domain name label) to a\n\t * Punycode string of ASCII-only symbols.\n\t * @memberOf punycode\n\t * @param {String} input The string of Unicode symbols.\n\t * @returns {String} The resulting Punycode string of ASCII-only symbols.\n\t */\n\tfunction encode(input) {\n\t\tvar n,\n\t\t    delta,\n\t\t    handledCPCount,\n\t\t    basicLength,\n\t\t    bias,\n\t\t    j,\n\t\t    m,\n\t\t    q,\n\t\t    k,\n\t\t    t,\n\t\t    currentValue,\n\t\t    output = [],\n\t\t    /** `inputLength` will hold the number of code points in `input`. */\n\t\t    inputLength,\n\t\t    /** Cached calculation results */\n\t\t    handledCPCountPlusOne,\n\t\t    baseMinusT,\n\t\t    qMinusT;\n\n\t\t// Convert the input in UCS-2 to Unicode\n\t\tinput = ucs2decode(input);\n\n\t\t// Cache the length\n\t\tinputLength = input.length;\n\n\t\t// Initialize the state\n\t\tn = initialN;\n\t\tdelta = 0;\n\t\tbias = initialBias;\n\n\t\t// Handle the basic code points\n\t\tfor (j = 0; j < inputLength; ++j) {\n\t\t\tcurrentValue = input[j];\n\t\t\tif (currentValue < 0x80) {\n\t\t\t\toutput.push(stringFromCharCode(currentValue));\n\t\t\t}\n\t\t}\n\n\t\thandledCPCount = basicLength = output.length;\n\n\t\t// `handledCPCount` is the number of code points that have been handled;\n\t\t// `basicLength` is the number of basic code points.\n\n\t\t// Finish the basic string - if it is not empty - with a delimiter\n\t\tif (basicLength) {\n\t\t\toutput.push(delimiter);\n\t\t}\n\n\t\t// Main encoding loop:\n\t\twhile (handledCPCount < inputLength) {\n\n\t\t\t// All non-basic code points < n have been handled already. Find the next\n\t\t\t// larger one:\n\t\t\tfor (m = maxInt, j = 0; j < inputLength; ++j) {\n\t\t\t\tcurrentValue = input[j];\n\t\t\t\tif (currentValue >= n && currentValue < m) {\n\t\t\t\t\tm = currentValue;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Increase `delta` enough to advance the decoder's <n,i> state to <m,0>,\n\t\t\t// but guard against overflow\n\t\t\thandledCPCountPlusOne = handledCPCount + 1;\n\t\t\tif (m - n > floor((maxInt - delta) / handledCPCountPlusOne)) {\n\t\t\t\terror('overflow');\n\t\t\t}\n\n\t\t\tdelta += (m - n) * handledCPCountPlusOne;\n\t\t\tn = m;\n\n\t\t\tfor (j = 0; j < inputLength; ++j) {\n\t\t\t\tcurrentValue = input[j];\n\n\t\t\t\tif (currentValue < n && ++delta > maxInt) {\n\t\t\t\t\terror('overflow');\n\t\t\t\t}\n\n\t\t\t\tif (currentValue == n) {\n\t\t\t\t\t// Represent delta as a generalized variable-length integer\n\t\t\t\t\tfor (q = delta, k = base; /* no condition */; k += base) {\n\t\t\t\t\t\tt = k <= bias ? tMin : (k >= bias + tMax ? tMax : k - bias);\n\t\t\t\t\t\tif (q < t) {\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tqMinusT = q - t;\n\t\t\t\t\t\tbaseMinusT = base - t;\n\t\t\t\t\t\toutput.push(\n\t\t\t\t\t\t\tstringFromCharCode(digitToBasic(t + qMinusT % baseMinusT, 0))\n\t\t\t\t\t\t);\n\t\t\t\t\t\tq = floor(qMinusT / baseMinusT);\n\t\t\t\t\t}\n\n\t\t\t\t\toutput.push(stringFromCharCode(digitToBasic(q, 0)));\n\t\t\t\t\tbias = adapt(delta, handledCPCountPlusOne, handledCPCount == basicLength);\n\t\t\t\t\tdelta = 0;\n\t\t\t\t\t++handledCPCount;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t++delta;\n\t\t\t++n;\n\n\t\t}\n\t\treturn output.join('');\n\t}\n\n\t/**\n\t * Converts a Punycode string representing a domain name or an email address\n\t * to Unicode. Only the Punycoded parts of the input will be converted, i.e.\n\t * it doesn't matter if you call it on a string that has already been\n\t * converted to Unicode.\n\t * @memberOf punycode\n\t * @param {String} input The Punycoded domain name or email address to\n\t * convert to Unicode.\n\t * @returns {String} The Unicode representation of the given Punycode\n\t * string.\n\t */\n\tfunction toUnicode(input) {\n\t\treturn mapDomain(input, function(string) {\n\t\t\treturn regexPunycode.test(string)\n\t\t\t\t? decode(string.slice(4).toLowerCase())\n\t\t\t\t: string;\n\t\t});\n\t}\n\n\t/**\n\t * Converts a Unicode string representing a domain name or an email address to\n\t * Punycode. Only the non-ASCII parts of the domain name will be converted,\n\t * i.e. it doesn't matter if you call it with a domain that's already in\n\t * ASCII.\n\t * @memberOf punycode\n\t * @param {String} input The domain name or email address to convert, as a\n\t * Unicode string.\n\t * @returns {String} The Punycode representation of the given domain name or\n\t * email address.\n\t */\n\tfunction toASCII(input) {\n\t\treturn mapDomain(input, function(string) {\n\t\t\treturn regexNonASCII.test(string)\n\t\t\t\t? 'xn--' + encode(string)\n\t\t\t\t: string;\n\t\t});\n\t}\n\n\t/*--------------------------------------------------------------------------*/\n\n\t/** Define the public API */\n\tpunycode = {\n\t\t/**\n\t\t * A string representing the current Punycode.js version number.\n\t\t * @memberOf punycode\n\t\t * @type String\n\t\t */\n\t\t'version': '1.3.2',\n\t\t/**\n\t\t * An object of methods to convert from JavaScript's internal character\n\t\t * representation (UCS-2) to Unicode code points, and back.\n\t\t * @see <https://mathiasbynens.be/notes/javascript-encoding>\n\t\t * @memberOf punycode\n\t\t * @type Object\n\t\t */\n\t\t'ucs2': {\n\t\t\t'decode': ucs2decode,\n\t\t\t'encode': ucs2encode\n\t\t},\n\t\t'decode': decode,\n\t\t'encode': encode,\n\t\t'toASCII': toASCII,\n\t\t'toUnicode': toUnicode\n\t};\n\n\t/** Expose `punycode` */\n\t// Some AMD build optimizers, like r.js, check for specific condition patterns\n\t// like the following:\n\tif (\n\t\ttypeof define == 'function' &&\n\t\ttypeof define.amd == 'object' &&\n\t\tdefine.amd\n\t) {\n\t\tdefine('punycode', function() {\n\t\t\treturn punycode;\n\t\t});\n\t} else if (freeExports && freeModule) {\n\t\tif (module.exports == freeExports) {\n\t\t\t// in Node.js, io.js, or RingoJS v0.8.0+\n\t\t\tfreeModule.exports = punycode;\n\t\t} else {\n\t\t\t// in Narwhal or RingoJS v0.7.0-\n\t\t\tfor (key in punycode) {\n\t\t\t\tpunycode.hasOwnProperty(key) && (freeExports[key] = punycode[key]);\n\t\t\t}\n\t\t}\n\t} else {\n\t\t// in Rhino or a web browser\n\t\troot.punycode = punycode;\n\t}\n\n}(this));\n\n}).call(this,typeof global !== \"undefined\" ? global : typeof self !== \"undefined\" ? self : typeof window !== \"undefined\" ? window : {})\n\n},{}],15:[function(require,module,exports){\n// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n'use strict';\n\n// If obj.hasOwnProperty has been overridden, then calling\n// obj.hasOwnProperty(prop) will break.\n// See: https://github.com/joyent/node/issues/1707\nfunction hasOwnProperty(obj, prop) {\n  return Object.prototype.hasOwnProperty.call(obj, prop);\n}\n\nmodule.exports = function(qs, sep, eq, options) {\n  sep = sep || '&';\n  eq = eq || '=';\n  var obj = {};\n\n  if (typeof qs !== 'string' || qs.length === 0) {\n    return obj;\n  }\n\n  var regexp = /\\+/g;\n  qs = qs.split(sep);\n\n  var maxKeys = 1000;\n  if (options && typeof options.maxKeys === 'number') {\n    maxKeys = options.maxKeys;\n  }\n\n  var len = qs.length;\n  // maxKeys <= 0 means that we should not limit keys count\n  if (maxKeys > 0 && len > maxKeys) {\n    len = maxKeys;\n  }\n\n  for (var i = 0; i < len; ++i) {\n    var x = qs[i].replace(regexp, '%20'),\n        idx = x.indexOf(eq),\n        kstr, vstr, k, v;\n\n    if (idx >= 0) {\n      kstr = x.substr(0, idx);\n      vstr = x.substr(idx + 1);\n    } else {\n      kstr = x;\n      vstr = '';\n    }\n\n    k = decodeURIComponent(kstr);\n    v = decodeURIComponent(vstr);\n\n    if (!hasOwnProperty(obj, k)) {\n      obj[k] = v;\n    } else if (isArray(obj[k])) {\n      obj[k].push(v);\n    } else {\n      obj[k] = [obj[k], v];\n    }\n  }\n\n  return obj;\n};\n\nvar isArray = Array.isArray || function (xs) {\n  return Object.prototype.toString.call(xs) === '[object Array]';\n};\n\n},{}],16:[function(require,module,exports){\n// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n'use strict';\n\nvar stringifyPrimitive = function(v) {\n  switch (typeof v) {\n    case 'string':\n      return v;\n\n    case 'boolean':\n      return v ? 'true' : 'false';\n\n    case 'number':\n      return isFinite(v) ? v : '';\n\n    default:\n      return '';\n  }\n};\n\nmodule.exports = function(obj, sep, eq, name) {\n  sep = sep || '&';\n  eq = eq || '=';\n  if (obj === null) {\n    obj = undefined;\n  }\n\n  if (typeof obj === 'object') {\n    return map(objectKeys(obj), function(k) {\n      var ks = encodeURIComponent(stringifyPrimitive(k)) + eq;\n      if (isArray(obj[k])) {\n        return map(obj[k], function(v) {\n          return ks + encodeURIComponent(stringifyPrimitive(v));\n        }).join(sep);\n      } else {\n        return ks + encodeURIComponent(stringifyPrimitive(obj[k]));\n      }\n    }).join(sep);\n\n  }\n\n  if (!name) return '';\n  return encodeURIComponent(stringifyPrimitive(name)) + eq +\n         encodeURIComponent(stringifyPrimitive(obj));\n};\n\nvar isArray = Array.isArray || function (xs) {\n  return Object.prototype.toString.call(xs) === '[object Array]';\n};\n\nfunction map (xs, f) {\n  if (xs.map) return xs.map(f);\n  var res = [];\n  for (var i = 0; i < xs.length; i++) {\n    res.push(f(xs[i], i));\n  }\n  return res;\n}\n\nvar objectKeys = Object.keys || function (obj) {\n  var res = [];\n  for (var key in obj) {\n    if (Object.prototype.hasOwnProperty.call(obj, key)) res.push(key);\n  }\n  return res;\n};\n\n},{}],17:[function(require,module,exports){\n'use strict';\n\nexports.decode = exports.parse = require('./decode');\nexports.encode = exports.stringify = require('./encode');\n\n},{\"./decode\":15,\"./encode\":16}],18:[function(require,module,exports){\nmodule.exports = require(\"./lib/_stream_duplex.js\")\n\n},{\"./lib/_stream_duplex.js\":19}],19:[function(require,module,exports){\n// a duplex stream is just a stream that is both readable and writable.\n// Since JS doesn't have multiple prototypal inheritance, this class\n// prototypally inherits from Readable, and then parasitically from\n// Writable.\n\n'use strict';\n\n/*<replacement>*/\nvar objectKeys = Object.keys || function (obj) {\n  var keys = [];\n  for (var key in obj) keys.push(key);\n  return keys;\n}\n/*</replacement>*/\n\n\nmodule.exports = Duplex;\n\n/*<replacement>*/\nvar processNextTick = require('process-nextick-args');\n/*</replacement>*/\n\n\n\n/*<replacement>*/\nvar util = require('core-util-is');\nutil.inherits = require('inherits');\n/*</replacement>*/\n\nvar Readable = require('./_stream_readable');\nvar Writable = require('./_stream_writable');\n\nutil.inherits(Duplex, Readable);\n\nvar keys = objectKeys(Writable.prototype);\nfor (var v = 0; v < keys.length; v++) {\n  var method = keys[v];\n  if (!Duplex.prototype[method])\n    Duplex.prototype[method] = Writable.prototype[method];\n}\n\nfunction Duplex(options) {\n  if (!(this instanceof Duplex))\n    return new Duplex(options);\n\n  Readable.call(this, options);\n  Writable.call(this, options);\n\n  if (options && options.readable === false)\n    this.readable = false;\n\n  if (options && options.writable === false)\n    this.writable = false;\n\n  this.allowHalfOpen = true;\n  if (options && options.allowHalfOpen === false)\n    this.allowHalfOpen = false;\n\n  this.once('end', onend);\n}\n\n// the no-half-open enforcer\nfunction onend() {\n  // if we allow half-open state, or if the writable side ended,\n  // then we're ok.\n  if (this.allowHalfOpen || this._writableState.ended)\n    return;\n\n  // no more data can be written.\n  // But allow more writes to happen in this tick.\n  processNextTick(onEndNT, this);\n}\n\nfunction onEndNT(self) {\n  self.end();\n}\n\nfunction forEach (xs, f) {\n  for (var i = 0, l = xs.length; i < l; i++) {\n    f(xs[i], i);\n  }\n}\n\n},{\"./_stream_readable\":21,\"./_stream_writable\":23,\"core-util-is\":24,\"inherits\":10,\"process-nextick-args\":25}],20:[function(require,module,exports){\n// a passthrough stream.\n// basically just the most minimal sort of Transform stream.\n// Every written chunk gets output as-is.\n\n'use strict';\n\nmodule.exports = PassThrough;\n\nvar Transform = require('./_stream_transform');\n\n/*<replacement>*/\nvar util = require('core-util-is');\nutil.inherits = require('inherits');\n/*</replacement>*/\n\nutil.inherits(PassThrough, Transform);\n\nfunction PassThrough(options) {\n  if (!(this instanceof PassThrough))\n    return new PassThrough(options);\n\n  Transform.call(this, options);\n}\n\nPassThrough.prototype._transform = function(chunk, encoding, cb) {\n  cb(null, chunk);\n};\n\n},{\"./_stream_transform\":22,\"core-util-is\":24,\"inherits\":10}],21:[function(require,module,exports){\n(function (process){\n'use strict';\n\nmodule.exports = Readable;\n\n/*<replacement>*/\nvar processNextTick = require('process-nextick-args');\n/*</replacement>*/\n\n\n/*<replacement>*/\nvar isArray = require('isarray');\n/*</replacement>*/\n\n\n/*<replacement>*/\nvar Buffer = require('buffer').Buffer;\n/*</replacement>*/\n\nReadable.ReadableState = ReadableState;\n\nvar EE = require('events');\n\n/*<replacement>*/\nvar EElistenerCount = function(emitter, type) {\n  return emitter.listeners(type).length;\n};\n/*</replacement>*/\n\n\n\n/*<replacement>*/\nvar Stream;\n(function (){try{\n  Stream = require('st' + 'ream');\n}catch(_){}finally{\n  if (!Stream)\n    Stream = require('events').EventEmitter;\n}}())\n/*</replacement>*/\n\nvar Buffer = require('buffer').Buffer;\n\n/*<replacement>*/\nvar util = require('core-util-is');\nutil.inherits = require('inherits');\n/*</replacement>*/\n\n\n\n/*<replacement>*/\nvar debugUtil = require('util');\nvar debug;\nif (debugUtil && debugUtil.debuglog) {\n  debug = debugUtil.debuglog('stream');\n} else {\n  debug = function () {};\n}\n/*</replacement>*/\n\nvar StringDecoder;\n\nutil.inherits(Readable, Stream);\n\nfunction ReadableState(options, stream) {\n  var Duplex = require('./_stream_duplex');\n\n  options = options || {};\n\n  // object stream flag. Used to make read(n) ignore n and to\n  // make all the buffer merging and length checks go away\n  this.objectMode = !!options.objectMode;\n\n  if (stream instanceof Duplex)\n    this.objectMode = this.objectMode || !!options.readableObjectMode;\n\n  // the point at which it stops calling _read() to fill the buffer\n  // Note: 0 is a valid value, means \"don't call _read preemptively ever\"\n  var hwm = options.highWaterMark;\n  var defaultHwm = this.objectMode ? 16 : 16 * 1024;\n  this.highWaterMark = (hwm || hwm === 0) ? hwm : defaultHwm;\n\n  // cast to ints.\n  this.highWaterMark = ~~this.highWaterMark;\n\n  this.buffer = [];\n  this.length = 0;\n  this.pipes = null;\n  this.pipesCount = 0;\n  this.flowing = null;\n  this.ended = false;\n  this.endEmitted = false;\n  this.reading = false;\n\n  // a flag to be able to tell if the onwrite cb is called immediately,\n  // or on a later tick.  We set this to true at first, because any\n  // actions that shouldn't happen until \"later\" should generally also\n  // not happen before the first write call.\n  this.sync = true;\n\n  // whenever we return null, then we set a flag to say\n  // that we're awaiting a 'readable' event emission.\n  this.needReadable = false;\n  this.emittedReadable = false;\n  this.readableListening = false;\n\n  // Crypto is kind of old and crusty.  Historically, its default string\n  // encoding is 'binary' so we have to make this configurable.\n  // Everything else in the universe uses 'utf8', though.\n  this.defaultEncoding = options.defaultEncoding || 'utf8';\n\n  // when piping, we only care about 'readable' events that happen\n  // after read()ing all the bytes and not getting any pushback.\n  this.ranOut = false;\n\n  // the number of writers that are awaiting a drain event in .pipe()s\n  this.awaitDrain = 0;\n\n  // if true, a maybeReadMore has been scheduled\n  this.readingMore = false;\n\n  this.decoder = null;\n  this.encoding = null;\n  if (options.encoding) {\n    if (!StringDecoder)\n      StringDecoder = require('string_decoder/').StringDecoder;\n    this.decoder = new StringDecoder(options.encoding);\n    this.encoding = options.encoding;\n  }\n}\n\nfunction Readable(options) {\n  var Duplex = require('./_stream_duplex');\n\n  if (!(this instanceof Readable))\n    return new Readable(options);\n\n  this._readableState = new ReadableState(options, this);\n\n  // legacy\n  this.readable = true;\n\n  if (options && typeof options.read === 'function')\n    this._read = options.read;\n\n  Stream.call(this);\n}\n\n// Manually shove something into the read() buffer.\n// This returns true if the highWaterMark has not been hit yet,\n// similar to how Writable.write() returns true if you should\n// write() some more.\nReadable.prototype.push = function(chunk, encoding) {\n  var state = this._readableState;\n\n  if (!state.objectMode && typeof chunk === 'string') {\n    encoding = encoding || state.defaultEncoding;\n    if (encoding !== state.encoding) {\n      chunk = new Buffer(chunk, encoding);\n      encoding = '';\n    }\n  }\n\n  return readableAddChunk(this, state, chunk, encoding, false);\n};\n\n// Unshift should *always* be something directly out of read()\nReadable.prototype.unshift = function(chunk) {\n  var state = this._readableState;\n  return readableAddChunk(this, state, chunk, '', true);\n};\n\nReadable.prototype.isPaused = function() {\n  return this._readableState.flowing === false;\n};\n\nfunction readableAddChunk(stream, state, chunk, encoding, addToFront) {\n  var er = chunkInvalid(state, chunk);\n  if (er) {\n    stream.emit('error', er);\n  } else if (chunk === null) {\n    state.reading = false;\n    onEofChunk(stream, state);\n  } else if (state.objectMode || chunk && chunk.length > 0) {\n    if (state.ended && !addToFront) {\n      var e = new Error('stream.push() after EOF');\n      stream.emit('error', e);\n    } else if (state.endEmitted && addToFront) {\n      var e = new Error('stream.unshift() after end event');\n      stream.emit('error', e);\n    } else {\n      if (state.decoder && !addToFront && !encoding)\n        chunk = state.decoder.write(chunk);\n\n      if (!addToFront)\n        state.reading = false;\n\n      // if we want the data now, just emit it.\n      if (state.flowing && state.length === 0 && !state.sync) {\n        stream.emit('data', chunk);\n        stream.read(0);\n      } else {\n        // update the buffer info.\n        state.length += state.objectMode ? 1 : chunk.length;\n        if (addToFront)\n          state.buffer.unshift(chunk);\n        else\n          state.buffer.push(chunk);\n\n        if (state.needReadable)\n          emitReadable(stream);\n      }\n\n      maybeReadMore(stream, state);\n    }\n  } else if (!addToFront) {\n    state.reading = false;\n  }\n\n  return needMoreData(state);\n}\n\n\n// if it's past the high water mark, we can push in some more.\n// Also, if we have no data yet, we can stand some\n// more bytes.  This is to work around cases where hwm=0,\n// such as the repl.  Also, if the push() triggered a\n// readable event, and the user called read(largeNumber) such that\n// needReadable was set, then we ought to push more, so that another\n// 'readable' event will be triggered.\nfunction needMoreData(state) {\n  return !state.ended &&\n         (state.needReadable ||\n          state.length < state.highWaterMark ||\n          state.length === 0);\n}\n\n// backwards compatibility.\nReadable.prototype.setEncoding = function(enc) {\n  if (!StringDecoder)\n    StringDecoder = require('string_decoder/').StringDecoder;\n  this._readableState.decoder = new StringDecoder(enc);\n  this._readableState.encoding = enc;\n  return this;\n};\n\n// Don't raise the hwm > 8MB\nvar MAX_HWM = 0x800000;\nfunction computeNewHighWaterMark(n) {\n  if (n >= MAX_HWM) {\n    n = MAX_HWM;\n  } else {\n    // Get the next highest power of 2\n    n--;\n    n |= n >>> 1;\n    n |= n >>> 2;\n    n |= n >>> 4;\n    n |= n >>> 8;\n    n |= n >>> 16;\n    n++;\n  }\n  return n;\n}\n\nfunction howMuchToRead(n, state) {\n  if (state.length === 0 && state.ended)\n    return 0;\n\n  if (state.objectMode)\n    return n === 0 ? 0 : 1;\n\n  if (n === null || isNaN(n)) {\n    // only flow one buffer at a time\n    if (state.flowing && state.buffer.length)\n      return state.buffer[0].length;\n    else\n      return state.length;\n  }\n\n  if (n <= 0)\n    return 0;\n\n  // If we're asking for more than the target buffer level,\n  // then raise the water mark.  Bump up to the next highest\n  // power of 2, to prevent increasing it excessively in tiny\n  // amounts.\n  if (n > state.highWaterMark)\n    state.highWaterMark = computeNewHighWaterMark(n);\n\n  // don't have that much.  return null, unless we've ended.\n  if (n > state.length) {\n    if (!state.ended) {\n      state.needReadable = true;\n      return 0;\n    } else {\n      return state.length;\n    }\n  }\n\n  return n;\n}\n\n// you can override either this method, or the async _read(n) below.\nReadable.prototype.read = function(n) {\n  debug('read', n);\n  var state = this._readableState;\n  var nOrig = n;\n\n  if (typeof n !== 'number' || n > 0)\n    state.emittedReadable = false;\n\n  // if we're doing read(0) to trigger a readable event, but we\n  // already have a bunch of data in the buffer, then just trigger\n  // the 'readable' event and move on.\n  if (n === 0 &&\n      state.needReadable &&\n      (state.length >= state.highWaterMark || state.ended)) {\n    debug('read: emitReadable', state.length, state.ended);\n    if (state.length === 0 && state.ended)\n      endReadable(this);\n    else\n      emitReadable(this);\n    return null;\n  }\n\n  n = howMuchToRead(n, state);\n\n  // if we've ended, and we're now clear, then finish it up.\n  if (n === 0 && state.ended) {\n    if (state.length === 0)\n      endReadable(this);\n    return null;\n  }\n\n  // All the actual chunk generation logic needs to be\n  // *below* the call to _read.  The reason is that in certain\n  // synthetic stream cases, such as passthrough streams, _read\n  // may be a completely synchronous operation which may change\n  // the state of the read buffer, providing enough data when\n  // before there was *not* enough.\n  //\n  // So, the steps are:\n  // 1. Figure out what the state of things will be after we do\n  // a read from the buffer.\n  //\n  // 2. If that resulting state will trigger a _read, then call _read.\n  // Note that this may be asynchronous, or synchronous.  Yes, it is\n  // deeply ugly to write APIs this way, but that still doesn't mean\n  // that the Readable class should behave improperly, as streams are\n  // designed to be sync/async agnostic.\n  // Take note if the _read call is sync or async (ie, if the read call\n  // has returned yet), so that we know whether or not it's safe to emit\n  // 'readable' etc.\n  //\n  // 3. Actually pull the requested chunks out of the buffer and return.\n\n  // if we need a readable event, then we need to do some reading.\n  var doRead = state.needReadable;\n  debug('need readable', doRead);\n\n  // if we currently have less than the highWaterMark, then also read some\n  if (state.length === 0 || state.length - n < state.highWaterMark) {\n    doRead = true;\n    debug('length less than watermark', doRead);\n  }\n\n  // however, if we've ended, then there's no point, and if we're already\n  // reading, then it's unnecessary.\n  if (state.ended || state.reading) {\n    doRead = false;\n    debug('reading or ended', doRead);\n  }\n\n  if (doRead) {\n    debug('do read');\n    state.reading = true;\n    state.sync = true;\n    // if the length is currently zero, then we *need* a readable event.\n    if (state.length === 0)\n      state.needReadable = true;\n    // call internal read method\n    this._read(state.highWaterMark);\n    state.sync = false;\n  }\n\n  // If _read pushed data synchronously, then `reading` will be false,\n  // and we need to re-evaluate how much data we can return to the user.\n  if (doRead && !state.reading)\n    n = howMuchToRead(nOrig, state);\n\n  var ret;\n  if (n > 0)\n    ret = fromList(n, state);\n  else\n    ret = null;\n\n  if (ret === null) {\n    state.needReadable = true;\n    n = 0;\n  }\n\n  state.length -= n;\n\n  // If we have nothing in the buffer, then we want to know\n  // as soon as we *do* get something into the buffer.\n  if (state.length === 0 && !state.ended)\n    state.needReadable = true;\n\n  // If we tried to read() past the EOF, then emit end on the next tick.\n  if (nOrig !== n && state.ended && state.length === 0)\n    endReadable(this);\n\n  if (ret !== null)\n    this.emit('data', ret);\n\n  return ret;\n};\n\nfunction chunkInvalid(state, chunk) {\n  var er = null;\n  if (!(Buffer.isBuffer(chunk)) &&\n      typeof chunk !== 'string' &&\n      chunk !== null &&\n      chunk !== undefined &&\n      !state.objectMode) {\n    er = new TypeError('Invalid non-string/buffer chunk');\n  }\n  return er;\n}\n\n\nfunction onEofChunk(stream, state) {\n  if (state.ended) return;\n  if (state.decoder) {\n    var chunk = state.decoder.end();\n    if (chunk && chunk.length) {\n      state.buffer.push(chunk);\n      state.length += state.objectMode ? 1 : chunk.length;\n    }\n  }\n  state.ended = true;\n\n  // emit 'readable' now to make sure it gets picked up.\n  emitReadable(stream);\n}\n\n// Don't emit readable right away in sync mode, because this can trigger\n// another read() call => stack overflow.  This way, it might trigger\n// a nextTick recursion warning, but that's not so bad.\nfunction emitReadable(stream) {\n  var state = stream._readableState;\n  state.needReadable = false;\n  if (!state.emittedReadable) {\n    debug('emitReadable', state.flowing);\n    state.emittedReadable = true;\n    if (state.sync)\n      processNextTick(emitReadable_, stream);\n    else\n      emitReadable_(stream);\n  }\n}\n\nfunction emitReadable_(stream) {\n  debug('emit readable');\n  stream.emit('readable');\n  flow(stream);\n}\n\n\n// at this point, the user has presumably seen the 'readable' event,\n// and called read() to consume some data.  that may have triggered\n// in turn another _read(n) call, in which case reading = true if\n// it's in progress.\n// However, if we're not ended, or reading, and the length < hwm,\n// then go ahead and try to read some more preemptively.\nfunction maybeReadMore(stream, state) {\n  if (!state.readingMore) {\n    state.readingMore = true;\n    processNextTick(maybeReadMore_, stream, state);\n  }\n}\n\nfunction maybeReadMore_(stream, state) {\n  var len = state.length;\n  while (!state.reading && !state.flowing && !state.ended &&\n         state.length < state.highWaterMark) {\n    debug('maybeReadMore read 0');\n    stream.read(0);\n    if (len === state.length)\n      // didn't get any data, stop spinning.\n      break;\n    else\n      len = state.length;\n  }\n  state.readingMore = false;\n}\n\n// abstract method.  to be overridden in specific implementation classes.\n// call cb(er, data) where data is <= n in length.\n// for virtual (non-string, non-buffer) streams, \"length\" is somewhat\n// arbitrary, and perhaps not very meaningful.\nReadable.prototype._read = function(n) {\n  this.emit('error', new Error('not implemented'));\n};\n\nReadable.prototype.pipe = function(dest, pipeOpts) {\n  var src = this;\n  var state = this._readableState;\n\n  switch (state.pipesCount) {\n    case 0:\n      state.pipes = dest;\n      break;\n    case 1:\n      state.pipes = [state.pipes, dest];\n      break;\n    default:\n      state.pipes.push(dest);\n      break;\n  }\n  state.pipesCount += 1;\n  debug('pipe count=%d opts=%j', state.pipesCount, pipeOpts);\n\n  var doEnd = (!pipeOpts || pipeOpts.end !== false) &&\n              dest !== process.stdout &&\n              dest !== process.stderr;\n\n  var endFn = doEnd ? onend : cleanup;\n  if (state.endEmitted)\n    processNextTick(endFn);\n  else\n    src.once('end', endFn);\n\n  dest.on('unpipe', onunpipe);\n  function onunpipe(readable) {\n    debug('onunpipe');\n    if (readable === src) {\n      cleanup();\n    }\n  }\n\n  function onend() {\n    debug('onend');\n    dest.end();\n  }\n\n  // when the dest drains, it reduces the awaitDrain counter\n  // on the source.  This would be more elegant with a .once()\n  // handler in flow(), but adding and removing repeatedly is\n  // too slow.\n  var ondrain = pipeOnDrain(src);\n  dest.on('drain', ondrain);\n\n  var cleanedUp = false;\n  function cleanup() {\n    debug('cleanup');\n    // cleanup event handlers once the pipe is broken\n    dest.removeListener('close', onclose);\n    dest.removeListener('finish', onfinish);\n    dest.removeListener('drain', ondrain);\n    dest.removeListener('error', onerror);\n    dest.removeListener('unpipe', onunpipe);\n    src.removeListener('end', onend);\n    src.removeListener('end', cleanup);\n    src.removeListener('data', ondata);\n\n    cleanedUp = true;\n\n    // if the reader is waiting for a drain event from this\n    // specific writer, then it would cause it to never start\n    // flowing again.\n    // So, if this is awaiting a drain, then we just call it now.\n    // If we don't know, then assume that we are waiting for one.\n    if (state.awaitDrain &&\n        (!dest._writableState || dest._writableState.needDrain))\n      ondrain();\n  }\n\n  src.on('data', ondata);\n  function ondata(chunk) {\n    debug('ondata');\n    var ret = dest.write(chunk);\n    if (false === ret) {\n      // If the user unpiped during `dest.write()`, it is possible\n      // to get stuck in a permanently paused state if that write\n      // also returned false.\n      if (state.pipesCount === 1 &&\n          state.pipes[0] === dest &&\n          src.listenerCount('data') === 1 &&\n          !cleanedUp) {\n        debug('false write response, pause', src._readableState.awaitDrain);\n        src._readableState.awaitDrain++;\n      }\n      src.pause();\n    }\n  }\n\n  // if the dest has an error, then stop piping into it.\n  // however, don't suppress the throwing behavior for this.\n  function onerror(er) {\n    debug('onerror', er);\n    unpipe();\n    dest.removeListener('error', onerror);\n    if (EElistenerCount(dest, 'error') === 0)\n      dest.emit('error', er);\n  }\n  // This is a brutally ugly hack to make sure that our error handler\n  // is attached before any userland ones.  NEVER DO THIS.\n  if (!dest._events || !dest._events.error)\n    dest.on('error', onerror);\n  else if (isArray(dest._events.error))\n    dest._events.error.unshift(onerror);\n  else\n    dest._events.error = [onerror, dest._events.error];\n\n\n  // Both close and finish should trigger unpipe, but only once.\n  function onclose() {\n    dest.removeListener('finish', onfinish);\n    unpipe();\n  }\n  dest.once('close', onclose);\n  function onfinish() {\n    debug('onfinish');\n    dest.removeListener('close', onclose);\n    unpipe();\n  }\n  dest.once('finish', onfinish);\n\n  function unpipe() {\n    debug('unpipe');\n    src.unpipe(dest);\n  }\n\n  // tell the dest that it's being piped to\n  dest.emit('pipe', src);\n\n  // start the flow if it hasn't been started already.\n  if (!state.flowing) {\n    debug('pipe resume');\n    src.resume();\n  }\n\n  return dest;\n};\n\nfunction pipeOnDrain(src) {\n  return function() {\n    var state = src._readableState;\n    debug('pipeOnDrain', state.awaitDrain);\n    if (state.awaitDrain)\n      state.awaitDrain--;\n    if (state.awaitDrain === 0 && EElistenerCount(src, 'data')) {\n      state.flowing = true;\n      flow(src);\n    }\n  };\n}\n\n\nReadable.prototype.unpipe = function(dest) {\n  var state = this._readableState;\n\n  // if we're not piping anywhere, then do nothing.\n  if (state.pipesCount === 0)\n    return this;\n\n  // just one destination.  most common case.\n  if (state.pipesCount === 1) {\n    // passed in one, but it's not the right one.\n    if (dest && dest !== state.pipes)\n      return this;\n\n    if (!dest)\n      dest = state.pipes;\n\n    // got a match.\n    state.pipes = null;\n    state.pipesCount = 0;\n    state.flowing = false;\n    if (dest)\n      dest.emit('unpipe', this);\n    return this;\n  }\n\n  // slow case. multiple pipe destinations.\n\n  if (!dest) {\n    // remove all.\n    var dests = state.pipes;\n    var len = state.pipesCount;\n    state.pipes = null;\n    state.pipesCount = 0;\n    state.flowing = false;\n\n    for (var i = 0; i < len; i++)\n      dests[i].emit('unpipe', this);\n    return this;\n  }\n\n  // try to find the right one.\n  var i = indexOf(state.pipes, dest);\n  if (i === -1)\n    return this;\n\n  state.pipes.splice(i, 1);\n  state.pipesCount -= 1;\n  if (state.pipesCount === 1)\n    state.pipes = state.pipes[0];\n\n  dest.emit('unpipe', this);\n\n  return this;\n};\n\n// set up data events if they are asked for\n// Ensure readable listeners eventually get something\nReadable.prototype.on = function(ev, fn) {\n  var res = Stream.prototype.on.call(this, ev, fn);\n\n  // If listening to data, and it has not explicitly been paused,\n  // then call resume to start the flow of data on the next tick.\n  if (ev === 'data' && false !== this._readableState.flowing) {\n    this.resume();\n  }\n\n  if (ev === 'readable' && this.readable) {\n    var state = this._readableState;\n    if (!state.readableListening) {\n      state.readableListening = true;\n      state.emittedReadable = false;\n      state.needReadable = true;\n      if (!state.reading) {\n        processNextTick(nReadingNextTick, this);\n      } else if (state.length) {\n        emitReadable(this, state);\n      }\n    }\n  }\n\n  return res;\n};\nReadable.prototype.addListener = Readable.prototype.on;\n\nfunction nReadingNextTick(self) {\n  debug('readable nexttick read 0');\n  self.read(0);\n}\n\n// pause() and resume() are remnants of the legacy readable stream API\n// If the user uses them, then switch into old mode.\nReadable.prototype.resume = function() {\n  var state = this._readableState;\n  if (!state.flowing) {\n    debug('resume');\n    state.flowing = true;\n    resume(this, state);\n  }\n  return this;\n};\n\nfunction resume(stream, state) {\n  if (!state.resumeScheduled) {\n    state.resumeScheduled = true;\n    processNextTick(resume_, stream, state);\n  }\n}\n\nfunction resume_(stream, state) {\n  if (!state.reading) {\n    debug('resume read 0');\n    stream.read(0);\n  }\n\n  state.resumeScheduled = false;\n  stream.emit('resume');\n  flow(stream);\n  if (state.flowing && !state.reading)\n    stream.read(0);\n}\n\nReadable.prototype.pause = function() {\n  debug('call pause flowing=%j', this._readableState.flowing);\n  if (false !== this._readableState.flowing) {\n    debug('pause');\n    this._readableState.flowing = false;\n    this.emit('pause');\n  }\n  return this;\n};\n\nfunction flow(stream) {\n  var state = stream._readableState;\n  debug('flow', state.flowing);\n  if (state.flowing) {\n    do {\n      var chunk = stream.read();\n    } while (null !== chunk && state.flowing);\n  }\n}\n\n// wrap an old-style stream as the async data source.\n// This is *not* part of the readable stream interface.\n// It is an ugly unfortunate mess of history.\nReadable.prototype.wrap = function(stream) {\n  var state = this._readableState;\n  var paused = false;\n\n  var self = this;\n  stream.on('end', function() {\n    debug('wrapped end');\n    if (state.decoder && !state.ended) {\n      var chunk = state.decoder.end();\n      if (chunk && chunk.length)\n        self.push(chunk);\n    }\n\n    self.push(null);\n  });\n\n  stream.on('data', function(chunk) {\n    debug('wrapped data');\n    if (state.decoder)\n      chunk = state.decoder.write(chunk);\n\n    // don't skip over falsy values in objectMode\n    if (state.objectMode && (chunk === null || chunk === undefined))\n      return;\n    else if (!state.objectMode && (!chunk || !chunk.length))\n      return;\n\n    var ret = self.push(chunk);\n    if (!ret) {\n      paused = true;\n      stream.pause();\n    }\n  });\n\n  // proxy all the other methods.\n  // important when wrapping filters and duplexes.\n  for (var i in stream) {\n    if (this[i] === undefined && typeof stream[i] === 'function') {\n      this[i] = function(method) { return function() {\n        return stream[method].apply(stream, arguments);\n      }; }(i);\n    }\n  }\n\n  // proxy certain important events.\n  var events = ['error', 'close', 'destroy', 'pause', 'resume'];\n  forEach(events, function(ev) {\n    stream.on(ev, self.emit.bind(self, ev));\n  });\n\n  // when we try to consume some more bytes, simply unpause the\n  // underlying stream.\n  self._read = function(n) {\n    debug('wrapped _read', n);\n    if (paused) {\n      paused = false;\n      stream.resume();\n    }\n  };\n\n  return self;\n};\n\n\n// exposed for testing purposes only.\nReadable._fromList = fromList;\n\n// Pluck off n bytes from an array of buffers.\n// Length is the combined lengths of all the buffers in the list.\nfunction fromList(n, state) {\n  var list = state.buffer;\n  var length = state.length;\n  var stringMode = !!state.decoder;\n  var objectMode = !!state.objectMode;\n  var ret;\n\n  // nothing in the list, definitely empty.\n  if (list.length === 0)\n    return null;\n\n  if (length === 0)\n    ret = null;\n  else if (objectMode)\n    ret = list.shift();\n  else if (!n || n >= length) {\n    // read it all, truncate the array.\n    if (stringMode)\n      ret = list.join('');\n    else if (list.length === 1)\n      ret = list[0];\n    else\n      ret = Buffer.concat(list, length);\n    list.length = 0;\n  } else {\n    // read just some of it.\n    if (n < list[0].length) {\n      // just take a part of the first list item.\n      // slice is the same for buffers and strings.\n      var buf = list[0];\n      ret = buf.slice(0, n);\n      list[0] = buf.slice(n);\n    } else if (n === list[0].length) {\n      // first list is a perfect match\n      ret = list.shift();\n    } else {\n      // complex case.\n      // we have enough to cover it, but it spans past the first buffer.\n      if (stringMode)\n        ret = '';\n      else\n        ret = new Buffer(n);\n\n      var c = 0;\n      for (var i = 0, l = list.length; i < l && c < n; i++) {\n        var buf = list[0];\n        var cpy = Math.min(n - c, buf.length);\n\n        if (stringMode)\n          ret += buf.slice(0, cpy);\n        else\n          buf.copy(ret, c, 0, cpy);\n\n        if (cpy < buf.length)\n          list[0] = buf.slice(cpy);\n        else\n          list.shift();\n\n        c += cpy;\n      }\n    }\n  }\n\n  return ret;\n}\n\nfunction endReadable(stream) {\n  var state = stream._readableState;\n\n  // If we get here before consuming all the bytes, then that is a\n  // bug in node.  Should never happen.\n  if (state.length > 0)\n    throw new Error('endReadable called on non-empty stream');\n\n  if (!state.endEmitted) {\n    state.ended = true;\n    processNextTick(endReadableNT, state, stream);\n  }\n}\n\nfunction endReadableNT(state, stream) {\n  // Check that we didn't get one last unshift.\n  if (!state.endEmitted && state.length === 0) {\n    state.endEmitted = true;\n    stream.readable = false;\n    stream.emit('end');\n  }\n}\n\nfunction forEach (xs, f) {\n  for (var i = 0, l = xs.length; i < l; i++) {\n    f(xs[i], i);\n  }\n}\n\nfunction indexOf (xs, x) {\n  for (var i = 0, l = xs.length; i < l; i++) {\n    if (xs[i] === x) return i;\n  }\n  return -1;\n}\n\n}).call(this,require('_process'))\n\n},{\"./_stream_duplex\":19,\"_process\":13,\"buffer\":4,\"core-util-is\":24,\"events\":8,\"inherits\":10,\"isarray\":12,\"process-nextick-args\":25,\"string_decoder/\":37,\"util\":3}],22:[function(require,module,exports){\n// a transform stream is a readable/writable stream where you do\n// something with the data.  Sometimes it's called a \"filter\",\n// but that's not a great name for it, since that implies a thing where\n// some bits pass through, and others are simply ignored.  (That would\n// be a valid example of a transform, of course.)\n//\n// While the output is causally related to the input, it's not a\n// necessarily symmetric or synchronous transformation.  For example,\n// a zlib stream might take multiple plain-text writes(), and then\n// emit a single compressed chunk some time in the future.\n//\n// Here's how this works:\n//\n// The Transform stream has all the aspects of the readable and writable\n// stream classes.  When you write(chunk), that calls _write(chunk,cb)\n// internally, and returns false if there's a lot of pending writes\n// buffered up.  When you call read(), that calls _read(n) until\n// there's enough pending readable data buffered up.\n//\n// In a transform stream, the written data is placed in a buffer.  When\n// _read(n) is called, it transforms the queued up data, calling the\n// buffered _write cb's as it consumes chunks.  If consuming a single\n// written chunk would result in multiple output chunks, then the first\n// outputted bit calls the readcb, and subsequent chunks just go into\n// the read buffer, and will cause it to emit 'readable' if necessary.\n//\n// This way, back-pressure is actually determined by the reading side,\n// since _read has to be called to start processing a new chunk.  However,\n// a pathological inflate type of transform can cause excessive buffering\n// here.  For example, imagine a stream where every byte of input is\n// interpreted as an integer from 0-255, and then results in that many\n// bytes of output.  Writing the 4 bytes {ff,ff,ff,ff} would result in\n// 1kb of data being output.  In this case, you could write a very small\n// amount of input, and end up with a very large amount of output.  In\n// such a pathological inflating mechanism, there'd be no way to tell\n// the system to stop doing the transform.  A single 4MB write could\n// cause the system to run out of memory.\n//\n// However, even in such a pathological case, only a single written chunk\n// would be consumed, and then the rest would wait (un-transformed) until\n// the results of the previous transformed chunk were consumed.\n\n'use strict';\n\nmodule.exports = Transform;\n\nvar Duplex = require('./_stream_duplex');\n\n/*<replacement>*/\nvar util = require('core-util-is');\nutil.inherits = require('inherits');\n/*</replacement>*/\n\nutil.inherits(Transform, Duplex);\n\n\nfunction TransformState(stream) {\n  this.afterTransform = function(er, data) {\n    return afterTransform(stream, er, data);\n  };\n\n  this.needTransform = false;\n  this.transforming = false;\n  this.writecb = null;\n  this.writechunk = null;\n}\n\nfunction afterTransform(stream, er, data) {\n  var ts = stream._transformState;\n  ts.transforming = false;\n\n  var cb = ts.writecb;\n\n  if (!cb)\n    return stream.emit('error', new Error('no writecb in Transform class'));\n\n  ts.writechunk = null;\n  ts.writecb = null;\n\n  if (data !== null && data !== undefined)\n    stream.push(data);\n\n  if (cb)\n    cb(er);\n\n  var rs = stream._readableState;\n  rs.reading = false;\n  if (rs.needReadable || rs.length < rs.highWaterMark) {\n    stream._read(rs.highWaterMark);\n  }\n}\n\n\nfunction Transform(options) {\n  if (!(this instanceof Transform))\n    return new Transform(options);\n\n  Duplex.call(this, options);\n\n  this._transformState = new TransformState(this);\n\n  // when the writable side finishes, then flush out anything remaining.\n  var stream = this;\n\n  // start out asking for a readable event once data is transformed.\n  this._readableState.needReadable = true;\n\n  // we have implemented the _read method, and done the other things\n  // that Readable wants before the first _read call, so unset the\n  // sync guard flag.\n  this._readableState.sync = false;\n\n  if (options) {\n    if (typeof options.transform === 'function')\n      this._transform = options.transform;\n\n    if (typeof options.flush === 'function')\n      this._flush = options.flush;\n  }\n\n  this.once('prefinish', function() {\n    if (typeof this._flush === 'function')\n      this._flush(function(er) {\n        done(stream, er);\n      });\n    else\n      done(stream);\n  });\n}\n\nTransform.prototype.push = function(chunk, encoding) {\n  this._transformState.needTransform = false;\n  return Duplex.prototype.push.call(this, chunk, encoding);\n};\n\n// This is the part where you do stuff!\n// override this function in implementation classes.\n// 'chunk' is an input chunk.\n//\n// Call `push(newChunk)` to pass along transformed output\n// to the readable side.  You may call 'push' zero or more times.\n//\n// Call `cb(err)` when you are done with this chunk.  If you pass\n// an error, then that'll put the hurt on the whole operation.  If you\n// never call cb(), then you'll never get another chunk.\nTransform.prototype._transform = function(chunk, encoding, cb) {\n  throw new Error('not implemented');\n};\n\nTransform.prototype._write = function(chunk, encoding, cb) {\n  var ts = this._transformState;\n  ts.writecb = cb;\n  ts.writechunk = chunk;\n  ts.writeencoding = encoding;\n  if (!ts.transforming) {\n    var rs = this._readableState;\n    if (ts.needTransform ||\n        rs.needReadable ||\n        rs.length < rs.highWaterMark)\n      this._read(rs.highWaterMark);\n  }\n};\n\n// Doesn't matter what the args are here.\n// _transform does all the work.\n// That we got here means that the readable side wants more data.\nTransform.prototype._read = function(n) {\n  var ts = this._transformState;\n\n  if (ts.writechunk !== null && ts.writecb && !ts.transforming) {\n    ts.transforming = true;\n    this._transform(ts.writechunk, ts.writeencoding, ts.afterTransform);\n  } else {\n    // mark that we need a transform, so that any data that comes in\n    // will get processed, now that we've asked for it.\n    ts.needTransform = true;\n  }\n};\n\n\nfunction done(stream, er) {\n  if (er)\n    return stream.emit('error', er);\n\n  // if there's nothing in the write buffer, then that means\n  // that nothing more will ever be provided\n  var ws = stream._writableState;\n  var ts = stream._transformState;\n\n  if (ws.length)\n    throw new Error('calling transform done when ws.length != 0');\n\n  if (ts.transforming)\n    throw new Error('calling transform done when still transforming');\n\n  return stream.push(null);\n}\n\n},{\"./_stream_duplex\":19,\"core-util-is\":24,\"inherits\":10}],23:[function(require,module,exports){\n// A bit simpler than readable streams.\n// Implement an async ._write(chunk, encoding, cb), and it'll handle all\n// the drain event emission and buffering.\n\n'use strict';\n\nmodule.exports = Writable;\n\n/*<replacement>*/\nvar processNextTick = require('process-nextick-args');\n/*</replacement>*/\n\n\n/*<replacement>*/\nvar Buffer = require('buffer').Buffer;\n/*</replacement>*/\n\nWritable.WritableState = WritableState;\n\n\n/*<replacement>*/\nvar util = require('core-util-is');\nutil.inherits = require('inherits');\n/*</replacement>*/\n\n\n/*<replacement>*/\nvar internalUtil = {\n  deprecate: require('util-deprecate')\n};\n/*</replacement>*/\n\n\n\n/*<replacement>*/\nvar Stream;\n(function (){try{\n  Stream = require('st' + 'ream');\n}catch(_){}finally{\n  if (!Stream)\n    Stream = require('events').EventEmitter;\n}}())\n/*</replacement>*/\n\nvar Buffer = require('buffer').Buffer;\n\nutil.inherits(Writable, Stream);\n\nfunction nop() {}\n\nfunction WriteReq(chunk, encoding, cb) {\n  this.chunk = chunk;\n  this.encoding = encoding;\n  this.callback = cb;\n  this.next = null;\n}\n\nfunction WritableState(options, stream) {\n  var Duplex = require('./_stream_duplex');\n\n  options = options || {};\n\n  // object stream flag to indicate whether or not this stream\n  // contains buffers or objects.\n  this.objectMode = !!options.objectMode;\n\n  if (stream instanceof Duplex)\n    this.objectMode = this.objectMode || !!options.writableObjectMode;\n\n  // the point at which write() starts returning false\n  // Note: 0 is a valid value, means that we always return false if\n  // the entire buffer is not flushed immediately on write()\n  var hwm = options.highWaterMark;\n  var defaultHwm = this.objectMode ? 16 : 16 * 1024;\n  this.highWaterMark = (hwm || hwm === 0) ? hwm : defaultHwm;\n\n  // cast to ints.\n  this.highWaterMark = ~~this.highWaterMark;\n\n  this.needDrain = false;\n  // at the start of calling end()\n  this.ending = false;\n  // when end() has been called, and returned\n  this.ended = false;\n  // when 'finish' is emitted\n  this.finished = false;\n\n  // should we decode strings into buffers before passing to _write?\n  // this is here so that some node-core streams can optimize string\n  // handling at a lower level.\n  var noDecode = options.decodeStrings === false;\n  this.decodeStrings = !noDecode;\n\n  // Crypto is kind of old and crusty.  Historically, its default string\n  // encoding is 'binary' so we have to make this configurable.\n  // Everything else in the universe uses 'utf8', though.\n  this.defaultEncoding = options.defaultEncoding || 'utf8';\n\n  // not an actual buffer we keep track of, but a measurement\n  // of how much we're waiting to get pushed to some underlying\n  // socket or file.\n  this.length = 0;\n\n  // a flag to see when we're in the middle of a write.\n  this.writing = false;\n\n  // when true all writes will be buffered until .uncork() call\n  this.corked = 0;\n\n  // a flag to be able to tell if the onwrite cb is called immediately,\n  // or on a later tick.  We set this to true at first, because any\n  // actions that shouldn't happen until \"later\" should generally also\n  // not happen before the first write call.\n  this.sync = true;\n\n  // a flag to know if we're processing previously buffered items, which\n  // may call the _write() callback in the same tick, so that we don't\n  // end up in an overlapped onwrite situation.\n  this.bufferProcessing = false;\n\n  // the callback that's passed to _write(chunk,cb)\n  this.onwrite = function(er) {\n    onwrite(stream, er);\n  };\n\n  // the callback that the user supplies to write(chunk,encoding,cb)\n  this.writecb = null;\n\n  // the amount that is being written when _write is called.\n  this.writelen = 0;\n\n  this.bufferedRequest = null;\n  this.lastBufferedRequest = null;\n\n  // number of pending user-supplied write callbacks\n  // this must be 0 before 'finish' can be emitted\n  this.pendingcb = 0;\n\n  // emit prefinish if the only thing we're waiting for is _write cbs\n  // This is relevant for synchronous Transform streams\n  this.prefinished = false;\n\n  // True if the error was already emitted and should not be thrown again\n  this.errorEmitted = false;\n}\n\nWritableState.prototype.getBuffer = function writableStateGetBuffer() {\n  var current = this.bufferedRequest;\n  var out = [];\n  while (current) {\n    out.push(current);\n    current = current.next;\n  }\n  return out;\n};\n\n(function (){try {\nObject.defineProperty(WritableState.prototype, 'buffer', {\n  get: internalUtil.deprecate(function() {\n    return this.getBuffer();\n  }, '_writableState.buffer is deprecated. Use _writableState.getBuffer ' +\n     'instead.')\n});\n}catch(_){}}());\n\n\nfunction Writable(options) {\n  var Duplex = require('./_stream_duplex');\n\n  // Writable ctor is applied to Duplexes, though they're not\n  // instanceof Writable, they're instanceof Readable.\n  if (!(this instanceof Writable) && !(this instanceof Duplex))\n    return new Writable(options);\n\n  this._writableState = new WritableState(options, this);\n\n  // legacy.\n  this.writable = true;\n\n  if (options) {\n    if (typeof options.write === 'function')\n      this._write = options.write;\n\n    if (typeof options.writev === 'function')\n      this._writev = options.writev;\n  }\n\n  Stream.call(this);\n}\n\n// Otherwise people can pipe Writable streams, which is just wrong.\nWritable.prototype.pipe = function() {\n  this.emit('error', new Error('Cannot pipe. Not readable.'));\n};\n\n\nfunction writeAfterEnd(stream, cb) {\n  var er = new Error('write after end');\n  // TODO: defer error events consistently everywhere, not just the cb\n  stream.emit('error', er);\n  processNextTick(cb, er);\n}\n\n// If we get something that is not a buffer, string, null, or undefined,\n// and we're not in objectMode, then that's an error.\n// Otherwise stream chunks are all considered to be of length=1, and the\n// watermarks determine how many objects to keep in the buffer, rather than\n// how many bytes or characters.\nfunction validChunk(stream, state, chunk, cb) {\n  var valid = true;\n\n  if (!(Buffer.isBuffer(chunk)) &&\n      typeof chunk !== 'string' &&\n      chunk !== null &&\n      chunk !== undefined &&\n      !state.objectMode) {\n    var er = new TypeError('Invalid non-string/buffer chunk');\n    stream.emit('error', er);\n    processNextTick(cb, er);\n    valid = false;\n  }\n  return valid;\n}\n\nWritable.prototype.write = function(chunk, encoding, cb) {\n  var state = this._writableState;\n  var ret = false;\n\n  if (typeof encoding === 'function') {\n    cb = encoding;\n    encoding = null;\n  }\n\n  if (Buffer.isBuffer(chunk))\n    encoding = 'buffer';\n  else if (!encoding)\n    encoding = state.defaultEncoding;\n\n  if (typeof cb !== 'function')\n    cb = nop;\n\n  if (state.ended)\n    writeAfterEnd(this, cb);\n  else if (validChunk(this, state, chunk, cb)) {\n    state.pendingcb++;\n    ret = writeOrBuffer(this, state, chunk, encoding, cb);\n  }\n\n  return ret;\n};\n\nWritable.prototype.cork = function() {\n  var state = this._writableState;\n\n  state.corked++;\n};\n\nWritable.prototype.uncork = function() {\n  var state = this._writableState;\n\n  if (state.corked) {\n    state.corked--;\n\n    if (!state.writing &&\n        !state.corked &&\n        !state.finished &&\n        !state.bufferProcessing &&\n        state.bufferedRequest)\n      clearBuffer(this, state);\n  }\n};\n\nWritable.prototype.setDefaultEncoding = function setDefaultEncoding(encoding) {\n  // node::ParseEncoding() requires lower case.\n  if (typeof encoding === 'string')\n    encoding = encoding.toLowerCase();\n  if (!(['hex', 'utf8', 'utf-8', 'ascii', 'binary', 'base64',\n'ucs2', 'ucs-2','utf16le', 'utf-16le', 'raw']\n.indexOf((encoding + '').toLowerCase()) > -1))\n    throw new TypeError('Unknown encoding: ' + encoding);\n  this._writableState.defaultEncoding = encoding;\n};\n\nfunction decodeChunk(state, chunk, encoding) {\n  if (!state.objectMode &&\n      state.decodeStrings !== false &&\n      typeof chunk === 'string') {\n    chunk = new Buffer(chunk, encoding);\n  }\n  return chunk;\n}\n\n// if we're already writing something, then just put this\n// in the queue, and wait our turn.  Otherwise, call _write\n// If we return false, then we need a drain event, so set that flag.\nfunction writeOrBuffer(stream, state, chunk, encoding, cb) {\n  chunk = decodeChunk(state, chunk, encoding);\n\n  if (Buffer.isBuffer(chunk))\n    encoding = 'buffer';\n  var len = state.objectMode ? 1 : chunk.length;\n\n  state.length += len;\n\n  var ret = state.length < state.highWaterMark;\n  // we must ensure that previous needDrain will not be reset to false.\n  if (!ret)\n    state.needDrain = true;\n\n  if (state.writing || state.corked) {\n    var last = state.lastBufferedRequest;\n    state.lastBufferedRequest = new WriteReq(chunk, encoding, cb);\n    if (last) {\n      last.next = state.lastBufferedRequest;\n    } else {\n      state.bufferedRequest = state.lastBufferedRequest;\n    }\n  } else {\n    doWrite(stream, state, false, len, chunk, encoding, cb);\n  }\n\n  return ret;\n}\n\nfunction doWrite(stream, state, writev, len, chunk, encoding, cb) {\n  state.writelen = len;\n  state.writecb = cb;\n  state.writing = true;\n  state.sync = true;\n  if (writev)\n    stream._writev(chunk, state.onwrite);\n  else\n    stream._write(chunk, encoding, state.onwrite);\n  state.sync = false;\n}\n\nfunction onwriteError(stream, state, sync, er, cb) {\n  --state.pendingcb;\n  if (sync)\n    processNextTick(cb, er);\n  else\n    cb(er);\n\n  stream._writableState.errorEmitted = true;\n  stream.emit('error', er);\n}\n\nfunction onwriteStateUpdate(state) {\n  state.writing = false;\n  state.writecb = null;\n  state.length -= state.writelen;\n  state.writelen = 0;\n}\n\nfunction onwrite(stream, er) {\n  var state = stream._writableState;\n  var sync = state.sync;\n  var cb = state.writecb;\n\n  onwriteStateUpdate(state);\n\n  if (er)\n    onwriteError(stream, state, sync, er, cb);\n  else {\n    // Check if we're actually ready to finish, but don't emit yet\n    var finished = needFinish(state);\n\n    if (!finished &&\n        !state.corked &&\n        !state.bufferProcessing &&\n        state.bufferedRequest) {\n      clearBuffer(stream, state);\n    }\n\n    if (sync) {\n      processNextTick(afterWrite, stream, state, finished, cb);\n    } else {\n      afterWrite(stream, state, finished, cb);\n    }\n  }\n}\n\nfunction afterWrite(stream, state, finished, cb) {\n  if (!finished)\n    onwriteDrain(stream, state);\n  state.pendingcb--;\n  cb();\n  finishMaybe(stream, state);\n}\n\n// Must force callback to be called on nextTick, so that we don't\n// emit 'drain' before the write() consumer gets the 'false' return\n// value, and has a chance to attach a 'drain' listener.\nfunction onwriteDrain(stream, state) {\n  if (state.length === 0 && state.needDrain) {\n    state.needDrain = false;\n    stream.emit('drain');\n  }\n}\n\n\n// if there's something in the buffer waiting, then process it\nfunction clearBuffer(stream, state) {\n  state.bufferProcessing = true;\n  var entry = state.bufferedRequest;\n\n  if (stream._writev && entry && entry.next) {\n    // Fast case, write everything using _writev()\n    var buffer = [];\n    var cbs = [];\n    while (entry) {\n      cbs.push(entry.callback);\n      buffer.push(entry);\n      entry = entry.next;\n    }\n\n    // count the one we are adding, as well.\n    // TODO(isaacs) clean this up\n    state.pendingcb++;\n    state.lastBufferedRequest = null;\n    doWrite(stream, state, true, state.length, buffer, '', function(err) {\n      for (var i = 0; i < cbs.length; i++) {\n        state.pendingcb--;\n        cbs[i](err);\n      }\n    });\n\n    // Clear buffer\n  } else {\n    // Slow case, write chunks one-by-one\n    while (entry) {\n      var chunk = entry.chunk;\n      var encoding = entry.encoding;\n      var cb = entry.callback;\n      var len = state.objectMode ? 1 : chunk.length;\n\n      doWrite(stream, state, false, len, chunk, encoding, cb);\n      entry = entry.next;\n      // if we didn't call the onwrite immediately, then\n      // it means that we need to wait until it does.\n      // also, that means that the chunk and cb are currently\n      // being processed, so move the buffer counter past them.\n      if (state.writing) {\n        break;\n      }\n    }\n\n    if (entry === null)\n      state.lastBufferedRequest = null;\n  }\n  state.bufferedRequest = entry;\n  state.bufferProcessing = false;\n}\n\nWritable.prototype._write = function(chunk, encoding, cb) {\n  cb(new Error('not implemented'));\n};\n\nWritable.prototype._writev = null;\n\nWritable.prototype.end = function(chunk, encoding, cb) {\n  var state = this._writableState;\n\n  if (typeof chunk === 'function') {\n    cb = chunk;\n    chunk = null;\n    encoding = null;\n  } else if (typeof encoding === 'function') {\n    cb = encoding;\n    encoding = null;\n  }\n\n  if (chunk !== null && chunk !== undefined)\n    this.write(chunk, encoding);\n\n  // .end() fully uncorks\n  if (state.corked) {\n    state.corked = 1;\n    this.uncork();\n  }\n\n  // ignore unnecessary end() calls.\n  if (!state.ending && !state.finished)\n    endWritable(this, state, cb);\n};\n\n\nfunction needFinish(state) {\n  return (state.ending &&\n          state.length === 0 &&\n          state.bufferedRequest === null &&\n          !state.finished &&\n          !state.writing);\n}\n\nfunction prefinish(stream, state) {\n  if (!state.prefinished) {\n    state.prefinished = true;\n    stream.emit('prefinish');\n  }\n}\n\nfunction finishMaybe(stream, state) {\n  var need = needFinish(state);\n  if (need) {\n    if (state.pendingcb === 0) {\n      prefinish(stream, state);\n      state.finished = true;\n      stream.emit('finish');\n    } else {\n      prefinish(stream, state);\n    }\n  }\n  return need;\n}\n\nfunction endWritable(stream, state, cb) {\n  state.ending = true;\n  finishMaybe(stream, state);\n  if (cb) {\n    if (state.finished)\n      processNextTick(cb);\n    else\n      stream.once('finish', cb);\n  }\n  state.ended = true;\n}\n\n},{\"./_stream_duplex\":19,\"buffer\":4,\"core-util-is\":24,\"events\":8,\"inherits\":10,\"process-nextick-args\":25,\"util-deprecate\":26}],24:[function(require,module,exports){\n(function (Buffer){\n// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n// NOTE: These type checking functions intentionally don't use `instanceof`\n// because it is fragile and can be easily faked with `Object.create()`.\n\nfunction isArray(arg) {\n  if (Array.isArray) {\n    return Array.isArray(arg);\n  }\n  return objectToString(arg) === '[object Array]';\n}\nexports.isArray = isArray;\n\nfunction isBoolean(arg) {\n  return typeof arg === 'boolean';\n}\nexports.isBoolean = isBoolean;\n\nfunction isNull(arg) {\n  return arg === null;\n}\nexports.isNull = isNull;\n\nfunction isNullOrUndefined(arg) {\n  return arg == null;\n}\nexports.isNullOrUndefined = isNullOrUndefined;\n\nfunction isNumber(arg) {\n  return typeof arg === 'number';\n}\nexports.isNumber = isNumber;\n\nfunction isString(arg) {\n  return typeof arg === 'string';\n}\nexports.isString = isString;\n\nfunction isSymbol(arg) {\n  return typeof arg === 'symbol';\n}\nexports.isSymbol = isSymbol;\n\nfunction isUndefined(arg) {\n  return arg === void 0;\n}\nexports.isUndefined = isUndefined;\n\nfunction isRegExp(re) {\n  return objectToString(re) === '[object RegExp]';\n}\nexports.isRegExp = isRegExp;\n\nfunction isObject(arg) {\n  return typeof arg === 'object' && arg !== null;\n}\nexports.isObject = isObject;\n\nfunction isDate(d) {\n  return objectToString(d) === '[object Date]';\n}\nexports.isDate = isDate;\n\nfunction isError(e) {\n  return (objectToString(e) === '[object Error]' || e instanceof Error);\n}\nexports.isError = isError;\n\nfunction isFunction(arg) {\n  return typeof arg === 'function';\n}\nexports.isFunction = isFunction;\n\nfunction isPrimitive(arg) {\n  return arg === null ||\n         typeof arg === 'boolean' ||\n         typeof arg === 'number' ||\n         typeof arg === 'string' ||\n         typeof arg === 'symbol' ||  // ES6 symbol\n         typeof arg === 'undefined';\n}\nexports.isPrimitive = isPrimitive;\n\nexports.isBuffer = Buffer.isBuffer;\n\nfunction objectToString(o) {\n  return Object.prototype.toString.call(o);\n}\n\n}).call(this,{\"isBuffer\":require(\"../../../../insert-module-globals/node_modules/is-buffer/index.js\")})\n\n},{\"../../../../insert-module-globals/node_modules/is-buffer/index.js\":11}],25:[function(require,module,exports){\n(function (process){\n'use strict';\n\nif (!process.version ||\n    process.version.indexOf('v0.') === 0 ||\n    process.version.indexOf('v1.') === 0 && process.version.indexOf('v1.8.') !== 0) {\n  module.exports = nextTick;\n} else {\n  module.exports = process.nextTick;\n}\n\nfunction nextTick(fn) {\n  var args = new Array(arguments.length - 1);\n  var i = 0;\n  while (i < args.length) {\n    args[i++] = arguments[i];\n  }\n  process.nextTick(function afterTick() {\n    fn.apply(null, args);\n  });\n}\n\n}).call(this,require('_process'))\n\n},{\"_process\":13}],26:[function(require,module,exports){\n(function (global){\n\n/**\n * Module exports.\n */\n\nmodule.exports = deprecate;\n\n/**\n * Mark that a method should not be used.\n * Returns a modified function which warns once by default.\n *\n * If `localStorage.noDeprecation = true` is set, then it is a no-op.\n *\n * If `localStorage.throwDeprecation = true` is set, then deprecated functions\n * will throw an Error when invoked.\n *\n * If `localStorage.traceDeprecation = true` is set, then deprecated functions\n * will invoke `console.trace()` instead of `console.error()`.\n *\n * @param {Function} fn - the function to deprecate\n * @param {String} msg - the string to print to the console when `fn` is invoked\n * @returns {Function} a new \"deprecated\" version of `fn`\n * @api public\n */\n\nfunction deprecate (fn, msg) {\n  if (config('noDeprecation')) {\n    return fn;\n  }\n\n  var warned = false;\n  function deprecated() {\n    if (!warned) {\n      if (config('throwDeprecation')) {\n        throw new Error(msg);\n      } else if (config('traceDeprecation')) {\n        console.trace(msg);\n      } else {\n        console.warn(msg);\n      }\n      warned = true;\n    }\n    return fn.apply(this, arguments);\n  }\n\n  return deprecated;\n}\n\n/**\n * Checks `localStorage` for boolean values for the given `name`.\n *\n * @param {String} name\n * @returns {Boolean}\n * @api private\n */\n\nfunction config (name) {\n  // accessing global.localStorage can trigger a DOMException in sandboxed iframes\n  try {\n    if (!global.localStorage) return false;\n  } catch (_) {\n    return false;\n  }\n  var val = global.localStorage[name];\n  if (null == val) return false;\n  return String(val).toLowerCase() === 'true';\n}\n\n}).call(this,typeof global !== \"undefined\" ? global : typeof self !== \"undefined\" ? self : typeof window !== \"undefined\" ? window : {})\n\n},{}],27:[function(require,module,exports){\nmodule.exports = require(\"./lib/_stream_passthrough.js\")\n\n},{\"./lib/_stream_passthrough.js\":20}],28:[function(require,module,exports){\nvar Stream = (function (){\n  try {\n    return require('st' + 'ream'); // hack to fix a circular dependency issue when used with browserify\n  } catch(_){}\n}());\nexports = module.exports = require('./lib/_stream_readable.js');\nexports.Stream = Stream || exports;\nexports.Readable = exports;\nexports.Writable = require('./lib/_stream_writable.js');\nexports.Duplex = require('./lib/_stream_duplex.js');\nexports.Transform = require('./lib/_stream_transform.js');\nexports.PassThrough = require('./lib/_stream_passthrough.js');\n\n},{\"./lib/_stream_duplex.js\":19,\"./lib/_stream_passthrough.js\":20,\"./lib/_stream_readable.js\":21,\"./lib/_stream_transform.js\":22,\"./lib/_stream_writable.js\":23}],29:[function(require,module,exports){\nmodule.exports = require(\"./lib/_stream_transform.js\")\n\n},{\"./lib/_stream_transform.js\":22}],30:[function(require,module,exports){\nmodule.exports = require(\"./lib/_stream_writable.js\")\n\n},{\"./lib/_stream_writable.js\":23}],31:[function(require,module,exports){\n// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\nmodule.exports = Stream;\n\nvar EE = require('events').EventEmitter;\nvar inherits = require('inherits');\n\ninherits(Stream, EE);\nStream.Readable = require('readable-stream/readable.js');\nStream.Writable = require('readable-stream/writable.js');\nStream.Duplex = require('readable-stream/duplex.js');\nStream.Transform = require('readable-stream/transform.js');\nStream.PassThrough = require('readable-stream/passthrough.js');\n\n// Backwards-compat with node 0.4.x\nStream.Stream = Stream;\n\n\n\n// old-style streams.  Note that the pipe method (the only relevant\n// part of this class) is overridden in the Readable class.\n\nfunction Stream() {\n  EE.call(this);\n}\n\nStream.prototype.pipe = function(dest, options) {\n  var source = this;\n\n  function ondata(chunk) {\n    if (dest.writable) {\n      if (false === dest.write(chunk) && source.pause) {\n        source.pause();\n      }\n    }\n  }\n\n  source.on('data', ondata);\n\n  function ondrain() {\n    if (source.readable && source.resume) {\n      source.resume();\n    }\n  }\n\n  dest.on('drain', ondrain);\n\n  // If the 'end' option is not supplied, dest.end() will be called when\n  // source gets the 'end' or 'close' events.  Only dest.end() once.\n  if (!dest._isStdio && (!options || options.end !== false)) {\n    source.on('end', onend);\n    source.on('close', onclose);\n  }\n\n  var didOnEnd = false;\n  function onend() {\n    if (didOnEnd) return;\n    didOnEnd = true;\n\n    dest.end();\n  }\n\n\n  function onclose() {\n    if (didOnEnd) return;\n    didOnEnd = true;\n\n    if (typeof dest.destroy === 'function') dest.destroy();\n  }\n\n  // don't leave dangling pipes when there are errors.\n  function onerror(er) {\n    cleanup();\n    if (EE.listenerCount(this, 'error') === 0) {\n      throw er; // Unhandled stream error in pipe.\n    }\n  }\n\n  source.on('error', onerror);\n  dest.on('error', onerror);\n\n  // remove all the event listeners that were added.\n  function cleanup() {\n    source.removeListener('data', ondata);\n    dest.removeListener('drain', ondrain);\n\n    source.removeListener('end', onend);\n    source.removeListener('close', onclose);\n\n    source.removeListener('error', onerror);\n    dest.removeListener('error', onerror);\n\n    source.removeListener('end', cleanup);\n    source.removeListener('close', cleanup);\n\n    dest.removeListener('close', cleanup);\n  }\n\n  source.on('end', cleanup);\n  source.on('close', cleanup);\n\n  dest.on('close', cleanup);\n\n  dest.emit('pipe', source);\n\n  // Allow for unix-like usage: A.pipe(B).pipe(C)\n  return dest;\n};\n\n},{\"events\":8,\"inherits\":10,\"readable-stream/duplex.js\":18,\"readable-stream/passthrough.js\":27,\"readable-stream/readable.js\":28,\"readable-stream/transform.js\":29,\"readable-stream/writable.js\":30}],32:[function(require,module,exports){\nvar ClientRequest = require('./lib/request')\nvar extend = require('xtend')\nvar statusCodes = require('builtin-status-codes')\nvar url = require('url')\n\nvar http = exports\n\nhttp.request = function (opts, cb) {\n\tif (typeof opts === 'string')\n\t\topts = url.parse(opts)\n\telse\n\t\topts = extend(opts)\n\n\tvar protocol = opts.protocol || ''\n\tvar host = opts.hostname || opts.host\n\tvar port = opts.port\n\tvar path = opts.path || '/'\n\n\t// Necessary for IPv6 addresses\n\tif (host && host.indexOf(':') !== -1)\n\t\thost = '[' + host + ']'\n\n\t// This may be a relative url. The browser should always be able to interpret it correctly.\n\topts.url = (host ? (protocol + '//' + host) : '') + (port ? ':' + port : '') + path\n\topts.method = (opts.method || 'GET').toUpperCase()\n\topts.headers = opts.headers || {}\n\n\t// Also valid opts.auth, opts.mode\n\n\tvar req = new ClientRequest(opts)\n\tif (cb)\n\t\treq.on('response', cb)\n\treturn req\n}\n\nhttp.get = function get (opts, cb) {\n\tvar req = http.request(opts, cb)\n\treq.end()\n\treturn req\n}\n\nhttp.Agent = function () {}\nhttp.Agent.defaultMaxSockets = 4\n\nhttp.STATUS_CODES = statusCodes\n\nhttp.METHODS = [\n\t'CHECKOUT',\n\t'CONNECT',\n\t'COPY',\n\t'DELETE',\n\t'GET',\n\t'HEAD',\n\t'LOCK',\n\t'M-SEARCH',\n\t'MERGE',\n\t'MKACTIVITY',\n\t'MKCOL',\n\t'MOVE',\n\t'NOTIFY',\n\t'OPTIONS',\n\t'PATCH',\n\t'POST',\n\t'PROPFIND',\n\t'PROPPATCH',\n\t'PURGE',\n\t'PUT',\n\t'REPORT',\n\t'SEARCH',\n\t'SUBSCRIBE',\n\t'TRACE',\n\t'UNLOCK',\n\t'UNSUBSCRIBE'\n]\n},{\"./lib/request\":34,\"builtin-status-codes\":36,\"url\":38,\"xtend\":40}],33:[function(require,module,exports){\n(function (global){\nexports.fetch = isFunction(global.fetch) && isFunction(global.ReadableByteStream)\n\nexports.blobConstructor = false\ntry {\n\tnew Blob([new ArrayBuffer(1)])\n\texports.blobConstructor = true\n} catch (e) {}\n\nvar xhr = new global.XMLHttpRequest()\n// If location.host is empty, e.g. if this page/worker was loaded\n// from a Blob, then use example.com to avoid an error\nxhr.open('GET', global.location.host ? '/' : 'https://example.com')\n\nfunction checkTypeSupport (type) {\n\ttry {\n\t\txhr.responseType = type\n\t\treturn xhr.responseType === type\n\t} catch (e) {}\n\treturn false\n}\n\n// For some strange reason, Safari 7.0 reports typeof global.ArrayBuffer === 'object'.\n// Safari 7.1 appears to have fixed this bug.\nvar haveArrayBuffer = typeof global.ArrayBuffer !== 'undefined'\nvar haveSlice = haveArrayBuffer && isFunction(global.ArrayBuffer.prototype.slice)\n\nexports.arraybuffer = haveArrayBuffer && checkTypeSupport('arraybuffer')\n// These next two tests unavoidably show warnings in Chrome. Since fetch will always\n// be used if it's available, just return false for these to avoid the warnings.\nexports.msstream = !exports.fetch && haveSlice && checkTypeSupport('ms-stream')\nexports.mozchunkedarraybuffer = !exports.fetch && haveArrayBuffer &&\n\tcheckTypeSupport('moz-chunked-arraybuffer')\nexports.overrideMimeType = isFunction(xhr.overrideMimeType)\nexports.vbArray = isFunction(global.VBArray)\n\nfunction isFunction (value) {\n  return typeof value === 'function'\n}\n\nxhr = null // Help gc\n\n}).call(this,typeof global !== \"undefined\" ? global : typeof self !== \"undefined\" ? self : typeof window !== \"undefined\" ? window : {})\n\n},{}],34:[function(require,module,exports){\n(function (process,global,Buffer){\n// var Base64 = require('Base64')\nvar capability = require('./capability')\nvar inherits = require('inherits')\nvar response = require('./response')\nvar stream = require('stream')\n\nvar IncomingMessage = response.IncomingMessage\nvar rStates = response.readyStates\n\nfunction decideMode (preferBinary) {\n\tif (capability.fetch) {\n\t\treturn 'fetch'\n\t} else if (capability.mozchunkedarraybuffer) {\n\t\treturn 'moz-chunked-arraybuffer'\n\t} else if (capability.msstream) {\n\t\treturn 'ms-stream'\n\t} else if (capability.arraybuffer && preferBinary) {\n\t\treturn 'arraybuffer'\n\t} else if (capability.vbArray && preferBinary) {\n\t\treturn 'text:vbarray'\n\t} else {\n\t\treturn 'text'\n\t}\n}\n\nvar ClientRequest = module.exports = function (opts) {\n\tvar self = this\n\tstream.Writable.call(self)\n\n\tself._opts = opts\n\tself._body = []\n\tself._headers = {}\n\tif (opts.auth)\n\t\tself.setHeader('Authorization', 'Basic ' + new Buffer(opts.auth).toString('base64'))\n\tObject.keys(opts.headers).forEach(function (name) {\n\t\tself.setHeader(name, opts.headers[name])\n\t})\n\n\tvar preferBinary\n\tif (opts.mode === 'prefer-streaming') {\n\t\t// If streaming is a high priority but binary compatibility and\n\t\t// the accuracy of the 'content-type' header aren't\n\t\tpreferBinary = false\n\t} else if (opts.mode === 'allow-wrong-content-type') {\n\t\t// If streaming is more important than preserving the 'content-type' header\n\t\tpreferBinary = !capability.overrideMimeType\n\t} else if (!opts.mode || opts.mode === 'default' || opts.mode === 'prefer-fast') {\n\t\t// Use binary if text streaming may corrupt data or the content-type header, or for speed\n\t\tpreferBinary = true\n\t} else {\n\t\tthrow new Error('Invalid value for opts.mode')\n\t}\n\tself._mode = decideMode(preferBinary)\n\n\tself.on('finish', function () {\n\t\tself._onFinish()\n\t})\n}\n\ninherits(ClientRequest, stream.Writable)\n\nClientRequest.prototype.setHeader = function (name, value) {\n\tvar self = this\n\tvar lowerName = name.toLowerCase()\n\t// This check is not necessary, but it prevents warnings from browsers about setting unsafe\n\t// headers. To be honest I'm not entirely sure hiding these warnings is a good thing, but\n\t// http-browserify did it, so I will too.\n\tif (unsafeHeaders.indexOf(lowerName) !== -1)\n\t\treturn\n\n\tself._headers[lowerName] = {\n\t\tname: name,\n\t\tvalue: value\n\t}\n}\n\nClientRequest.prototype.getHeader = function (name) {\n\tvar self = this\n\treturn self._headers[name.toLowerCase()].value\n}\n\nClientRequest.prototype.removeHeader = function (name) {\n\tvar self = this\n\tdelete self._headers[name.toLowerCase()]\n}\n\nClientRequest.prototype._onFinish = function () {\n\tvar self = this\n\n\tif (self._destroyed)\n\t\treturn\n\tvar opts = self._opts\n\n\tvar headersObj = self._headers\n\tvar body\n\tif (opts.method === 'POST' || opts.method === 'PUT' || opts.method === 'PATCH') {\n\t\tif (capability.blobConstructor) {\n\t\t\tbody = new global.Blob(self._body.map(function (buffer) {\n\t\t\t\treturn buffer.toArrayBuffer()\n\t\t\t}), {\n\t\t\t\ttype: (headersObj['content-type'] || {}).value || ''\n\t\t\t})\n\t\t} else {\n\t\t\t// get utf8 string\n\t\t\tbody = Buffer.concat(self._body).toString()\n\t\t}\n\t}\n\n\tif (self._mode === 'fetch') {\n\t\tvar headers = Object.keys(headersObj).map(function (name) {\n\t\t\treturn [headersObj[name].name, headersObj[name].value]\n\t\t})\n\n\t\tglobal.fetch(self._opts.url, {\n\t\t\tmethod: self._opts.method,\n\t\t\theaders: headers,\n\t\t\tbody: body,\n\t\t\tmode: 'cors',\n\t\t\tcredentials: opts.withCredentials ? 'include' : 'same-origin'\n\t\t}).then(function (response) {\n\t\t\tself._fetchResponse = response\n\t\t\tself._connect()\n\t\t}, function (reason) {\n\t\t\tself.emit('error', reason)\n\t\t})\n\t} else {\n\t\tvar xhr = self._xhr = new global.XMLHttpRequest()\n\t\ttry {\n\t\t\txhr.open(self._opts.method, self._opts.url, true)\n\t\t} catch (err) {\n\t\t\tprocess.nextTick(function () {\n\t\t\t\tself.emit('error', err)\n\t\t\t})\n\t\t\treturn\n\t\t}\n\n\t\t// Can't set responseType on really old browsers\n\t\tif ('responseType' in xhr)\n\t\t\txhr.responseType = self._mode.split(':')[0]\n\n\t\tif ('withCredentials' in xhr)\n\t\t\txhr.withCredentials = !!opts.withCredentials\n\n\t\tif (self._mode === 'text' && 'overrideMimeType' in xhr)\n\t\t\txhr.overrideMimeType('text/plain; charset=x-user-defined')\n\n\t\tObject.keys(headersObj).forEach(function (name) {\n\t\t\txhr.setRequestHeader(headersObj[name].name, headersObj[name].value)\n\t\t})\n\n\t\tself._response = null\n\t\txhr.onreadystatechange = function () {\n\t\t\tswitch (xhr.readyState) {\n\t\t\t\tcase rStates.LOADING:\n\t\t\t\tcase rStates.DONE:\n\t\t\t\t\tself._onXHRProgress()\n\t\t\t\t\tbreak\n\t\t\t}\n\t\t}\n\t\t// Necessary for streaming in Firefox, since xhr.response is ONLY defined\n\t\t// in onprogress, not in onreadystatechange with xhr.readyState = 3\n\t\tif (self._mode === 'moz-chunked-arraybuffer') {\n\t\t\txhr.onprogress = function () {\n\t\t\t\tself._onXHRProgress()\n\t\t\t}\n\t\t}\n\n\t\txhr.onerror = function () {\n\t\t\tif (self._destroyed)\n\t\t\t\treturn\n\t\t\tself.emit('error', new Error('XHR error'))\n\t\t}\n\n\t\ttry {\n\t\t\txhr.send(body)\n\t\t} catch (err) {\n\t\t\tprocess.nextTick(function () {\n\t\t\t\tself.emit('error', err)\n\t\t\t})\n\t\t\treturn\n\t\t}\n\t}\n}\n\n/**\n * Checks if xhr.status is readable. Even though the spec says it should\n * be available in readyState 3, accessing it throws an exception in IE8\n */\nfunction statusValid (xhr) {\n\ttry {\n\t\treturn (xhr.status !== null)\n\t} catch (e) {\n\t\treturn false\n\t}\n}\n\nClientRequest.prototype._onXHRProgress = function () {\n\tvar self = this\n\n\tif (!statusValid(self._xhr) || self._destroyed)\n\t\treturn\n\n\tif (!self._response)\n\t\tself._connect()\n\n\tself._response._onXHRProgress()\n}\n\nClientRequest.prototype._connect = function () {\n\tvar self = this\n\n\tif (self._destroyed)\n\t\treturn\n\n\tself._response = new IncomingMessage(self._xhr, self._fetchResponse, self._mode)\n\tself.emit('response', self._response)\n}\n\nClientRequest.prototype._write = function (chunk, encoding, cb) {\n\tvar self = this\n\n\tself._body.push(chunk)\n\tcb()\n}\n\nClientRequest.prototype.abort = ClientRequest.prototype.destroy = function () {\n\tvar self = this\n\tself._destroyed = true\n\tif (self._response)\n\t\tself._response._destroyed = true\n\tif (self._xhr)\n\t\tself._xhr.abort()\n\t// Currently, there isn't a way to truly abort a fetch.\n\t// If you like bikeshedding, see https://github.com/whatwg/fetch/issues/27\n}\n\nClientRequest.prototype.end = function (data, encoding, cb) {\n\tvar self = this\n\tif (typeof data === 'function') {\n\t\tcb = data\n\t\tdata = undefined\n\t}\n\n\tstream.Writable.prototype.end.call(self, data, encoding, cb)\n}\n\nClientRequest.prototype.flushHeaders = function () {}\nClientRequest.prototype.setTimeout = function () {}\nClientRequest.prototype.setNoDelay = function () {}\nClientRequest.prototype.setSocketKeepAlive = function () {}\n\n// Taken from http://www.w3.org/TR/XMLHttpRequest/#the-setrequestheader%28%29-method\nvar unsafeHeaders = [\n\t'accept-charset',\n\t'accept-encoding',\n\t'access-control-request-headers',\n\t'access-control-request-method',\n\t'connection',\n\t'content-length',\n\t'cookie',\n\t'cookie2',\n\t'date',\n\t'dnt',\n\t'expect',\n\t'host',\n\t'keep-alive',\n\t'origin',\n\t'referer',\n\t'te',\n\t'trailer',\n\t'transfer-encoding',\n\t'upgrade',\n\t'user-agent',\n\t'via'\n]\n\n}).call(this,require('_process'),typeof global !== \"undefined\" ? global : typeof self !== \"undefined\" ? self : typeof window !== \"undefined\" ? window : {},require(\"buffer\").Buffer)\n\n},{\"./capability\":33,\"./response\":35,\"_process\":13,\"buffer\":4,\"inherits\":10,\"stream\":31}],35:[function(require,module,exports){\n(function (process,global,Buffer){\nvar capability = require('./capability')\nvar inherits = require('inherits')\nvar stream = require('stream')\n\nvar rStates = exports.readyStates = {\n\tUNSENT: 0,\n\tOPENED: 1,\n\tHEADERS_RECEIVED: 2,\n\tLOADING: 3,\n\tDONE: 4\n}\n\nvar IncomingMessage = exports.IncomingMessage = function (xhr, response, mode) {\n\tvar self = this\n\tstream.Readable.call(self)\n\n\tself._mode = mode\n\tself.headers = {}\n\tself.rawHeaders = []\n\tself.trailers = {}\n\tself.rawTrailers = []\n\n\t// Fake the 'close' event, but only once 'end' fires\n\tself.on('end', function () {\n\t\t// The nextTick is necessary to prevent the 'request' module from causing an infinite loop\n\t\tprocess.nextTick(function () {\n\t\t\tself.emit('close')\n\t\t})\n\t})\n\n\tif (mode === 'fetch') {\n\t\tself._fetchResponse = response\n\n\t\tself.statusCode = response.status\n\t\tself.statusMessage = response.statusText\n\t\t// backwards compatible version of for (<item> of <iterable>):\n\t\t// for (var <item>,_i,_it = <iterable>[Symbol.iterator](); <item> = (_i = _it.next()).value,!_i.done;)\n\t\tfor (var header, _i, _it = response.headers[Symbol.iterator](); header = (_i = _it.next()).value, !_i.done;) {\n\t\t\tself.headers[header[0].toLowerCase()] = header[1]\n\t\t\tself.rawHeaders.push(header[0], header[1])\n\t\t}\n\n\t\t// TODO: this doesn't respect backpressure. Once WritableStream is available, this can be fixed\n\t\tvar reader = response.body.getReader()\n\t\tfunction read () {\n\t\t\treader.read().then(function (result) {\n\t\t\t\tif (self._destroyed)\n\t\t\t\t\treturn\n\t\t\t\tif (result.done) {\n\t\t\t\t\tself.push(null)\n\t\t\t\t\treturn\n\t\t\t\t}\n\t\t\t\tself.push(new Buffer(result.value))\n\t\t\t\tread()\n\t\t\t})\n\t\t}\n\t\tread()\n\n\t} else {\n\t\tself._xhr = xhr\n\t\tself._pos = 0\n\n\t\tself.statusCode = xhr.status\n\t\tself.statusMessage = xhr.statusText\n\t\tvar headers = xhr.getAllResponseHeaders().split(/\\r?\\n/)\n\t\theaders.forEach(function (header) {\n\t\t\tvar matches = header.match(/^([^:]+):\\s*(.*)/)\n\t\t\tif (matches) {\n\t\t\t\tvar key = matches[1].toLowerCase()\n\t\t\t\tif (self.headers[key] !== undefined)\n\t\t\t\t\tself.headers[key] += ', ' + matches[2]\n\t\t\t\telse\n\t\t\t\t\tself.headers[key] = matches[2]\n\t\t\t\tself.rawHeaders.push(matches[1], matches[2])\n\t\t\t}\n\t\t})\n\n\t\tself._charset = 'x-user-defined'\n\t\tif (!capability.overrideMimeType) {\n\t\t\tvar mimeType = self.rawHeaders['mime-type']\n\t\t\tif (mimeType) {\n\t\t\t\tvar charsetMatch = mimeType.match(/;\\s*charset=([^;])(;|$)/)\n\t\t\t\tif (charsetMatch) {\n\t\t\t\t\tself._charset = charsetMatch[1].toLowerCase()\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (!self._charset)\n\t\t\t\tself._charset = 'utf-8' // best guess\n\t\t}\n\t}\n}\n\ninherits(IncomingMessage, stream.Readable)\n\nIncomingMessage.prototype._read = function () {}\n\nIncomingMessage.prototype._onXHRProgress = function () {\n\tvar self = this\n\n\tvar xhr = self._xhr\n\n\tvar response = null\n\tswitch (self._mode) {\n\t\tcase 'text:vbarray': // For IE9\n\t\t\tif (xhr.readyState !== rStates.DONE)\n\t\t\t\tbreak\n\t\t\ttry {\n\t\t\t\t// This fails in IE8\n\t\t\t\tresponse = new global.VBArray(xhr.responseBody).toArray()\n\t\t\t} catch (e) {}\n\t\t\tif (response !== null) {\n\t\t\t\tself.push(new Buffer(response))\n\t\t\t\tbreak\n\t\t\t}\n\t\t\t// Falls through in IE8\t\n\t\tcase 'text':\n\t\t\ttry { // This will fail when readyState = 3 in IE9. Switch mode and wait for readyState = 4\n\t\t\t\tresponse = xhr.responseText\n\t\t\t} catch (e) {\n\t\t\t\tself._mode = 'text:vbarray'\n\t\t\t\tbreak\n\t\t\t}\n\t\t\tif (response.length > self._pos) {\n\t\t\t\tvar newData = response.substr(self._pos)\n\t\t\t\tif (self._charset === 'x-user-defined') {\n\t\t\t\t\tvar buffer = new Buffer(newData.length)\n\t\t\t\t\tfor (var i = 0; i < newData.length; i++)\n\t\t\t\t\t\tbuffer[i] = newData.charCodeAt(i) & 0xff\n\n\t\t\t\t\tself.push(buffer)\n\t\t\t\t} else {\n\t\t\t\t\tself.push(newData, self._charset)\n\t\t\t\t}\n\t\t\t\tself._pos = response.length\n\t\t\t}\n\t\t\tbreak\n\t\tcase 'arraybuffer':\n\t\t\tif (xhr.readyState !== rStates.DONE)\n\t\t\t\tbreak\n\t\t\tresponse = xhr.response\n\t\t\tself.push(new Buffer(new Uint8Array(response)))\n\t\t\tbreak\n\t\tcase 'moz-chunked-arraybuffer': // take whole\n\t\t\tresponse = xhr.response\n\t\t\tif (xhr.readyState !== rStates.LOADING || !response)\n\t\t\t\tbreak\n\t\t\tself.push(new Buffer(new Uint8Array(response)))\n\t\t\tbreak\n\t\tcase 'ms-stream':\n\t\t\tresponse = xhr.response\n\t\t\tif (xhr.readyState !== rStates.LOADING)\n\t\t\t\tbreak\n\t\t\tvar reader = new global.MSStreamReader()\n\t\t\treader.onprogress = function () {\n\t\t\t\tif (reader.result.byteLength > self._pos) {\n\t\t\t\t\tself.push(new Buffer(new Uint8Array(reader.result.slice(self._pos))))\n\t\t\t\t\tself._pos = reader.result.byteLength\n\t\t\t\t}\n\t\t\t}\n\t\t\treader.onload = function () {\n\t\t\t\tself.push(null)\n\t\t\t}\n\t\t\t// reader.onerror = ??? // TODO: this\n\t\t\treader.readAsArrayBuffer(response)\n\t\t\tbreak\n\t}\n\n\t// The ms-stream case handles end separately in reader.onload()\n\tif (self._xhr.readyState === rStates.DONE && self._mode !== 'ms-stream') {\n\t\tself.push(null)\n\t}\n}\n\n}).call(this,require('_process'),typeof global !== \"undefined\" ? global : typeof self !== \"undefined\" ? self : typeof window !== \"undefined\" ? window : {},require(\"buffer\").Buffer)\n\n},{\"./capability\":33,\"_process\":13,\"buffer\":4,\"inherits\":10,\"stream\":31}],36:[function(require,module,exports){\nmodule.exports = {\n  \"100\": \"Continue\",\n  \"101\": \"Switching Protocols\",\n  \"102\": \"Processing\",\n  \"200\": \"OK\",\n  \"201\": \"Created\",\n  \"202\": \"Accepted\",\n  \"203\": \"Non-Authoritative Information\",\n  \"204\": \"No Content\",\n  \"205\": \"Reset Content\",\n  \"206\": \"Partial Content\",\n  \"207\": \"Multi-Status\",\n  \"300\": \"Multiple Choices\",\n  \"301\": \"Moved Permanently\",\n  \"302\": \"Moved Temporarily\",\n  \"303\": \"See Other\",\n  \"304\": \"Not Modified\",\n  \"305\": \"Use Proxy\",\n  \"307\": \"Temporary Redirect\",\n  \"308\": \"Permanent Redirect\",\n  \"400\": \"Bad Request\",\n  \"401\": \"Unauthorized\",\n  \"402\": \"Payment Required\",\n  \"403\": \"Forbidden\",\n  \"404\": \"Not Found\",\n  \"405\": \"Method Not Allowed\",\n  \"406\": \"Not Acceptable\",\n  \"407\": \"Proxy Authentication Required\",\n  \"408\": \"Request Time-out\",\n  \"409\": \"Conflict\",\n  \"410\": \"Gone\",\n  \"411\": \"Length Required\",\n  \"412\": \"Precondition Failed\",\n  \"413\": \"Request Entity Too Large\",\n  \"414\": \"Request-URI Too Large\",\n  \"415\": \"Unsupported Media Type\",\n  \"416\": \"Requested Range Not Satisfiable\",\n  \"417\": \"Expectation Failed\",\n  \"418\": \"I'm a teapot\",\n  \"422\": \"Unprocessable Entity\",\n  \"423\": \"Locked\",\n  \"424\": \"Failed Dependency\",\n  \"425\": \"Unordered Collection\",\n  \"426\": \"Upgrade Required\",\n  \"428\": \"Precondition Required\",\n  \"429\": \"Too Many Requests\",\n  \"431\": \"Request Header Fields Too Large\",\n  \"500\": \"Internal Server Error\",\n  \"501\": \"Not Implemented\",\n  \"502\": \"Bad Gateway\",\n  \"503\": \"Service Unavailable\",\n  \"504\": \"Gateway Time-out\",\n  \"505\": \"HTTP Version Not Supported\",\n  \"506\": \"Variant Also Negotiates\",\n  \"507\": \"Insufficient Storage\",\n  \"509\": \"Bandwidth Limit Exceeded\",\n  \"510\": \"Not Extended\",\n  \"511\": \"Network Authentication Required\"\n}\n\n},{}],37:[function(require,module,exports){\n// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\nvar Buffer = require('buffer').Buffer;\n\nvar isBufferEncoding = Buffer.isEncoding\n  || function(encoding) {\n       switch (encoding && encoding.toLowerCase()) {\n         case 'hex': case 'utf8': case 'utf-8': case 'ascii': case 'binary': case 'base64': case 'ucs2': case 'ucs-2': case 'utf16le': case 'utf-16le': case 'raw': return true;\n         default: return false;\n       }\n     }\n\n\nfunction assertEncoding(encoding) {\n  if (encoding && !isBufferEncoding(encoding)) {\n    throw new Error('Unknown encoding: ' + encoding);\n  }\n}\n\n// StringDecoder provides an interface for efficiently splitting a series of\n// buffers into a series of JS strings without breaking apart multi-byte\n// characters. CESU-8 is handled as part of the UTF-8 encoding.\n//\n// @TODO Handling all encodings inside a single object makes it very difficult\n// to reason about this code, so it should be split up in the future.\n// @TODO There should be a utf8-strict encoding that rejects invalid UTF-8 code\n// points as used by CESU-8.\nvar StringDecoder = exports.StringDecoder = function(encoding) {\n  this.encoding = (encoding || 'utf8').toLowerCase().replace(/[-_]/, '');\n  assertEncoding(encoding);\n  switch (this.encoding) {\n    case 'utf8':\n      // CESU-8 represents each of Surrogate Pair by 3-bytes\n      this.surrogateSize = 3;\n      break;\n    case 'ucs2':\n    case 'utf16le':\n      // UTF-16 represents each of Surrogate Pair by 2-bytes\n      this.surrogateSize = 2;\n      this.detectIncompleteChar = utf16DetectIncompleteChar;\n      break;\n    case 'base64':\n      // Base-64 stores 3 bytes in 4 chars, and pads the remainder.\n      this.surrogateSize = 3;\n      this.detectIncompleteChar = base64DetectIncompleteChar;\n      break;\n    default:\n      this.write = passThroughWrite;\n      return;\n  }\n\n  // Enough space to store all bytes of a single character. UTF-8 needs 4\n  // bytes, but CESU-8 may require up to 6 (3 bytes per surrogate).\n  this.charBuffer = new Buffer(6);\n  // Number of bytes received for the current incomplete multi-byte character.\n  this.charReceived = 0;\n  // Number of bytes expected for the current incomplete multi-byte character.\n  this.charLength = 0;\n};\n\n\n// write decodes the given buffer and returns it as JS string that is\n// guaranteed to not contain any partial multi-byte characters. Any partial\n// character found at the end of the buffer is buffered up, and will be\n// returned when calling write again with the remaining bytes.\n//\n// Note: Converting a Buffer containing an orphan surrogate to a String\n// currently works, but converting a String to a Buffer (via `new Buffer`, or\n// Buffer#write) will replace incomplete surrogates with the unicode\n// replacement character. See https://codereview.chromium.org/121173009/ .\nStringDecoder.prototype.write = function(buffer) {\n  var charStr = '';\n  // if our last write ended with an incomplete multibyte character\n  while (this.charLength) {\n    // determine how many remaining bytes this buffer has to offer for this char\n    var available = (buffer.length >= this.charLength - this.charReceived) ?\n        this.charLength - this.charReceived :\n        buffer.length;\n\n    // add the new bytes to the char buffer\n    buffer.copy(this.charBuffer, this.charReceived, 0, available);\n    this.charReceived += available;\n\n    if (this.charReceived < this.charLength) {\n      // still not enough chars in this buffer? wait for more ...\n      return '';\n    }\n\n    // remove bytes belonging to the current character from the buffer\n    buffer = buffer.slice(available, buffer.length);\n\n    // get the character that was split\n    charStr = this.charBuffer.slice(0, this.charLength).toString(this.encoding);\n\n    // CESU-8: lead surrogate (D800-DBFF) is also the incomplete character\n    var charCode = charStr.charCodeAt(charStr.length - 1);\n    if (charCode >= 0xD800 && charCode <= 0xDBFF) {\n      this.charLength += this.surrogateSize;\n      charStr = '';\n      continue;\n    }\n    this.charReceived = this.charLength = 0;\n\n    // if there are no more bytes in this buffer, just emit our char\n    if (buffer.length === 0) {\n      return charStr;\n    }\n    break;\n  }\n\n  // determine and set charLength / charReceived\n  this.detectIncompleteChar(buffer);\n\n  var end = buffer.length;\n  if (this.charLength) {\n    // buffer the incomplete character bytes we got\n    buffer.copy(this.charBuffer, 0, buffer.length - this.charReceived, end);\n    end -= this.charReceived;\n  }\n\n  charStr += buffer.toString(this.encoding, 0, end);\n\n  var end = charStr.length - 1;\n  var charCode = charStr.charCodeAt(end);\n  // CESU-8: lead surrogate (D800-DBFF) is also the incomplete character\n  if (charCode >= 0xD800 && charCode <= 0xDBFF) {\n    var size = this.surrogateSize;\n    this.charLength += size;\n    this.charReceived += size;\n    this.charBuffer.copy(this.charBuffer, size, 0, size);\n    buffer.copy(this.charBuffer, 0, 0, size);\n    return charStr.substring(0, end);\n  }\n\n  // or just emit the charStr\n  return charStr;\n};\n\n// detectIncompleteChar determines if there is an incomplete UTF-8 character at\n// the end of the given buffer. If so, it sets this.charLength to the byte\n// length that character, and sets this.charReceived to the number of bytes\n// that are available for this character.\nStringDecoder.prototype.detectIncompleteChar = function(buffer) {\n  // determine how many bytes we have to check at the end of this buffer\n  var i = (buffer.length >= 3) ? 3 : buffer.length;\n\n  // Figure out if one of the last i bytes of our buffer announces an\n  // incomplete char.\n  for (; i > 0; i--) {\n    var c = buffer[buffer.length - i];\n\n    // See http://en.wikipedia.org/wiki/UTF-8#Description\n\n    // 110XXXXX\n    if (i == 1 && c >> 5 == 0x06) {\n      this.charLength = 2;\n      break;\n    }\n\n    // 1110XXXX\n    if (i <= 2 && c >> 4 == 0x0E) {\n      this.charLength = 3;\n      break;\n    }\n\n    // 11110XXX\n    if (i <= 3 && c >> 3 == 0x1E) {\n      this.charLength = 4;\n      break;\n    }\n  }\n  this.charReceived = i;\n};\n\nStringDecoder.prototype.end = function(buffer) {\n  var res = '';\n  if (buffer && buffer.length)\n    res = this.write(buffer);\n\n  if (this.charReceived) {\n    var cr = this.charReceived;\n    var buf = this.charBuffer;\n    var enc = this.encoding;\n    res += buf.slice(0, cr).toString(enc);\n  }\n\n  return res;\n};\n\nfunction passThroughWrite(buffer) {\n  return buffer.toString(this.encoding);\n}\n\nfunction utf16DetectIncompleteChar(buffer) {\n  this.charReceived = buffer.length % 2;\n  this.charLength = this.charReceived ? 2 : 0;\n}\n\nfunction base64DetectIncompleteChar(buffer) {\n  this.charReceived = buffer.length % 3;\n  this.charLength = this.charReceived ? 3 : 0;\n}\n\n},{\"buffer\":4}],38:[function(require,module,exports){\n// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n'use strict';\n\nvar punycode = require('punycode');\nvar util = require('./util');\n\nexports.parse = urlParse;\nexports.resolve = urlResolve;\nexports.resolveObject = urlResolveObject;\nexports.format = urlFormat;\n\nexports.Url = Url;\n\nfunction Url() {\n  this.protocol = null;\n  this.slashes = null;\n  this.auth = null;\n  this.host = null;\n  this.port = null;\n  this.hostname = null;\n  this.hash = null;\n  this.search = null;\n  this.query = null;\n  this.pathname = null;\n  this.path = null;\n  this.href = null;\n}\n\n// Reference: RFC 3986, RFC 1808, RFC 2396\n\n// define these here so at least they only have to be\n// compiled once on the first module load.\nvar protocolPattern = /^([a-z0-9.+-]+:)/i,\n    portPattern = /:[0-9]*$/,\n\n    // Special case for a simple path URL\n    simplePathPattern = /^(\\/\\/?(?!\\/)[^\\?\\s]*)(\\?[^\\s]*)?$/,\n\n    // RFC 2396: characters reserved for delimiting URLs.\n    // We actually just auto-escape these.\n    delims = ['<', '>', '\"', '`', ' ', '\\r', '\\n', '\\t'],\n\n    // RFC 2396: characters not allowed for various reasons.\n    unwise = ['{', '}', '|', '\\\\', '^', '`'].concat(delims),\n\n    // Allowed by RFCs, but cause of XSS attacks.  Always escape these.\n    autoEscape = ['\\''].concat(unwise),\n    // Characters that are never ever allowed in a hostname.\n    // Note that any invalid chars are also handled, but these\n    // are the ones that are *expected* to be seen, so we fast-path\n    // them.\n    nonHostChars = ['%', '/', '?', ';', '#'].concat(autoEscape),\n    hostEndingChars = ['/', '?', '#'],\n    hostnameMaxLen = 255,\n    hostnamePartPattern = /^[+a-z0-9A-Z_-]{0,63}$/,\n    hostnamePartStart = /^([+a-z0-9A-Z_-]{0,63})(.*)$/,\n    // protocols that can allow \"unsafe\" and \"unwise\" chars.\n    unsafeProtocol = {\n      'javascript': true,\n      'javascript:': true\n    },\n    // protocols that never have a hostname.\n    hostlessProtocol = {\n      'javascript': true,\n      'javascript:': true\n    },\n    // protocols that always contain a // bit.\n    slashedProtocol = {\n      'http': true,\n      'https': true,\n      'ftp': true,\n      'gopher': true,\n      'file': true,\n      'http:': true,\n      'https:': true,\n      'ftp:': true,\n      'gopher:': true,\n      'file:': true\n    },\n    querystring = require('querystring');\n\nfunction urlParse(url, parseQueryString, slashesDenoteHost) {\n  if (url && util.isObject(url) && url instanceof Url) return url;\n\n  var u = new Url;\n  u.parse(url, parseQueryString, slashesDenoteHost);\n  return u;\n}\n\nUrl.prototype.parse = function(url, parseQueryString, slashesDenoteHost) {\n  if (!util.isString(url)) {\n    throw new TypeError(\"Parameter 'url' must be a string, not \" + typeof url);\n  }\n\n  // Copy chrome, IE, opera backslash-handling behavior.\n  // Back slashes before the query string get converted to forward slashes\n  // See: https://code.google.com/p/chromium/issues/detail?id=25916\n  var queryIndex = url.indexOf('?'),\n      splitter =\n          (queryIndex !== -1 && queryIndex < url.indexOf('#')) ? '?' : '#',\n      uSplit = url.split(splitter),\n      slashRegex = /\\\\/g;\n  uSplit[0] = uSplit[0].replace(slashRegex, '/');\n  url = uSplit.join(splitter);\n\n  var rest = url;\n\n  // trim before proceeding.\n  // This is to support parse stuff like \"  http://foo.com  \\n\"\n  rest = rest.trim();\n\n  if (!slashesDenoteHost && url.split('#').length === 1) {\n    // Try fast path regexp\n    var simplePath = simplePathPattern.exec(rest);\n    if (simplePath) {\n      this.path = rest;\n      this.href = rest;\n      this.pathname = simplePath[1];\n      if (simplePath[2]) {\n        this.search = simplePath[2];\n        if (parseQueryString) {\n          this.query = querystring.parse(this.search.substr(1));\n        } else {\n          this.query = this.search.substr(1);\n        }\n      } else if (parseQueryString) {\n        this.search = '';\n        this.query = {};\n      }\n      return this;\n    }\n  }\n\n  var proto = protocolPattern.exec(rest);\n  if (proto) {\n    proto = proto[0];\n    var lowerProto = proto.toLowerCase();\n    this.protocol = lowerProto;\n    rest = rest.substr(proto.length);\n  }\n\n  // figure out if it's got a host\n  // user@server is *always* interpreted as a hostname, and url\n  // resolution will treat //foo/bar as host=foo,path=bar because that's\n  // how the browser resolves relative URLs.\n  if (slashesDenoteHost || proto || rest.match(/^\\/\\/[^@\\/]+@[^@\\/]+/)) {\n    var slashes = rest.substr(0, 2) === '//';\n    if (slashes && !(proto && hostlessProtocol[proto])) {\n      rest = rest.substr(2);\n      this.slashes = true;\n    }\n  }\n\n  if (!hostlessProtocol[proto] &&\n      (slashes || (proto && !slashedProtocol[proto]))) {\n\n    // there's a hostname.\n    // the first instance of /, ?, ;, or # ends the host.\n    //\n    // If there is an @ in the hostname, then non-host chars *are* allowed\n    // to the left of the last @ sign, unless some host-ending character\n    // comes *before* the @-sign.\n    // URLs are obnoxious.\n    //\n    // ex:\n    // http://a@b@c/ => user:a@b host:c\n    // http://a@b?@c => user:a host:c path:/?@c\n\n    // v0.12 TODO(isaacs): This is not quite how Chrome does things.\n    // Review our test case against browsers more comprehensively.\n\n    // find the first instance of any hostEndingChars\n    var hostEnd = -1;\n    for (var i = 0; i < hostEndingChars.length; i++) {\n      var hec = rest.indexOf(hostEndingChars[i]);\n      if (hec !== -1 && (hostEnd === -1 || hec < hostEnd))\n        hostEnd = hec;\n    }\n\n    // at this point, either we have an explicit point where the\n    // auth portion cannot go past, or the last @ char is the decider.\n    var auth, atSign;\n    if (hostEnd === -1) {\n      // atSign can be anywhere.\n      atSign = rest.lastIndexOf('@');\n    } else {\n      // atSign must be in auth portion.\n      // http://a@b/c@d => host:b auth:a path:/c@d\n      atSign = rest.lastIndexOf('@', hostEnd);\n    }\n\n    // Now we have a portion which is definitely the auth.\n    // Pull that off.\n    if (atSign !== -1) {\n      auth = rest.slice(0, atSign);\n      rest = rest.slice(atSign + 1);\n      this.auth = decodeURIComponent(auth);\n    }\n\n    // the host is the remaining to the left of the first non-host char\n    hostEnd = -1;\n    for (var i = 0; i < nonHostChars.length; i++) {\n      var hec = rest.indexOf(nonHostChars[i]);\n      if (hec !== -1 && (hostEnd === -1 || hec < hostEnd))\n        hostEnd = hec;\n    }\n    // if we still have not hit it, then the entire thing is a host.\n    if (hostEnd === -1)\n      hostEnd = rest.length;\n\n    this.host = rest.slice(0, hostEnd);\n    rest = rest.slice(hostEnd);\n\n    // pull out port.\n    this.parseHost();\n\n    // we've indicated that there is a hostname,\n    // so even if it's empty, it has to be present.\n    this.hostname = this.hostname || '';\n\n    // if hostname begins with [ and ends with ]\n    // assume that it's an IPv6 address.\n    var ipv6Hostname = this.hostname[0] === '[' &&\n        this.hostname[this.hostname.length - 1] === ']';\n\n    // validate a little.\n    if (!ipv6Hostname) {\n      var hostparts = this.hostname.split(/\\./);\n      for (var i = 0, l = hostparts.length; i < l; i++) {\n        var part = hostparts[i];\n        if (!part) continue;\n        if (!part.match(hostnamePartPattern)) {\n          var newpart = '';\n          for (var j = 0, k = part.length; j < k; j++) {\n            if (part.charCodeAt(j) > 127) {\n              // we replace non-ASCII char with a temporary placeholder\n              // we need this to make sure size of hostname is not\n              // broken by replacing non-ASCII by nothing\n              newpart += 'x';\n            } else {\n              newpart += part[j];\n            }\n          }\n          // we test again with ASCII char only\n          if (!newpart.match(hostnamePartPattern)) {\n            var validParts = hostparts.slice(0, i);\n            var notHost = hostparts.slice(i + 1);\n            var bit = part.match(hostnamePartStart);\n            if (bit) {\n              validParts.push(bit[1]);\n              notHost.unshift(bit[2]);\n            }\n            if (notHost.length) {\n              rest = '/' + notHost.join('.') + rest;\n            }\n            this.hostname = validParts.join('.');\n            break;\n          }\n        }\n      }\n    }\n\n    if (this.hostname.length > hostnameMaxLen) {\n      this.hostname = '';\n    } else {\n      // hostnames are always lower case.\n      this.hostname = this.hostname.toLowerCase();\n    }\n\n    if (!ipv6Hostname) {\n      // IDNA Support: Returns a punycoded representation of \"domain\".\n      // It only converts parts of the domain name that\n      // have non-ASCII characters, i.e. it doesn't matter if\n      // you call it with a domain that already is ASCII-only.\n      this.hostname = punycode.toASCII(this.hostname);\n    }\n\n    var p = this.port ? ':' + this.port : '';\n    var h = this.hostname || '';\n    this.host = h + p;\n    this.href += this.host;\n\n    // strip [ and ] from the hostname\n    // the host field still retains them, though\n    if (ipv6Hostname) {\n      this.hostname = this.hostname.substr(1, this.hostname.length - 2);\n      if (rest[0] !== '/') {\n        rest = '/' + rest;\n      }\n    }\n  }\n\n  // now rest is set to the post-host stuff.\n  // chop off any delim chars.\n  if (!unsafeProtocol[lowerProto]) {\n\n    // First, make 100% sure that any \"autoEscape\" chars get\n    // escaped, even if encodeURIComponent doesn't think they\n    // need to be.\n    for (var i = 0, l = autoEscape.length; i < l; i++) {\n      var ae = autoEscape[i];\n      if (rest.indexOf(ae) === -1)\n        continue;\n      var esc = encodeURIComponent(ae);\n      if (esc === ae) {\n        esc = escape(ae);\n      }\n      rest = rest.split(ae).join(esc);\n    }\n  }\n\n\n  // chop off from the tail first.\n  var hash = rest.indexOf('#');\n  if (hash !== -1) {\n    // got a fragment string.\n    this.hash = rest.substr(hash);\n    rest = rest.slice(0, hash);\n  }\n  var qm = rest.indexOf('?');\n  if (qm !== -1) {\n    this.search = rest.substr(qm);\n    this.query = rest.substr(qm + 1);\n    if (parseQueryString) {\n      this.query = querystring.parse(this.query);\n    }\n    rest = rest.slice(0, qm);\n  } else if (parseQueryString) {\n    // no query string, but parseQueryString still requested\n    this.search = '';\n    this.query = {};\n  }\n  if (rest) this.pathname = rest;\n  if (slashedProtocol[lowerProto] &&\n      this.hostname && !this.pathname) {\n    this.pathname = '/';\n  }\n\n  //to support http.request\n  if (this.pathname || this.search) {\n    var p = this.pathname || '';\n    var s = this.search || '';\n    this.path = p + s;\n  }\n\n  // finally, reconstruct the href based on what has been validated.\n  this.href = this.format();\n  return this;\n};\n\n// format a parsed object into a url string\nfunction urlFormat(obj) {\n  // ensure it's an object, and not a string url.\n  // If it's an obj, this is a no-op.\n  // this way, you can call url_format() on strings\n  // to clean up potentially wonky urls.\n  if (util.isString(obj)) obj = urlParse(obj);\n  if (!(obj instanceof Url)) return Url.prototype.format.call(obj);\n  return obj.format();\n}\n\nUrl.prototype.format = function() {\n  var auth = this.auth || '';\n  if (auth) {\n    auth = encodeURIComponent(auth);\n    auth = auth.replace(/%3A/i, ':');\n    auth += '@';\n  }\n\n  var protocol = this.protocol || '',\n      pathname = this.pathname || '',\n      hash = this.hash || '',\n      host = false,\n      query = '';\n\n  if (this.host) {\n    host = auth + this.host;\n  } else if (this.hostname) {\n    host = auth + (this.hostname.indexOf(':') === -1 ?\n        this.hostname :\n        '[' + this.hostname + ']');\n    if (this.port) {\n      host += ':' + this.port;\n    }\n  }\n\n  if (this.query &&\n      util.isObject(this.query) &&\n      Object.keys(this.query).length) {\n    query = querystring.stringify(this.query);\n  }\n\n  var search = this.search || (query && ('?' + query)) || '';\n\n  if (protocol && protocol.substr(-1) !== ':') protocol += ':';\n\n  // only the slashedProtocols get the //.  Not mailto:, xmpp:, etc.\n  // unless they had them to begin with.\n  if (this.slashes ||\n      (!protocol || slashedProtocol[protocol]) && host !== false) {\n    host = '//' + (host || '');\n    if (pathname && pathname.charAt(0) !== '/') pathname = '/' + pathname;\n  } else if (!host) {\n    host = '';\n  }\n\n  if (hash && hash.charAt(0) !== '#') hash = '#' + hash;\n  if (search && search.charAt(0) !== '?') search = '?' + search;\n\n  pathname = pathname.replace(/[?#]/g, function(match) {\n    return encodeURIComponent(match);\n  });\n  search = search.replace('#', '%23');\n\n  return protocol + host + pathname + search + hash;\n};\n\nfunction urlResolve(source, relative) {\n  return urlParse(source, false, true).resolve(relative);\n}\n\nUrl.prototype.resolve = function(relative) {\n  return this.resolveObject(urlParse(relative, false, true)).format();\n};\n\nfunction urlResolveObject(source, relative) {\n  if (!source) return relative;\n  return urlParse(source, false, true).resolveObject(relative);\n}\n\nUrl.prototype.resolveObject = function(relative) {\n  if (util.isString(relative)) {\n    var rel = new Url();\n    rel.parse(relative, false, true);\n    relative = rel;\n  }\n\n  var result = new Url();\n  var tkeys = Object.keys(this);\n  for (var tk = 0; tk < tkeys.length; tk++) {\n    var tkey = tkeys[tk];\n    result[tkey] = this[tkey];\n  }\n\n  // hash is always overridden, no matter what.\n  // even href=\"\" will remove it.\n  result.hash = relative.hash;\n\n  // if the relative url is empty, then there's nothing left to do here.\n  if (relative.href === '') {\n    result.href = result.format();\n    return result;\n  }\n\n  // hrefs like //foo/bar always cut to the protocol.\n  if (relative.slashes && !relative.protocol) {\n    // take everything except the protocol from relative\n    var rkeys = Object.keys(relative);\n    for (var rk = 0; rk < rkeys.length; rk++) {\n      var rkey = rkeys[rk];\n      if (rkey !== 'protocol')\n        result[rkey] = relative[rkey];\n    }\n\n    //urlParse appends trailing / to urls like http://www.example.com\n    if (slashedProtocol[result.protocol] &&\n        result.hostname && !result.pathname) {\n      result.path = result.pathname = '/';\n    }\n\n    result.href = result.format();\n    return result;\n  }\n\n  if (relative.protocol && relative.protocol !== result.protocol) {\n    // if it's a known url protocol, then changing\n    // the protocol does weird things\n    // first, if it's not file:, then we MUST have a host,\n    // and if there was a path\n    // to begin with, then we MUST have a path.\n    // if it is file:, then the host is dropped,\n    // because that's known to be hostless.\n    // anything else is assumed to be absolute.\n    if (!slashedProtocol[relative.protocol]) {\n      var keys = Object.keys(relative);\n      for (var v = 0; v < keys.length; v++) {\n        var k = keys[v];\n        result[k] = relative[k];\n      }\n      result.href = result.format();\n      return result;\n    }\n\n    result.protocol = relative.protocol;\n    if (!relative.host && !hostlessProtocol[relative.protocol]) {\n      var relPath = (relative.pathname || '').split('/');\n      while (relPath.length && !(relative.host = relPath.shift()));\n      if (!relative.host) relative.host = '';\n      if (!relative.hostname) relative.hostname = '';\n      if (relPath[0] !== '') relPath.unshift('');\n      if (relPath.length < 2) relPath.unshift('');\n      result.pathname = relPath.join('/');\n    } else {\n      result.pathname = relative.pathname;\n    }\n    result.search = relative.search;\n    result.query = relative.query;\n    result.host = relative.host || '';\n    result.auth = relative.auth;\n    result.hostname = relative.hostname || relative.host;\n    result.port = relative.port;\n    // to support http.request\n    if (result.pathname || result.search) {\n      var p = result.pathname || '';\n      var s = result.search || '';\n      result.path = p + s;\n    }\n    result.slashes = result.slashes || relative.slashes;\n    result.href = result.format();\n    return result;\n  }\n\n  var isSourceAbs = (result.pathname && result.pathname.charAt(0) === '/'),\n      isRelAbs = (\n          relative.host ||\n          relative.pathname && relative.pathname.charAt(0) === '/'\n      ),\n      mustEndAbs = (isRelAbs || isSourceAbs ||\n                    (result.host && relative.pathname)),\n      removeAllDots = mustEndAbs,\n      srcPath = result.pathname && result.pathname.split('/') || [],\n      relPath = relative.pathname && relative.pathname.split('/') || [],\n      psychotic = result.protocol && !slashedProtocol[result.protocol];\n\n  // if the url is a non-slashed url, then relative\n  // links like ../.. should be able\n  // to crawl up to the hostname, as well.  This is strange.\n  // result.protocol has already been set by now.\n  // Later on, put the first path part into the host field.\n  if (psychotic) {\n    result.hostname = '';\n    result.port = null;\n    if (result.host) {\n      if (srcPath[0] === '') srcPath[0] = result.host;\n      else srcPath.unshift(result.host);\n    }\n    result.host = '';\n    if (relative.protocol) {\n      relative.hostname = null;\n      relative.port = null;\n      if (relative.host) {\n        if (relPath[0] === '') relPath[0] = relative.host;\n        else relPath.unshift(relative.host);\n      }\n      relative.host = null;\n    }\n    mustEndAbs = mustEndAbs && (relPath[0] === '' || srcPath[0] === '');\n  }\n\n  if (isRelAbs) {\n    // it's absolute.\n    result.host = (relative.host || relative.host === '') ?\n                  relative.host : result.host;\n    result.hostname = (relative.hostname || relative.hostname === '') ?\n                      relative.hostname : result.hostname;\n    result.search = relative.search;\n    result.query = relative.query;\n    srcPath = relPath;\n    // fall through to the dot-handling below.\n  } else if (relPath.length) {\n    // it's relative\n    // throw away the existing file, and take the new path instead.\n    if (!srcPath) srcPath = [];\n    srcPath.pop();\n    srcPath = srcPath.concat(relPath);\n    result.search = relative.search;\n    result.query = relative.query;\n  } else if (!util.isNullOrUndefined(relative.search)) {\n    // just pull out the search.\n    // like href='?foo'.\n    // Put this after the other two cases because it simplifies the booleans\n    if (psychotic) {\n      result.hostname = result.host = srcPath.shift();\n      //occationaly the auth can get stuck only in host\n      //this especially happens in cases like\n      //url.resolveObject('mailto:local1@domain1', 'local2@domain2')\n      var authInHost = result.host && result.host.indexOf('@') > 0 ?\n                       result.host.split('@') : false;\n      if (authInHost) {\n        result.auth = authInHost.shift();\n        result.host = result.hostname = authInHost.shift();\n      }\n    }\n    result.search = relative.search;\n    result.query = relative.query;\n    //to support http.request\n    if (!util.isNull(result.pathname) || !util.isNull(result.search)) {\n      result.path = (result.pathname ? result.pathname : '') +\n                    (result.search ? result.search : '');\n    }\n    result.href = result.format();\n    return result;\n  }\n\n  if (!srcPath.length) {\n    // no path at all.  easy.\n    // we've already handled the other stuff above.\n    result.pathname = null;\n    //to support http.request\n    if (result.search) {\n      result.path = '/' + result.search;\n    } else {\n      result.path = null;\n    }\n    result.href = result.format();\n    return result;\n  }\n\n  // if a url ENDs in . or .., then it must get a trailing slash.\n  // however, if it ends in anything else non-slashy,\n  // then it must NOT get a trailing slash.\n  var last = srcPath.slice(-1)[0];\n  var hasTrailingSlash = (\n      (result.host || relative.host || srcPath.length > 1) &&\n      (last === '.' || last === '..') || last === '');\n\n  // strip single dots, resolve double dots to parent dir\n  // if the path tries to go above the root, `up` ends up > 0\n  var up = 0;\n  for (var i = srcPath.length; i >= 0; i--) {\n    last = srcPath[i];\n    if (last === '.') {\n      srcPath.splice(i, 1);\n    } else if (last === '..') {\n      srcPath.splice(i, 1);\n      up++;\n    } else if (up) {\n      srcPath.splice(i, 1);\n      up--;\n    }\n  }\n\n  // if the path is allowed to go above the root, restore leading ..s\n  if (!mustEndAbs && !removeAllDots) {\n    for (; up--; up) {\n      srcPath.unshift('..');\n    }\n  }\n\n  if (mustEndAbs && srcPath[0] !== '' &&\n      (!srcPath[0] || srcPath[0].charAt(0) !== '/')) {\n    srcPath.unshift('');\n  }\n\n  if (hasTrailingSlash && (srcPath.join('/').substr(-1) !== '/')) {\n    srcPath.push('');\n  }\n\n  var isAbsolute = srcPath[0] === '' ||\n      (srcPath[0] && srcPath[0].charAt(0) === '/');\n\n  // put the host back\n  if (psychotic) {\n    result.hostname = result.host = isAbsolute ? '' :\n                                    srcPath.length ? srcPath.shift() : '';\n    //occationaly the auth can get stuck only in host\n    //this especially happens in cases like\n    //url.resolveObject('mailto:local1@domain1', 'local2@domain2')\n    var authInHost = result.host && result.host.indexOf('@') > 0 ?\n                     result.host.split('@') : false;\n    if (authInHost) {\n      result.auth = authInHost.shift();\n      result.host = result.hostname = authInHost.shift();\n    }\n  }\n\n  mustEndAbs = mustEndAbs || (result.host && srcPath.length);\n\n  if (mustEndAbs && !isAbsolute) {\n    srcPath.unshift('');\n  }\n\n  if (!srcPath.length) {\n    result.pathname = null;\n    result.path = null;\n  } else {\n    result.pathname = srcPath.join('/');\n  }\n\n  //to support request.http\n  if (!util.isNull(result.pathname) || !util.isNull(result.search)) {\n    result.path = (result.pathname ? result.pathname : '') +\n                  (result.search ? result.search : '');\n  }\n  result.auth = relative.auth || result.auth;\n  result.slashes = result.slashes || relative.slashes;\n  result.href = result.format();\n  return result;\n};\n\nUrl.prototype.parseHost = function() {\n  var host = this.host;\n  var port = portPattern.exec(host);\n  if (port) {\n    port = port[0];\n    if (port !== ':') {\n      this.port = port.substr(1);\n    }\n    host = host.substr(0, host.length - port.length);\n  }\n  if (host) this.hostname = host;\n};\n\n},{\"./util\":39,\"punycode\":14,\"querystring\":17}],39:[function(require,module,exports){\n'use strict';\n\nmodule.exports = {\n  isString: function(arg) {\n    return typeof(arg) === 'string';\n  },\n  isObject: function(arg) {\n    return typeof(arg) === 'object' && arg !== null;\n  },\n  isNull: function(arg) {\n    return arg === null;\n  },\n  isNullOrUndefined: function(arg) {\n    return arg == null;\n  }\n};\n\n},{}],40:[function(require,module,exports){\nmodule.exports = extend\n\nvar hasOwnProperty = Object.prototype.hasOwnProperty;\n\nfunction extend() {\n    var target = {}\n\n    for (var i = 0; i < arguments.length; i++) {\n        var source = arguments[i]\n\n        for (var key in source) {\n            if (hasOwnProperty.call(source, key)) {\n                target[key] = source[key]\n            }\n        }\n    }\n\n    return target\n}\n\n},{}],41:[function(require,module,exports){\n/*!\n * escape-html\n * Copyright(c) 2012-2013 TJ Holowaychuk\n * Copyright(c) 2015 Andreas Lubbe\n * Copyright(c) 2015 Tiancheng \"Timothy\" Gu\n * MIT Licensed\n */\n\n'use strict';\n\n/**\n * Module variables.\n * @private\n */\n\nvar matchHtmlRegExp = /[\"'&<>]/;\n\n/**\n * Module exports.\n * @public\n */\n\nmodule.exports = escapeHtml;\n\n/**\n * Escape special characters in the given string of html.\n *\n * @param  {string} string The string to escape for inserting into HTML\n * @return {string}\n * @public\n */\n\nfunction escapeHtml(string) {\n  var str = '' + string;\n  var match = matchHtmlRegExp.exec(str);\n\n  if (!match) {\n    return str;\n  }\n\n  var escape;\n  var html = '';\n  var index = 0;\n  var lastIndex = 0;\n\n  for (index = match.index; index < str.length; index++) {\n    switch (str.charCodeAt(index)) {\n      case 34: // \"\n        escape = '&quot;';\n        break;\n      case 38: // &\n        escape = '&amp;';\n        break;\n      case 39: // '\n        escape = '&#39;';\n        break;\n      case 60: // <\n        escape = '&lt;';\n        break;\n      case 62: // >\n        escape = '&gt;';\n        break;\n      default:\n        continue;\n    }\n\n    if (lastIndex !== index) {\n      html += str.substring(lastIndex, index);\n    }\n\n    lastIndex = index + 1;\n    html += escape;\n  }\n\n  return lastIndex !== index\n    ? html + str.substring(lastIndex, index)\n    : html;\n}\n\n},{}],42:[function(require,module,exports){\n(function (Buffer){\n;(function (sax) { // wrapper for non-node envs\n  sax.parser = function (strict, opt) { return new SAXParser(strict, opt) }\n  sax.SAXParser = SAXParser\n  sax.SAXStream = SAXStream\n  sax.createStream = createStream\n\n  // When we pass the MAX_BUFFER_LENGTH position, start checking for buffer overruns.\n  // When we check, schedule the next check for MAX_BUFFER_LENGTH - (max(buffer lengths)),\n  // since that's the earliest that a buffer overrun could occur.  This way, checks are\n  // as rare as required, but as often as necessary to ensure never crossing this bound.\n  // Furthermore, buffers are only tested at most once per write(), so passing a very\n  // large string into write() might have undesirable effects, but this is manageable by\n  // the caller, so it is assumed to be safe.  Thus, a call to write() may, in the extreme\n  // edge case, result in creating at most one complete copy of the string passed in.\n  // Set to Infinity to have unlimited buffers.\n  sax.MAX_BUFFER_LENGTH = 64 * 1024\n\n  var buffers = [\n    'comment', 'sgmlDecl', 'textNode', 'tagName', 'doctype',\n    'procInstName', 'procInstBody', 'entity', 'attribName',\n    'attribValue', 'cdata', 'script'\n  ]\n\n  sax.EVENTS = [\n    'text',\n    'processinginstruction',\n    'sgmldeclaration',\n    'doctype',\n    'comment',\n    'attribute',\n    'opentag',\n    'closetag',\n    'opencdata',\n    'cdata',\n    'closecdata',\n    'error',\n    'end',\n    'ready',\n    'script',\n    'opennamespace',\n    'closenamespace'\n  ]\n\n  function SAXParser (strict, opt) {\n    if (!(this instanceof SAXParser)) {\n      return new SAXParser(strict, opt)\n    }\n\n    var parser = this\n    clearBuffers(parser)\n    parser.q = parser.c = ''\n    parser.bufferCheckPosition = sax.MAX_BUFFER_LENGTH\n    parser.opt = opt || {}\n    parser.opt.lowercase = parser.opt.lowercase || parser.opt.lowercasetags\n    parser.looseCase = parser.opt.lowercase ? 'toLowerCase' : 'toUpperCase'\n    parser.tags = []\n    parser.closed = parser.closedRoot = parser.sawRoot = false\n    parser.tag = parser.error = null\n    parser.strict = !!strict\n    parser.noscript = !!(strict || parser.opt.noscript)\n    parser.state = S.BEGIN\n    parser.strictEntities = parser.opt.strictEntities\n    parser.ENTITIES = parser.strictEntities ? Object.create(sax.XML_ENTITIES) : Object.create(sax.ENTITIES)\n    parser.attribList = []\n\n    // namespaces form a prototype chain.\n    // it always points at the current tag,\n    // which protos to its parent tag.\n    if (parser.opt.xmlns) {\n      parser.ns = Object.create(rootNS)\n    }\n\n    // mostly just for error reporting\n    parser.trackPosition = parser.opt.position !== false\n    if (parser.trackPosition) {\n      parser.position = parser.line = parser.column = 0\n    }\n    emit(parser, 'onready')\n  }\n\n  if (!Object.create) {\n    Object.create = function (o) {\n      function F () {}\n      F.prototype = o\n      var newf = new F()\n      return newf\n    }\n  }\n\n  if (!Object.keys) {\n    Object.keys = function (o) {\n      var a = []\n      for (var i in o) if (o.hasOwnProperty(i)) a.push(i)\n      return a\n    }\n  }\n\n  function checkBufferLength (parser) {\n    var maxAllowed = Math.max(sax.MAX_BUFFER_LENGTH, 10)\n    var maxActual = 0\n    for (var i = 0, l = buffers.length; i < l; i++) {\n      var len = parser[buffers[i]].length\n      if (len > maxAllowed) {\n        // Text/cdata nodes can get big, and since they're buffered,\n        // we can get here under normal conditions.\n        // Avoid issues by emitting the text node now,\n        // so at least it won't get any bigger.\n        switch (buffers[i]) {\n          case 'textNode':\n            closeText(parser)\n            break\n\n          case 'cdata':\n            emitNode(parser, 'oncdata', parser.cdata)\n            parser.cdata = ''\n            break\n\n          case 'script':\n            emitNode(parser, 'onscript', parser.script)\n            parser.script = ''\n            break\n\n          default:\n            error(parser, 'Max buffer length exceeded: ' + buffers[i])\n        }\n      }\n      maxActual = Math.max(maxActual, len)\n    }\n    // schedule the next check for the earliest possible buffer overrun.\n    var m = sax.MAX_BUFFER_LENGTH - maxActual\n    parser.bufferCheckPosition = m + parser.position\n  }\n\n  function clearBuffers (parser) {\n    for (var i = 0, l = buffers.length; i < l; i++) {\n      parser[buffers[i]] = ''\n    }\n  }\n\n  function flushBuffers (parser) {\n    closeText(parser)\n    if (parser.cdata !== '') {\n      emitNode(parser, 'oncdata', parser.cdata)\n      parser.cdata = ''\n    }\n    if (parser.script !== '') {\n      emitNode(parser, 'onscript', parser.script)\n      parser.script = ''\n    }\n  }\n\n  SAXParser.prototype = {\n    end: function () { end(this) },\n    write: write,\n    resume: function () { this.error = null; return this },\n    close: function () { return this.write(null) },\n    flush: function () { flushBuffers(this) }\n  }\n\n  var Stream\n  try {\n    Stream = require('stream').Stream\n  } catch (ex) {\n    Stream = function () {}\n  }\n\n  var streamWraps = sax.EVENTS.filter(function (ev) {\n    return ev !== 'error' && ev !== 'end'\n  })\n\n  function createStream (strict, opt) {\n    return new SAXStream(strict, opt)\n  }\n\n  function SAXStream (strict, opt) {\n    if (!(this instanceof SAXStream)) {\n      return new SAXStream(strict, opt)\n    }\n\n    Stream.apply(this)\n\n    this._parser = new SAXParser(strict, opt)\n    this.writable = true\n    this.readable = true\n\n    var me = this\n\n    this._parser.onend = function () {\n      me.emit('end')\n    }\n\n    this._parser.onerror = function (er) {\n      me.emit('error', er)\n\n      // if didn't throw, then means error was handled.\n      // go ahead and clear error, so we can write again.\n      me._parser.error = null\n    }\n\n    this._decoder = null\n\n    streamWraps.forEach(function (ev) {\n      Object.defineProperty(me, 'on' + ev, {\n        get: function () {\n          return me._parser['on' + ev]\n        },\n        set: function (h) {\n          if (!h) {\n            me.removeAllListeners(ev)\n            me._parser['on' + ev] = h\n            return h\n          }\n          me.on(ev, h)\n        },\n        enumerable: true,\n        configurable: false\n      })\n    })\n  }\n\n  SAXStream.prototype = Object.create(Stream.prototype, {\n    constructor: {\n      value: SAXStream\n    }\n  })\n\n  SAXStream.prototype.write = function (data) {\n    if (typeof Buffer === 'function' &&\n      typeof Buffer.isBuffer === 'function' &&\n      Buffer.isBuffer(data)) {\n      if (!this._decoder) {\n        var SD = require('string_decoder').StringDecoder\n        this._decoder = new SD('utf8')\n      }\n      data = this._decoder.write(data)\n    }\n\n    this._parser.write(data.toString())\n    this.emit('data', data)\n    return true\n  }\n\n  SAXStream.prototype.end = function (chunk) {\n    if (chunk && chunk.length) {\n      this.write(chunk)\n    }\n    this._parser.end()\n    return true\n  }\n\n  SAXStream.prototype.on = function (ev, handler) {\n    var me = this\n    if (!me._parser['on' + ev] && streamWraps.indexOf(ev) !== -1) {\n      me._parser['on' + ev] = function () {\n        var args = arguments.length === 1 ? [arguments[0]] : Array.apply(null, arguments)\n        args.splice(0, 0, ev)\n        me.emit.apply(me, args)\n      }\n    }\n\n    return Stream.prototype.on.call(me, ev, handler)\n  }\n\n  // character classes and tokens\n  var whitespace = '\\r\\n\\t '\n\n  // this really needs to be replaced with character classes.\n  // XML allows all manner of ridiculous numbers and digits.\n  var number = '0124356789'\n  var letter = 'abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ'\n\n  // (Letter | \"_\" | \":\")\n  var quote = '\\'\"'\n  var attribEnd = whitespace + '>'\n  var CDATA = '[CDATA['\n  var DOCTYPE = 'DOCTYPE'\n  var XML_NAMESPACE = 'http://www.w3.org/XML/1998/namespace'\n  var XMLNS_NAMESPACE = 'http://www.w3.org/2000/xmlns/'\n  var rootNS = { xml: XML_NAMESPACE, xmlns: XMLNS_NAMESPACE }\n\n  // turn all the string character sets into character class objects.\n  whitespace = charClass(whitespace)\n  number = charClass(number)\n  letter = charClass(letter)\n\n  // http://www.w3.org/TR/REC-xml/#NT-NameStartChar\n  // This implementation works on strings, a single character at a time\n  // as such, it cannot ever support astral-plane characters (10000-EFFFF)\n  // without a significant breaking change to either this  parser, or the\n  // JavaScript language.  Implementation of an emoji-capable xml parser\n  // is left as an exercise for the reader.\n  var nameStart = /[:_A-Za-z\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD]/\n\n  var nameBody = /[:_A-Za-z\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD\\u00B7\\u0300-\\u036F\\u203F-\\u2040\\.\\d-]/\n\n  var entityStart = /[#:_A-Za-z\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD]/\n  var entityBody = /[#:_A-Za-z\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD\\u00B7\\u0300-\\u036F\\u203F-\\u2040\\.\\d-]/\n\n  quote = charClass(quote)\n  attribEnd = charClass(attribEnd)\n\n  function charClass (str) {\n    return str.split('').reduce(function (s, c) {\n      s[c] = true\n      return s\n    }, {})\n  }\n\n  function isRegExp (c) {\n    return Object.prototype.toString.call(c) === '[object RegExp]'\n  }\n\n  function is (charclass, c) {\n    return isRegExp(charclass) ? !!c.match(charclass) : charclass[c]\n  }\n\n  function not (charclass, c) {\n    return !is(charclass, c)\n  }\n\n  var S = 0\n  sax.STATE = {\n    BEGIN: S++, // leading byte order mark or whitespace\n    BEGIN_WHITESPACE: S++, // leading whitespace\n    TEXT: S++, // general stuff\n    TEXT_ENTITY: S++, // &amp and such.\n    OPEN_WAKA: S++, // <\n    SGML_DECL: S++, // <!BLARG\n    SGML_DECL_QUOTED: S++, // <!BLARG foo \"bar\n    DOCTYPE: S++, // <!DOCTYPE\n    DOCTYPE_QUOTED: S++, // <!DOCTYPE \"//blah\n    DOCTYPE_DTD: S++, // <!DOCTYPE \"//blah\" [ ...\n    DOCTYPE_DTD_QUOTED: S++, // <!DOCTYPE \"//blah\" [ \"foo\n    COMMENT_STARTING: S++, // <!-\n    COMMENT: S++, // <!--\n    COMMENT_ENDING: S++, // <!-- blah -\n    COMMENT_ENDED: S++, // <!-- blah --\n    CDATA: S++, // <![CDATA[ something\n    CDATA_ENDING: S++, // ]\n    CDATA_ENDING_2: S++, // ]]\n    PROC_INST: S++, // <?hi\n    PROC_INST_BODY: S++, // <?hi there\n    PROC_INST_ENDING: S++, // <?hi \"there\" ?\n    OPEN_TAG: S++, // <strong\n    OPEN_TAG_SLASH: S++, // <strong /\n    ATTRIB: S++, // <a\n    ATTRIB_NAME: S++, // <a foo\n    ATTRIB_NAME_SAW_WHITE: S++, // <a foo _\n    ATTRIB_VALUE: S++, // <a foo=\n    ATTRIB_VALUE_QUOTED: S++, // <a foo=\"bar\n    ATTRIB_VALUE_CLOSED: S++, // <a foo=\"bar\"\n    ATTRIB_VALUE_UNQUOTED: S++, // <a foo=bar\n    ATTRIB_VALUE_ENTITY_Q: S++, // <foo bar=\"&quot;\"\n    ATTRIB_VALUE_ENTITY_U: S++, // <foo bar=&quot\n    CLOSE_TAG: S++, // </a\n    CLOSE_TAG_SAW_WHITE: S++, // </a   >\n    SCRIPT: S++, // <script> ...\n    SCRIPT_ENDING: S++ // <script> ... <\n  }\n\n  sax.XML_ENTITIES = {\n    'amp': '&',\n    'gt': '>',\n    'lt': '<',\n    'quot': '\"',\n    'apos': \"'\"\n  }\n\n  sax.ENTITIES = {\n    'amp': '&',\n    'gt': '>',\n    'lt': '<',\n    'quot': '\"',\n    'apos': \"'\",\n    'AElig': 198,\n    'Aacute': 193,\n    'Acirc': 194,\n    'Agrave': 192,\n    'Aring': 197,\n    'Atilde': 195,\n    'Auml': 196,\n    'Ccedil': 199,\n    'ETH': 208,\n    'Eacute': 201,\n    'Ecirc': 202,\n    'Egrave': 200,\n    'Euml': 203,\n    'Iacute': 205,\n    'Icirc': 206,\n    'Igrave': 204,\n    'Iuml': 207,\n    'Ntilde': 209,\n    'Oacute': 211,\n    'Ocirc': 212,\n    'Ograve': 210,\n    'Oslash': 216,\n    'Otilde': 213,\n    'Ouml': 214,\n    'THORN': 222,\n    'Uacute': 218,\n    'Ucirc': 219,\n    'Ugrave': 217,\n    'Uuml': 220,\n    'Yacute': 221,\n    'aacute': 225,\n    'acirc': 226,\n    'aelig': 230,\n    'agrave': 224,\n    'aring': 229,\n    'atilde': 227,\n    'auml': 228,\n    'ccedil': 231,\n    'eacute': 233,\n    'ecirc': 234,\n    'egrave': 232,\n    'eth': 240,\n    'euml': 235,\n    'iacute': 237,\n    'icirc': 238,\n    'igrave': 236,\n    'iuml': 239,\n    'ntilde': 241,\n    'oacute': 243,\n    'ocirc': 244,\n    'ograve': 242,\n    'oslash': 248,\n    'otilde': 245,\n    'ouml': 246,\n    'szlig': 223,\n    'thorn': 254,\n    'uacute': 250,\n    'ucirc': 251,\n    'ugrave': 249,\n    'uuml': 252,\n    'yacute': 253,\n    'yuml': 255,\n    'copy': 169,\n    'reg': 174,\n    'nbsp': 160,\n    'iexcl': 161,\n    'cent': 162,\n    'pound': 163,\n    'curren': 164,\n    'yen': 165,\n    'brvbar': 166,\n    'sect': 167,\n    'uml': 168,\n    'ordf': 170,\n    'laquo': 171,\n    'not': 172,\n    'shy': 173,\n    'macr': 175,\n    'deg': 176,\n    'plusmn': 177,\n    'sup1': 185,\n    'sup2': 178,\n    'sup3': 179,\n    'acute': 180,\n    'micro': 181,\n    'para': 182,\n    'middot': 183,\n    'cedil': 184,\n    'ordm': 186,\n    'raquo': 187,\n    'frac14': 188,\n    'frac12': 189,\n    'frac34': 190,\n    'iquest': 191,\n    'times': 215,\n    'divide': 247,\n    'OElig': 338,\n    'oelig': 339,\n    'Scaron': 352,\n    'scaron': 353,\n    'Yuml': 376,\n    'fnof': 402,\n    'circ': 710,\n    'tilde': 732,\n    'Alpha': 913,\n    'Beta': 914,\n    'Gamma': 915,\n    'Delta': 916,\n    'Epsilon': 917,\n    'Zeta': 918,\n    'Eta': 919,\n    'Theta': 920,\n    'Iota': 921,\n    'Kappa': 922,\n    'Lambda': 923,\n    'Mu': 924,\n    'Nu': 925,\n    'Xi': 926,\n    'Omicron': 927,\n    'Pi': 928,\n    'Rho': 929,\n    'Sigma': 931,\n    'Tau': 932,\n    'Upsilon': 933,\n    'Phi': 934,\n    'Chi': 935,\n    'Psi': 936,\n    'Omega': 937,\n    'alpha': 945,\n    'beta': 946,\n    'gamma': 947,\n    'delta': 948,\n    'epsilon': 949,\n    'zeta': 950,\n    'eta': 951,\n    'theta': 952,\n    'iota': 953,\n    'kappa': 954,\n    'lambda': 955,\n    'mu': 956,\n    'nu': 957,\n    'xi': 958,\n    'omicron': 959,\n    'pi': 960,\n    'rho': 961,\n    'sigmaf': 962,\n    'sigma': 963,\n    'tau': 964,\n    'upsilon': 965,\n    'phi': 966,\n    'chi': 967,\n    'psi': 968,\n    'omega': 969,\n    'thetasym': 977,\n    'upsih': 978,\n    'piv': 982,\n    'ensp': 8194,\n    'emsp': 8195,\n    'thinsp': 8201,\n    'zwnj': 8204,\n    'zwj': 8205,\n    'lrm': 8206,\n    'rlm': 8207,\n    'ndash': 8211,\n    'mdash': 8212,\n    'lsquo': 8216,\n    'rsquo': 8217,\n    'sbquo': 8218,\n    'ldquo': 8220,\n    'rdquo': 8221,\n    'bdquo': 8222,\n    'dagger': 8224,\n    'Dagger': 8225,\n    'bull': 8226,\n    'hellip': 8230,\n    'permil': 8240,\n    'prime': 8242,\n    'Prime': 8243,\n    'lsaquo': 8249,\n    'rsaquo': 8250,\n    'oline': 8254,\n    'frasl': 8260,\n    'euro': 8364,\n    'image': 8465,\n    'weierp': 8472,\n    'real': 8476,\n    'trade': 8482,\n    'alefsym': 8501,\n    'larr': 8592,\n    'uarr': 8593,\n    'rarr': 8594,\n    'darr': 8595,\n    'harr': 8596,\n    'crarr': 8629,\n    'lArr': 8656,\n    'uArr': 8657,\n    'rArr': 8658,\n    'dArr': 8659,\n    'hArr': 8660,\n    'forall': 8704,\n    'part': 8706,\n    'exist': 8707,\n    'empty': 8709,\n    'nabla': 8711,\n    'isin': 8712,\n    'notin': 8713,\n    'ni': 8715,\n    'prod': 8719,\n    'sum': 8721,\n    'minus': 8722,\n    'lowast': 8727,\n    'radic': 8730,\n    'prop': 8733,\n    'infin': 8734,\n    'ang': 8736,\n    'and': 8743,\n    'or': 8744,\n    'cap': 8745,\n    'cup': 8746,\n    'int': 8747,\n    'there4': 8756,\n    'sim': 8764,\n    'cong': 8773,\n    'asymp': 8776,\n    'ne': 8800,\n    'equiv': 8801,\n    'le': 8804,\n    'ge': 8805,\n    'sub': 8834,\n    'sup': 8835,\n    'nsub': 8836,\n    'sube': 8838,\n    'supe': 8839,\n    'oplus': 8853,\n    'otimes': 8855,\n    'perp': 8869,\n    'sdot': 8901,\n    'lceil': 8968,\n    'rceil': 8969,\n    'lfloor': 8970,\n    'rfloor': 8971,\n    'lang': 9001,\n    'rang': 9002,\n    'loz': 9674,\n    'spades': 9824,\n    'clubs': 9827,\n    'hearts': 9829,\n    'diams': 9830\n  }\n\n  Object.keys(sax.ENTITIES).forEach(function (key) {\n    var e = sax.ENTITIES[key]\n    var s = typeof e === 'number' ? String.fromCharCode(e) : e\n    sax.ENTITIES[key] = s\n  })\n\n  for (var s in sax.STATE) {\n    sax.STATE[sax.STATE[s]] = s\n  }\n\n  // shorthand\n  S = sax.STATE\n\n  function emit (parser, event, data) {\n    parser[event] && parser[event](data)\n  }\n\n  function emitNode (parser, nodeType, data) {\n    if (parser.textNode) closeText(parser)\n    emit(parser, nodeType, data)\n  }\n\n  function closeText (parser) {\n    parser.textNode = textopts(parser.opt, parser.textNode)\n    if (parser.textNode) emit(parser, 'ontext', parser.textNode)\n    parser.textNode = ''\n  }\n\n  function textopts (opt, text) {\n    if (opt.trim) text = text.trim()\n    if (opt.normalize) text = text.replace(/\\s+/g, ' ')\n    return text\n  }\n\n  function error (parser, er) {\n    closeText(parser)\n    if (parser.trackPosition) {\n      er += '\\nLine: ' + parser.line +\n        '\\nColumn: ' + parser.column +\n        '\\nChar: ' + parser.c\n    }\n    er = new Error(er)\n    parser.error = er\n    emit(parser, 'onerror', er)\n    return parser\n  }\n\n  function end (parser) {\n    if (parser.sawRoot && !parser.closedRoot) strictFail(parser, 'Unclosed root tag')\n    if ((parser.state !== S.BEGIN) &&\n      (parser.state !== S.BEGIN_WHITESPACE) &&\n      (parser.state !== S.TEXT)) {\n      error(parser, 'Unexpected end')\n    }\n    closeText(parser)\n    parser.c = ''\n    parser.closed = true\n    emit(parser, 'onend')\n    SAXParser.call(parser, parser.strict, parser.opt)\n    return parser\n  }\n\n  function strictFail (parser, message) {\n    if (typeof parser !== 'object' || !(parser instanceof SAXParser)) {\n      throw new Error('bad call to strictFail')\n    }\n    if (parser.strict) {\n      error(parser, message)\n    }\n  }\n\n  function newTag (parser) {\n    if (!parser.strict) parser.tagName = parser.tagName[parser.looseCase]()\n    var parent = parser.tags[parser.tags.length - 1] || parser\n    var tag = parser.tag = { name: parser.tagName, attributes: {} }\n\n    // will be overridden if tag contails an xmlns=\"foo\" or xmlns:foo=\"bar\"\n    if (parser.opt.xmlns) {\n      tag.ns = parent.ns\n    }\n    parser.attribList.length = 0\n  }\n\n  function qname (name, attribute) {\n    var i = name.indexOf(':')\n    var qualName = i < 0 ? [ '', name ] : name.split(':')\n    var prefix = qualName[0]\n    var local = qualName[1]\n\n    // <x \"xmlns\"=\"http://foo\">\n    if (attribute && name === 'xmlns') {\n      prefix = 'xmlns'\n      local = ''\n    }\n\n    return { prefix: prefix, local: local }\n  }\n\n  function attrib (parser) {\n    if (!parser.strict) {\n      parser.attribName = parser.attribName[parser.looseCase]()\n    }\n\n    if (parser.attribList.indexOf(parser.attribName) !== -1 ||\n      parser.tag.attributes.hasOwnProperty(parser.attribName)) {\n      parser.attribName = parser.attribValue = ''\n      return\n    }\n\n    if (parser.opt.xmlns) {\n      var qn = qname(parser.attribName, true)\n      var prefix = qn.prefix\n      var local = qn.local\n\n      if (prefix === 'xmlns') {\n        // namespace binding attribute. push the binding into scope\n        if (local === 'xml' && parser.attribValue !== XML_NAMESPACE) {\n          strictFail(parser,\n            'xml: prefix must be bound to ' + XML_NAMESPACE + '\\n' +\n            'Actual: ' + parser.attribValue)\n        } else if (local === 'xmlns' && parser.attribValue !== XMLNS_NAMESPACE) {\n          strictFail(parser,\n            'xmlns: prefix must be bound to ' + XMLNS_NAMESPACE + '\\n' +\n            'Actual: ' + parser.attribValue)\n        } else {\n          var tag = parser.tag\n          var parent = parser.tags[parser.tags.length - 1] || parser\n          if (tag.ns === parent.ns) {\n            tag.ns = Object.create(parent.ns)\n          }\n          tag.ns[local] = parser.attribValue\n        }\n      }\n\n      // defer onattribute events until all attributes have been seen\n      // so any new bindings can take effect. preserve attribute order\n      // so deferred events can be emitted in document order\n      parser.attribList.push([parser.attribName, parser.attribValue])\n    } else {\n      // in non-xmlns mode, we can emit the event right away\n      parser.tag.attributes[parser.attribName] = parser.attribValue\n      emitNode(parser, 'onattribute', {\n        name: parser.attribName,\n        value: parser.attribValue\n      })\n    }\n\n    parser.attribName = parser.attribValue = ''\n  }\n\n  function openTag (parser, selfClosing) {\n    if (parser.opt.xmlns) {\n      // emit namespace binding events\n      var tag = parser.tag\n\n      // add namespace info to tag\n      var qn = qname(parser.tagName)\n      tag.prefix = qn.prefix\n      tag.local = qn.local\n      tag.uri = tag.ns[qn.prefix] || ''\n\n      if (tag.prefix && !tag.uri) {\n        strictFail(parser, 'Unbound namespace prefix: ' +\n          JSON.stringify(parser.tagName))\n        tag.uri = qn.prefix\n      }\n\n      var parent = parser.tags[parser.tags.length - 1] || parser\n      if (tag.ns && parent.ns !== tag.ns) {\n        Object.keys(tag.ns).forEach(function (p) {\n          emitNode(parser, 'onopennamespace', {\n            prefix: p,\n            uri: tag.ns[p]\n          })\n        })\n      }\n\n      // handle deferred onattribute events\n      // Note: do not apply default ns to attributes:\n      //   http://www.w3.org/TR/REC-xml-names/#defaulting\n      for (var i = 0, l = parser.attribList.length; i < l; i++) {\n        var nv = parser.attribList[i]\n        var name = nv[0]\n        var value = nv[1]\n        var qualName = qname(name, true)\n        var prefix = qualName.prefix\n        var local = qualName.local\n        var uri = prefix === '' ? '' : (tag.ns[prefix] || '')\n        var a = {\n          name: name,\n          value: value,\n          prefix: prefix,\n          local: local,\n          uri: uri\n        }\n\n        // if there's any attributes with an undefined namespace,\n        // then fail on them now.\n        if (prefix && prefix !== 'xmlns' && !uri) {\n          strictFail(parser, 'Unbound namespace prefix: ' +\n            JSON.stringify(prefix))\n          a.uri = prefix\n        }\n        parser.tag.attributes[name] = a\n        emitNode(parser, 'onattribute', a)\n      }\n      parser.attribList.length = 0\n    }\n\n    parser.tag.isSelfClosing = !!selfClosing\n\n    // process the tag\n    parser.sawRoot = true\n    parser.tags.push(parser.tag)\n    emitNode(parser, 'onopentag', parser.tag)\n    if (!selfClosing) {\n      // special case for <script> in non-strict mode.\n      if (!parser.noscript && parser.tagName.toLowerCase() === 'script') {\n        parser.state = S.SCRIPT\n      } else {\n        parser.state = S.TEXT\n      }\n      parser.tag = null\n      parser.tagName = ''\n    }\n    parser.attribName = parser.attribValue = ''\n    parser.attribList.length = 0\n  }\n\n  function closeTag (parser) {\n    if (!parser.tagName) {\n      strictFail(parser, 'Weird empty close tag.')\n      parser.textNode += '</>'\n      parser.state = S.TEXT\n      return\n    }\n\n    if (parser.script) {\n      if (parser.tagName !== 'script') {\n        parser.script += '</' + parser.tagName + '>'\n        parser.tagName = ''\n        parser.state = S.SCRIPT\n        return\n      }\n      emitNode(parser, 'onscript', parser.script)\n      parser.script = ''\n    }\n\n    // first make sure that the closing tag actually exists.\n    // <a><b></c></b></a> will close everything, otherwise.\n    var t = parser.tags.length\n    var tagName = parser.tagName\n    if (!parser.strict) {\n      tagName = tagName[parser.looseCase]()\n    }\n    var closeTo = tagName\n    while (t--) {\n      var close = parser.tags[t]\n      if (close.name !== closeTo) {\n        // fail the first time in strict mode\n        strictFail(parser, 'Unexpected close tag')\n      } else {\n        break\n      }\n    }\n\n    // didn't find it.  we already failed for strict, so just abort.\n    if (t < 0) {\n      strictFail(parser, 'Unmatched closing tag: ' + parser.tagName)\n      parser.textNode += '</' + parser.tagName + '>'\n      parser.state = S.TEXT\n      return\n    }\n    parser.tagName = tagName\n    var s = parser.tags.length\n    while (s-- > t) {\n      var tag = parser.tag = parser.tags.pop()\n      parser.tagName = parser.tag.name\n      emitNode(parser, 'onclosetag', parser.tagName)\n\n      var x = {}\n      for (var i in tag.ns) {\n        x[i] = tag.ns[i]\n      }\n\n      var parent = parser.tags[parser.tags.length - 1] || parser\n      if (parser.opt.xmlns && tag.ns !== parent.ns) {\n        // remove namespace bindings introduced by tag\n        Object.keys(tag.ns).forEach(function (p) {\n          var n = tag.ns[p]\n          emitNode(parser, 'onclosenamespace', { prefix: p, uri: n })\n        })\n      }\n    }\n    if (t === 0) parser.closedRoot = true\n    parser.tagName = parser.attribValue = parser.attribName = ''\n    parser.attribList.length = 0\n    parser.state = S.TEXT\n  }\n\n  function parseEntity (parser) {\n    var entity = parser.entity\n    var entityLC = entity.toLowerCase()\n    var num\n    var numStr = ''\n\n    if (parser.ENTITIES[entity]) {\n      return parser.ENTITIES[entity]\n    }\n    if (parser.ENTITIES[entityLC]) {\n      return parser.ENTITIES[entityLC]\n    }\n    entity = entityLC\n    if (entity.charAt(0) === '#') {\n      if (entity.charAt(1) === 'x') {\n        entity = entity.slice(2)\n        num = parseInt(entity, 16)\n        numStr = num.toString(16)\n      } else {\n        entity = entity.slice(1)\n        num = parseInt(entity, 10)\n        numStr = num.toString(10)\n      }\n    }\n    entity = entity.replace(/^0+/, '')\n    if (numStr.toLowerCase() !== entity) {\n      strictFail(parser, 'Invalid character entity')\n      return '&' + parser.entity + ';'\n    }\n\n    return String.fromCodePoint(num)\n  }\n\n  function beginWhiteSpace (parser, c) {\n    if (c === '<') {\n      parser.state = S.OPEN_WAKA\n      parser.startTagPosition = parser.position\n    } else if (not(whitespace, c)) {\n      // have to process this as a text node.\n      // weird, but happens.\n      strictFail(parser, 'Non-whitespace before first tag.')\n      parser.textNode = c\n      parser.state = S.TEXT\n    }\n  }\n\n  function write (chunk) {\n    var parser = this\n    if (this.error) {\n      throw this.error\n    }\n    if (parser.closed) {\n      return error(parser,\n        'Cannot write after close. Assign an onready handler.')\n    }\n    if (chunk === null) {\n      return end(parser)\n    }\n    var i = 0\n    var c = ''\n    while (true) {\n      c = chunk.charAt(i++)\n      parser.c = c\n      if (!c) {\n        break\n      }\n      if (parser.trackPosition) {\n        parser.position++\n        if (c === '\\n') {\n          parser.line++\n          parser.column = 0\n        } else {\n          parser.column++\n        }\n      }\n      switch (parser.state) {\n        case S.BEGIN:\n          parser.state = S.BEGIN_WHITESPACE\n          if (c === '\\uFEFF') {\n            continue\n          }\n          beginWhiteSpace(parser, c)\n          continue\n\n        case S.BEGIN_WHITESPACE:\n          beginWhiteSpace(parser, c)\n          continue\n\n        case S.TEXT:\n          if (parser.sawRoot && !parser.closedRoot) {\n            var starti = i - 1\n            while (c && c !== '<' && c !== '&') {\n              c = chunk.charAt(i++)\n              if (c && parser.trackPosition) {\n                parser.position++\n                if (c === '\\n') {\n                  parser.line++\n                  parser.column = 0\n                } else {\n                  parser.column++\n                }\n              }\n            }\n            parser.textNode += chunk.substring(starti, i - 1)\n          }\n          if (c === '<' && !(parser.sawRoot && parser.closedRoot && !parser.strict)) {\n            parser.state = S.OPEN_WAKA\n            parser.startTagPosition = parser.position\n          } else {\n            if (not(whitespace, c) && (!parser.sawRoot || parser.closedRoot)) {\n              strictFail(parser, 'Text data outside of root node.')\n            }\n            if (c === '&') {\n              parser.state = S.TEXT_ENTITY\n            } else {\n              parser.textNode += c\n            }\n          }\n          continue\n\n        case S.SCRIPT:\n          // only non-strict\n          if (c === '<') {\n            parser.state = S.SCRIPT_ENDING\n          } else {\n            parser.script += c\n          }\n          continue\n\n        case S.SCRIPT_ENDING:\n          if (c === '/') {\n            parser.state = S.CLOSE_TAG\n          } else {\n            parser.script += '<' + c\n            parser.state = S.SCRIPT\n          }\n          continue\n\n        case S.OPEN_WAKA:\n          // either a /, ?, !, or text is coming next.\n          if (c === '!') {\n            parser.state = S.SGML_DECL\n            parser.sgmlDecl = ''\n          } else if (is(whitespace, c)) {\n            // wait for it...\n          } else if (is(nameStart, c)) {\n            parser.state = S.OPEN_TAG\n            parser.tagName = c\n          } else if (c === '/') {\n            parser.state = S.CLOSE_TAG\n            parser.tagName = ''\n          } else if (c === '?') {\n            parser.state = S.PROC_INST\n            parser.procInstName = parser.procInstBody = ''\n          } else {\n            strictFail(parser, 'Unencoded <')\n            // if there was some whitespace, then add that in.\n            if (parser.startTagPosition + 1 < parser.position) {\n              var pad = parser.position - parser.startTagPosition\n              c = new Array(pad).join(' ') + c\n            }\n            parser.textNode += '<' + c\n            parser.state = S.TEXT\n          }\n          continue\n\n        case S.SGML_DECL:\n          if ((parser.sgmlDecl + c).toUpperCase() === CDATA) {\n            emitNode(parser, 'onopencdata')\n            parser.state = S.CDATA\n            parser.sgmlDecl = ''\n            parser.cdata = ''\n          } else if (parser.sgmlDecl + c === '--') {\n            parser.state = S.COMMENT\n            parser.comment = ''\n            parser.sgmlDecl = ''\n          } else if ((parser.sgmlDecl + c).toUpperCase() === DOCTYPE) {\n            parser.state = S.DOCTYPE\n            if (parser.doctype || parser.sawRoot) {\n              strictFail(parser,\n                'Inappropriately located doctype declaration')\n            }\n            parser.doctype = ''\n            parser.sgmlDecl = ''\n          } else if (c === '>') {\n            emitNode(parser, 'onsgmldeclaration', parser.sgmlDecl)\n            parser.sgmlDecl = ''\n            parser.state = S.TEXT\n          } else if (is(quote, c)) {\n            parser.state = S.SGML_DECL_QUOTED\n            parser.sgmlDecl += c\n          } else {\n            parser.sgmlDecl += c\n          }\n          continue\n\n        case S.SGML_DECL_QUOTED:\n          if (c === parser.q) {\n            parser.state = S.SGML_DECL\n            parser.q = ''\n          }\n          parser.sgmlDecl += c\n          continue\n\n        case S.DOCTYPE:\n          if (c === '>') {\n            parser.state = S.TEXT\n            emitNode(parser, 'ondoctype', parser.doctype)\n            parser.doctype = true // just remember that we saw it.\n          } else {\n            parser.doctype += c\n            if (c === '[') {\n              parser.state = S.DOCTYPE_DTD\n            } else if (is(quote, c)) {\n              parser.state = S.DOCTYPE_QUOTED\n              parser.q = c\n            }\n          }\n          continue\n\n        case S.DOCTYPE_QUOTED:\n          parser.doctype += c\n          if (c === parser.q) {\n            parser.q = ''\n            parser.state = S.DOCTYPE\n          }\n          continue\n\n        case S.DOCTYPE_DTD:\n          parser.doctype += c\n          if (c === ']') {\n            parser.state = S.DOCTYPE\n          } else if (is(quote, c)) {\n            parser.state = S.DOCTYPE_DTD_QUOTED\n            parser.q = c\n          }\n          continue\n\n        case S.DOCTYPE_DTD_QUOTED:\n          parser.doctype += c\n          if (c === parser.q) {\n            parser.state = S.DOCTYPE_DTD\n            parser.q = ''\n          }\n          continue\n\n        case S.COMMENT:\n          if (c === '-') {\n            parser.state = S.COMMENT_ENDING\n          } else {\n            parser.comment += c\n          }\n          continue\n\n        case S.COMMENT_ENDING:\n          if (c === '-') {\n            parser.state = S.COMMENT_ENDED\n            parser.comment = textopts(parser.opt, parser.comment)\n            if (parser.comment) {\n              emitNode(parser, 'oncomment', parser.comment)\n            }\n            parser.comment = ''\n          } else {\n            parser.comment += '-' + c\n            parser.state = S.COMMENT\n          }\n          continue\n\n        case S.COMMENT_ENDED:\n          if (c !== '>') {\n            strictFail(parser, 'Malformed comment')\n            // allow <!-- blah -- bloo --> in non-strict mode,\n            // which is a comment of \" blah -- bloo \"\n            parser.comment += '--' + c\n            parser.state = S.COMMENT\n          } else {\n            parser.state = S.TEXT\n          }\n          continue\n\n        case S.CDATA:\n          if (c === ']') {\n            parser.state = S.CDATA_ENDING\n          } else {\n            parser.cdata += c\n          }\n          continue\n\n        case S.CDATA_ENDING:\n          if (c === ']') {\n            parser.state = S.CDATA_ENDING_2\n          } else {\n            parser.cdata += ']' + c\n            parser.state = S.CDATA\n          }\n          continue\n\n        case S.CDATA_ENDING_2:\n          if (c === '>') {\n            if (parser.cdata) {\n              emitNode(parser, 'oncdata', parser.cdata)\n            }\n            emitNode(parser, 'onclosecdata')\n            parser.cdata = ''\n            parser.state = S.TEXT\n          } else if (c === ']') {\n            parser.cdata += ']'\n          } else {\n            parser.cdata += ']]' + c\n            parser.state = S.CDATA\n          }\n          continue\n\n        case S.PROC_INST:\n          if (c === '?') {\n            parser.state = S.PROC_INST_ENDING\n          } else if (is(whitespace, c)) {\n            parser.state = S.PROC_INST_BODY\n          } else {\n            parser.procInstName += c\n          }\n          continue\n\n        case S.PROC_INST_BODY:\n          if (!parser.procInstBody && is(whitespace, c)) {\n            continue\n          } else if (c === '?') {\n            parser.state = S.PROC_INST_ENDING\n          } else {\n            parser.procInstBody += c\n          }\n          continue\n\n        case S.PROC_INST_ENDING:\n          if (c === '>') {\n            emitNode(parser, 'onprocessinginstruction', {\n              name: parser.procInstName,\n              body: parser.procInstBody\n            })\n            parser.procInstName = parser.procInstBody = ''\n            parser.state = S.TEXT\n          } else {\n            parser.procInstBody += '?' + c\n            parser.state = S.PROC_INST_BODY\n          }\n          continue\n\n        case S.OPEN_TAG:\n          if (is(nameBody, c)) {\n            parser.tagName += c\n          } else {\n            newTag(parser)\n            if (c === '>') {\n              openTag(parser)\n            } else if (c === '/') {\n              parser.state = S.OPEN_TAG_SLASH\n            } else {\n              if (not(whitespace, c)) {\n                strictFail(parser, 'Invalid character in tag name')\n              }\n              parser.state = S.ATTRIB\n            }\n          }\n          continue\n\n        case S.OPEN_TAG_SLASH:\n          if (c === '>') {\n            openTag(parser, true)\n            closeTag(parser)\n          } else {\n            strictFail(parser, 'Forward-slash in opening tag not followed by >')\n            parser.state = S.ATTRIB\n          }\n          continue\n\n        case S.ATTRIB:\n          // haven't read the attribute name yet.\n          if (is(whitespace, c)) {\n            continue\n          } else if (c === '>') {\n            openTag(parser)\n          } else if (c === '/') {\n            parser.state = S.OPEN_TAG_SLASH\n          } else if (is(nameStart, c)) {\n            parser.attribName = c\n            parser.attribValue = ''\n            parser.state = S.ATTRIB_NAME\n          } else {\n            strictFail(parser, 'Invalid attribute name')\n          }\n          continue\n\n        case S.ATTRIB_NAME:\n          if (c === '=') {\n            parser.state = S.ATTRIB_VALUE\n          } else if (c === '>') {\n            strictFail(parser, 'Attribute without value')\n            parser.attribValue = parser.attribName\n            attrib(parser)\n            openTag(parser)\n          } else if (is(whitespace, c)) {\n            parser.state = S.ATTRIB_NAME_SAW_WHITE\n          } else if (is(nameBody, c)) {\n            parser.attribName += c\n          } else {\n            strictFail(parser, 'Invalid attribute name')\n          }\n          continue\n\n        case S.ATTRIB_NAME_SAW_WHITE:\n          if (c === '=') {\n            parser.state = S.ATTRIB_VALUE\n          } else if (is(whitespace, c)) {\n            continue\n          } else {\n            strictFail(parser, 'Attribute without value')\n            parser.tag.attributes[parser.attribName] = ''\n            parser.attribValue = ''\n            emitNode(parser, 'onattribute', {\n              name: parser.attribName,\n              value: ''\n            })\n            parser.attribName = ''\n            if (c === '>') {\n              openTag(parser)\n            } else if (is(nameStart, c)) {\n              parser.attribName = c\n              parser.state = S.ATTRIB_NAME\n            } else {\n              strictFail(parser, 'Invalid attribute name')\n              parser.state = S.ATTRIB\n            }\n          }\n          continue\n\n        case S.ATTRIB_VALUE:\n          if (is(whitespace, c)) {\n            continue\n          } else if (is(quote, c)) {\n            parser.q = c\n            parser.state = S.ATTRIB_VALUE_QUOTED\n          } else {\n            strictFail(parser, 'Unquoted attribute value')\n            parser.state = S.ATTRIB_VALUE_UNQUOTED\n            parser.attribValue = c\n          }\n          continue\n\n        case S.ATTRIB_VALUE_QUOTED:\n          if (c !== parser.q) {\n            if (c === '&') {\n              parser.state = S.ATTRIB_VALUE_ENTITY_Q\n            } else {\n              parser.attribValue += c\n            }\n            continue\n          }\n          attrib(parser)\n          parser.q = ''\n          parser.state = S.ATTRIB_VALUE_CLOSED\n          continue\n\n        case S.ATTRIB_VALUE_CLOSED:\n          if (is(whitespace, c)) {\n            parser.state = S.ATTRIB\n          } else if (c === '>') {\n            openTag(parser)\n          } else if (c === '/') {\n            parser.state = S.OPEN_TAG_SLASH\n          } else if (is(nameStart, c)) {\n            strictFail(parser, 'No whitespace between attributes')\n            parser.attribName = c\n            parser.attribValue = ''\n            parser.state = S.ATTRIB_NAME\n          } else {\n            strictFail(parser, 'Invalid attribute name')\n          }\n          continue\n\n        case S.ATTRIB_VALUE_UNQUOTED:\n          if (not(attribEnd, c)) {\n            if (c === '&') {\n              parser.state = S.ATTRIB_VALUE_ENTITY_U\n            } else {\n              parser.attribValue += c\n            }\n            continue\n          }\n          attrib(parser)\n          if (c === '>') {\n            openTag(parser)\n          } else {\n            parser.state = S.ATTRIB\n          }\n          continue\n\n        case S.CLOSE_TAG:\n          if (!parser.tagName) {\n            if (is(whitespace, c)) {\n              continue\n            } else if (not(nameStart, c)) {\n              if (parser.script) {\n                parser.script += '</' + c\n                parser.state = S.SCRIPT\n              } else {\n                strictFail(parser, 'Invalid tagname in closing tag.')\n              }\n            } else {\n              parser.tagName = c\n            }\n          } else if (c === '>') {\n            closeTag(parser)\n          } else if (is(nameBody, c)) {\n            parser.tagName += c\n          } else if (parser.script) {\n            parser.script += '</' + parser.tagName\n            parser.tagName = ''\n            parser.state = S.SCRIPT\n          } else {\n            if (not(whitespace, c)) {\n              strictFail(parser, 'Invalid tagname in closing tag')\n            }\n            parser.state = S.CLOSE_TAG_SAW_WHITE\n          }\n          continue\n\n        case S.CLOSE_TAG_SAW_WHITE:\n          if (is(whitespace, c)) {\n            continue\n          }\n          if (c === '>') {\n            closeTag(parser)\n          } else {\n            strictFail(parser, 'Invalid characters in closing tag')\n          }\n          continue\n\n        case S.TEXT_ENTITY:\n        case S.ATTRIB_VALUE_ENTITY_Q:\n        case S.ATTRIB_VALUE_ENTITY_U:\n          var returnState\n          var buffer\n          switch (parser.state) {\n            case S.TEXT_ENTITY:\n              returnState = S.TEXT\n              buffer = 'textNode'\n              break\n\n            case S.ATTRIB_VALUE_ENTITY_Q:\n              returnState = S.ATTRIB_VALUE_QUOTED\n              buffer = 'attribValue'\n              break\n\n            case S.ATTRIB_VALUE_ENTITY_U:\n              returnState = S.ATTRIB_VALUE_UNQUOTED\n              buffer = 'attribValue'\n              break\n          }\n\n          if (c === ';') {\n            parser[buffer] += parseEntity(parser)\n            parser.entity = ''\n            parser.state = returnState\n          } else if (is(parser.entity.length ? entityBody : entityStart, c)) {\n            parser.entity += c\n          } else {\n            strictFail(parser, 'Invalid character in entity name')\n            parser[buffer] += '&' + parser.entity + c\n            parser.entity = ''\n            parser.state = returnState\n          }\n\n          continue\n\n        default:\n          throw new Error(parser, 'Unknown state: ' + parser.state)\n      }\n    } // while\n\n    if (parser.position >= parser.bufferCheckPosition) {\n      checkBufferLength(parser)\n    }\n    return parser\n  }\n\n  /*! http://mths.be/fromcodepoint v0.1.0 by @mathias */\n  if (!String.fromCodePoint) {\n    (function () {\n      var stringFromCharCode = String.fromCharCode\n      var floor = Math.floor\n      var fromCodePoint = function () {\n        var MAX_SIZE = 0x4000\n        var codeUnits = []\n        var highSurrogate\n        var lowSurrogate\n        var index = -1\n        var length = arguments.length\n        if (!length) {\n          return ''\n        }\n        var result = ''\n        while (++index < length) {\n          var codePoint = Number(arguments[index])\n          if (\n            !isFinite(codePoint) || // `NaN`, `+Infinity`, or `-Infinity`\n            codePoint < 0 || // not a valid Unicode code point\n            codePoint > 0x10FFFF || // not a valid Unicode code point\n            floor(codePoint) !== codePoint // not an integer\n          ) {\n            throw RangeError('Invalid code point: ' + codePoint)\n          }\n          if (codePoint <= 0xFFFF) { // BMP code point\n            codeUnits.push(codePoint)\n          } else { // Astral code point; split in surrogate halves\n            // http://mathiasbynens.be/notes/javascript-encoding#surrogate-formulae\n            codePoint -= 0x10000\n            highSurrogate = (codePoint >> 10) + 0xD800\n            lowSurrogate = (codePoint % 0x400) + 0xDC00\n            codeUnits.push(highSurrogate, lowSurrogate)\n          }\n          if (index + 1 === length || codeUnits.length > MAX_SIZE) {\n            result += stringFromCharCode.apply(null, codeUnits)\n            codeUnits.length = 0\n          }\n        }\n        return result\n      }\n      if (Object.defineProperty) {\n        Object.defineProperty(String, 'fromCodePoint', {\n          value: fromCodePoint,\n          configurable: true,\n          writable: true\n        })\n      } else {\n        String.fromCodePoint = fromCodePoint\n      }\n    }())\n  }\n})(typeof exports === 'undefined' ? this.sax = {} : exports)\n\n}).call(this,require(\"buffer\").Buffer)\n\n},{\"buffer\":4,\"stream\":31,\"string_decoder\":37}]},{},[1])\n\n","const URL_LAWLY_BOT_HOST = 'lawlybot.herokuapp.com',\n    URL_LAWLY_BOT_API_PATH = '/api/bwb/',\n    URL_LAWLY_BOT = 'https://' + URL_LAWLY_BOT_HOST + URL_LAWLY_BOT_API_PATH;\n\nmodule.exports = {\n    URL_LAWLY_BOT_HOST: URL_LAWLY_BOT_HOST,\n    URL_LAWLY_BOT_API_PATH: URL_LAWLY_BOT_API_PATH,\n    URL_LAWLY_BOT: URL_LAWLY_BOT\n};","/*!\n * The buffer module from node.js, for the browser.\n *\n * @author   Feross Aboukhadijeh <feross@feross.org> <http://feross.org>\n * @license  MIT\n */\n/* eslint-disable no-proto */\n\nvar base64 = require('base64-js')\nvar ieee754 = require('ieee754')\nvar isArray = require('isarray')\n\nexports.Buffer = Buffer\nexports.SlowBuffer = SlowBuffer\nexports.INSPECT_MAX_BYTES = 50\nBuffer.poolSize = 8192 // not used by this implementation\n\nvar rootParent = {}\n\n/**\n * If `Buffer.TYPED_ARRAY_SUPPORT`:\n *   === true    Use Uint8Array implementation (fastest)\n *   === false   Use Object implementation (most compatible, even IE6)\n *\n * Browsers that support typed arrays are IE 10+, Firefox 4+, Chrome 7+, Safari 5.1+,\n * Opera 11.6+, iOS 4.2+.\n *\n * Due to various browser bugs, sometimes the Object implementation will be used even\n * when the browser supports typed arrays.\n *\n * Note:\n *\n *   - Firefox 4-29 lacks support for adding new properties to `Uint8Array` instances,\n *     See: https://bugzilla.mozilla.org/show_bug.cgi?id=695438.\n *\n *   - Safari 5-7 lacks support for changing the `Object.prototype.constructor` property\n *     on objects.\n *\n *   - Chrome 9-10 is missing the `TypedArray.prototype.subarray` function.\n *\n *   - IE10 has a broken `TypedArray.prototype.subarray` function which returns arrays of\n *     incorrect length in some situations.\n\n * We detect these buggy browsers and set `Buffer.TYPED_ARRAY_SUPPORT` to `false` so they\n * get the Object implementation, which is slower but behaves correctly.\n */\nBuffer.TYPED_ARRAY_SUPPORT = global.TYPED_ARRAY_SUPPORT !== undefined\n  ? global.TYPED_ARRAY_SUPPORT\n  : typedArraySupport()\n\nfunction typedArraySupport () {\n  function Bar () {}\n  try {\n    var arr = new Uint8Array(1)\n    arr.foo = function () { return 42 }\n    arr.constructor = Bar\n    return arr.foo() === 42 && // typed array instances can be augmented\n        arr.constructor === Bar && // constructor can be set\n        typeof arr.subarray === 'function' && // chrome 9-10 lack `subarray`\n        arr.subarray(1, 1).byteLength === 0 // ie10 has broken `subarray`\n  } catch (e) {\n    return false\n  }\n}\n\nfunction kMaxLength () {\n  return Buffer.TYPED_ARRAY_SUPPORT\n    ? 0x7fffffff\n    : 0x3fffffff\n}\n\n/**\n * Class: Buffer\n * =============\n *\n * The Buffer constructor returns instances of `Uint8Array` that are augmented\n * with function properties for all the node `Buffer` API functions. We use\n * `Uint8Array` so that square bracket notation works as expected -- it returns\n * a single octet.\n *\n * By augmenting the instances, we can avoid modifying the `Uint8Array`\n * prototype.\n */\nfunction Buffer (arg) {\n  if (!(this instanceof Buffer)) {\n    // Avoid going through an ArgumentsAdaptorTrampoline in the common case.\n    if (arguments.length > 1) return new Buffer(arg, arguments[1])\n    return new Buffer(arg)\n  }\n\n  this.length = 0\n  this.parent = undefined\n\n  // Common case.\n  if (typeof arg === 'number') {\n    return fromNumber(this, arg)\n  }\n\n  // Slightly less common case.\n  if (typeof arg === 'string') {\n    return fromString(this, arg, arguments.length > 1 ? arguments[1] : 'utf8')\n  }\n\n  // Unusual.\n  return fromObject(this, arg)\n}\n\nfunction fromNumber (that, length) {\n  that = allocate(that, length < 0 ? 0 : checked(length) | 0)\n  if (!Buffer.TYPED_ARRAY_SUPPORT) {\n    for (var i = 0; i < length; i++) {\n      that[i] = 0\n    }\n  }\n  return that\n}\n\nfunction fromString (that, string, encoding) {\n  if (typeof encoding !== 'string' || encoding === '') encoding = 'utf8'\n\n  // Assumption: byteLength() return value is always < kMaxLength.\n  var length = byteLength(string, encoding) | 0\n  that = allocate(that, length)\n\n  that.write(string, encoding)\n  return that\n}\n\nfunction fromObject (that, object) {\n  if (Buffer.isBuffer(object)) return fromBuffer(that, object)\n\n  if (isArray(object)) return fromArray(that, object)\n\n  if (object == null) {\n    throw new TypeError('must start with number, buffer, array or string')\n  }\n\n  if (typeof ArrayBuffer !== 'undefined') {\n    if (object.buffer instanceof ArrayBuffer) {\n      return fromTypedArray(that, object)\n    }\n    if (object instanceof ArrayBuffer) {\n      return fromArrayBuffer(that, object)\n    }\n  }\n\n  if (object.length) return fromArrayLike(that, object)\n\n  return fromJsonObject(that, object)\n}\n\nfunction fromBuffer (that, buffer) {\n  var length = checked(buffer.length) | 0\n  that = allocate(that, length)\n  buffer.copy(that, 0, 0, length)\n  return that\n}\n\nfunction fromArray (that, array) {\n  var length = checked(array.length) | 0\n  that = allocate(that, length)\n  for (var i = 0; i < length; i += 1) {\n    that[i] = array[i] & 255\n  }\n  return that\n}\n\n// Duplicate of fromArray() to keep fromArray() monomorphic.\nfunction fromTypedArray (that, array) {\n  var length = checked(array.length) | 0\n  that = allocate(that, length)\n  // Truncating the elements is probably not what people expect from typed\n  // arrays with BYTES_PER_ELEMENT > 1 but it's compatible with the behavior\n  // of the old Buffer constructor.\n  for (var i = 0; i < length; i += 1) {\n    that[i] = array[i] & 255\n  }\n  return that\n}\n\nfunction fromArrayBuffer (that, array) {\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    // Return an augmented `Uint8Array` instance, for best performance\n    array.byteLength\n    that = Buffer._augment(new Uint8Array(array))\n  } else {\n    // Fallback: Return an object instance of the Buffer class\n    that = fromTypedArray(that, new Uint8Array(array))\n  }\n  return that\n}\n\nfunction fromArrayLike (that, array) {\n  var length = checked(array.length) | 0\n  that = allocate(that, length)\n  for (var i = 0; i < length; i += 1) {\n    that[i] = array[i] & 255\n  }\n  return that\n}\n\n// Deserialize { type: 'Buffer', data: [1,2,3,...] } into a Buffer object.\n// Returns a zero-length buffer for inputs that don't conform to the spec.\nfunction fromJsonObject (that, object) {\n  var array\n  var length = 0\n\n  if (object.type === 'Buffer' && isArray(object.data)) {\n    array = object.data\n    length = checked(array.length) | 0\n  }\n  that = allocate(that, length)\n\n  for (var i = 0; i < length; i += 1) {\n    that[i] = array[i] & 255\n  }\n  return that\n}\n\nif (Buffer.TYPED_ARRAY_SUPPORT) {\n  Buffer.prototype.__proto__ = Uint8Array.prototype\n  Buffer.__proto__ = Uint8Array\n}\n\nfunction allocate (that, length) {\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    // Return an augmented `Uint8Array` instance, for best performance\n    that = Buffer._augment(new Uint8Array(length))\n    that.__proto__ = Buffer.prototype\n  } else {\n    // Fallback: Return an object instance of the Buffer class\n    that.length = length\n    that._isBuffer = true\n  }\n\n  var fromPool = length !== 0 && length <= Buffer.poolSize >>> 1\n  if (fromPool) that.parent = rootParent\n\n  return that\n}\n\nfunction checked (length) {\n  // Note: cannot use `length < kMaxLength` here because that fails when\n  // length is NaN (which is otherwise coerced to zero.)\n  if (length >= kMaxLength()) {\n    throw new RangeError('Attempt to allocate Buffer larger than maximum ' +\n                         'size: 0x' + kMaxLength().toString(16) + ' bytes')\n  }\n  return length | 0\n}\n\nfunction SlowBuffer (subject, encoding) {\n  if (!(this instanceof SlowBuffer)) return new SlowBuffer(subject, encoding)\n\n  var buf = new Buffer(subject, encoding)\n  delete buf.parent\n  return buf\n}\n\nBuffer.isBuffer = function isBuffer (b) {\n  return !!(b != null && b._isBuffer)\n}\n\nBuffer.compare = function compare (a, b) {\n  if (!Buffer.isBuffer(a) || !Buffer.isBuffer(b)) {\n    throw new TypeError('Arguments must be Buffers')\n  }\n\n  if (a === b) return 0\n\n  var x = a.length\n  var y = b.length\n\n  var i = 0\n  var len = Math.min(x, y)\n  while (i < len) {\n    if (a[i] !== b[i]) break\n\n    ++i\n  }\n\n  if (i !== len) {\n    x = a[i]\n    y = b[i]\n  }\n\n  if (x < y) return -1\n  if (y < x) return 1\n  return 0\n}\n\nBuffer.isEncoding = function isEncoding (encoding) {\n  switch (String(encoding).toLowerCase()) {\n    case 'hex':\n    case 'utf8':\n    case 'utf-8':\n    case 'ascii':\n    case 'binary':\n    case 'base64':\n    case 'raw':\n    case 'ucs2':\n    case 'ucs-2':\n    case 'utf16le':\n    case 'utf-16le':\n      return true\n    default:\n      return false\n  }\n}\n\nBuffer.concat = function concat (list, length) {\n  if (!isArray(list)) throw new TypeError('list argument must be an Array of Buffers.')\n\n  if (list.length === 0) {\n    return new Buffer(0)\n  }\n\n  var i\n  if (length === undefined) {\n    length = 0\n    for (i = 0; i < list.length; i++) {\n      length += list[i].length\n    }\n  }\n\n  var buf = new Buffer(length)\n  var pos = 0\n  for (i = 0; i < list.length; i++) {\n    var item = list[i]\n    item.copy(buf, pos)\n    pos += item.length\n  }\n  return buf\n}\n\nfunction byteLength (string, encoding) {\n  if (typeof string !== 'string') string = '' + string\n\n  var len = string.length\n  if (len === 0) return 0\n\n  // Use a for loop to avoid recursion\n  var loweredCase = false\n  for (;;) {\n    switch (encoding) {\n      case 'ascii':\n      case 'binary':\n      // Deprecated\n      case 'raw':\n      case 'raws':\n        return len\n      case 'utf8':\n      case 'utf-8':\n        return utf8ToBytes(string).length\n      case 'ucs2':\n      case 'ucs-2':\n      case 'utf16le':\n      case 'utf-16le':\n        return len * 2\n      case 'hex':\n        return len >>> 1\n      case 'base64':\n        return base64ToBytes(string).length\n      default:\n        if (loweredCase) return utf8ToBytes(string).length // assume utf8\n        encoding = ('' + encoding).toLowerCase()\n        loweredCase = true\n    }\n  }\n}\nBuffer.byteLength = byteLength\n\n// pre-set for values that may exist in the future\nBuffer.prototype.length = undefined\nBuffer.prototype.parent = undefined\n\nfunction slowToString (encoding, start, end) {\n  var loweredCase = false\n\n  start = start | 0\n  end = end === undefined || end === Infinity ? this.length : end | 0\n\n  if (!encoding) encoding = 'utf8'\n  if (start < 0) start = 0\n  if (end > this.length) end = this.length\n  if (end <= start) return ''\n\n  while (true) {\n    switch (encoding) {\n      case 'hex':\n        return hexSlice(this, start, end)\n\n      case 'utf8':\n      case 'utf-8':\n        return utf8Slice(this, start, end)\n\n      case 'ascii':\n        return asciiSlice(this, start, end)\n\n      case 'binary':\n        return binarySlice(this, start, end)\n\n      case 'base64':\n        return base64Slice(this, start, end)\n\n      case 'ucs2':\n      case 'ucs-2':\n      case 'utf16le':\n      case 'utf-16le':\n        return utf16leSlice(this, start, end)\n\n      default:\n        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)\n        encoding = (encoding + '').toLowerCase()\n        loweredCase = true\n    }\n  }\n}\n\nBuffer.prototype.toString = function toString () {\n  var length = this.length | 0\n  if (length === 0) return ''\n  if (arguments.length === 0) return utf8Slice(this, 0, length)\n  return slowToString.apply(this, arguments)\n}\n\nBuffer.prototype.equals = function equals (b) {\n  if (!Buffer.isBuffer(b)) throw new TypeError('Argument must be a Buffer')\n  if (this === b) return true\n  return Buffer.compare(this, b) === 0\n}\n\nBuffer.prototype.inspect = function inspect () {\n  var str = ''\n  var max = exports.INSPECT_MAX_BYTES\n  if (this.length > 0) {\n    str = this.toString('hex', 0, max).match(/.{2}/g).join(' ')\n    if (this.length > max) str += ' ... '\n  }\n  return '<Buffer ' + str + '>'\n}\n\nBuffer.prototype.compare = function compare (b) {\n  if (!Buffer.isBuffer(b)) throw new TypeError('Argument must be a Buffer')\n  if (this === b) return 0\n  return Buffer.compare(this, b)\n}\n\nBuffer.prototype.indexOf = function indexOf (val, byteOffset) {\n  if (byteOffset > 0x7fffffff) byteOffset = 0x7fffffff\n  else if (byteOffset < -0x80000000) byteOffset = -0x80000000\n  byteOffset >>= 0\n\n  if (this.length === 0) return -1\n  if (byteOffset >= this.length) return -1\n\n  // Negative offsets start from the end of the buffer\n  if (byteOffset < 0) byteOffset = Math.max(this.length + byteOffset, 0)\n\n  if (typeof val === 'string') {\n    if (val.length === 0) return -1 // special case: looking for empty string always fails\n    return String.prototype.indexOf.call(this, val, byteOffset)\n  }\n  if (Buffer.isBuffer(val)) {\n    return arrayIndexOf(this, val, byteOffset)\n  }\n  if (typeof val === 'number') {\n    if (Buffer.TYPED_ARRAY_SUPPORT && Uint8Array.prototype.indexOf === 'function') {\n      return Uint8Array.prototype.indexOf.call(this, val, byteOffset)\n    }\n    return arrayIndexOf(this, [ val ], byteOffset)\n  }\n\n  function arrayIndexOf (arr, val, byteOffset) {\n    var foundIndex = -1\n    for (var i = 0; byteOffset + i < arr.length; i++) {\n      if (arr[byteOffset + i] === val[foundIndex === -1 ? 0 : i - foundIndex]) {\n        if (foundIndex === -1) foundIndex = i\n        if (i - foundIndex + 1 === val.length) return byteOffset + foundIndex\n      } else {\n        foundIndex = -1\n      }\n    }\n    return -1\n  }\n\n  throw new TypeError('val must be string, number or Buffer')\n}\n\n// `get` is deprecated\nBuffer.prototype.get = function get (offset) {\n  console.log('.get() is deprecated. Access using array indexes instead.')\n  return this.readUInt8(offset)\n}\n\n// `set` is deprecated\nBuffer.prototype.set = function set (v, offset) {\n  console.log('.set() is deprecated. Access using array indexes instead.')\n  return this.writeUInt8(v, offset)\n}\n\nfunction hexWrite (buf, string, offset, length) {\n  offset = Number(offset) || 0\n  var remaining = buf.length - offset\n  if (!length) {\n    length = remaining\n  } else {\n    length = Number(length)\n    if (length > remaining) {\n      length = remaining\n    }\n  }\n\n  // must be an even number of digits\n  var strLen = string.length\n  if (strLen % 2 !== 0) throw new Error('Invalid hex string')\n\n  if (length > strLen / 2) {\n    length = strLen / 2\n  }\n  for (var i = 0; i < length; i++) {\n    var parsed = parseInt(string.substr(i * 2, 2), 16)\n    if (isNaN(parsed)) throw new Error('Invalid hex string')\n    buf[offset + i] = parsed\n  }\n  return i\n}\n\nfunction utf8Write (buf, string, offset, length) {\n  return blitBuffer(utf8ToBytes(string, buf.length - offset), buf, offset, length)\n}\n\nfunction asciiWrite (buf, string, offset, length) {\n  return blitBuffer(asciiToBytes(string), buf, offset, length)\n}\n\nfunction binaryWrite (buf, string, offset, length) {\n  return asciiWrite(buf, string, offset, length)\n}\n\nfunction base64Write (buf, string, offset, length) {\n  return blitBuffer(base64ToBytes(string), buf, offset, length)\n}\n\nfunction ucs2Write (buf, string, offset, length) {\n  return blitBuffer(utf16leToBytes(string, buf.length - offset), buf, offset, length)\n}\n\nBuffer.prototype.write = function write (string, offset, length, encoding) {\n  // Buffer#write(string)\n  if (offset === undefined) {\n    encoding = 'utf8'\n    length = this.length\n    offset = 0\n  // Buffer#write(string, encoding)\n  } else if (length === undefined && typeof offset === 'string') {\n    encoding = offset\n    length = this.length\n    offset = 0\n  // Buffer#write(string, offset[, length][, encoding])\n  } else if (isFinite(offset)) {\n    offset = offset | 0\n    if (isFinite(length)) {\n      length = length | 0\n      if (encoding === undefined) encoding = 'utf8'\n    } else {\n      encoding = length\n      length = undefined\n    }\n  // legacy write(string, encoding, offset, length) - remove in v0.13\n  } else {\n    var swap = encoding\n    encoding = offset\n    offset = length | 0\n    length = swap\n  }\n\n  var remaining = this.length - offset\n  if (length === undefined || length > remaining) length = remaining\n\n  if ((string.length > 0 && (length < 0 || offset < 0)) || offset > this.length) {\n    throw new RangeError('attempt to write outside buffer bounds')\n  }\n\n  if (!encoding) encoding = 'utf8'\n\n  var loweredCase = false\n  for (;;) {\n    switch (encoding) {\n      case 'hex':\n        return hexWrite(this, string, offset, length)\n\n      case 'utf8':\n      case 'utf-8':\n        return utf8Write(this, string, offset, length)\n\n      case 'ascii':\n        return asciiWrite(this, string, offset, length)\n\n      case 'binary':\n        return binaryWrite(this, string, offset, length)\n\n      case 'base64':\n        // Warning: maxLength not taken into account in base64Write\n        return base64Write(this, string, offset, length)\n\n      case 'ucs2':\n      case 'ucs-2':\n      case 'utf16le':\n      case 'utf-16le':\n        return ucs2Write(this, string, offset, length)\n\n      default:\n        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)\n        encoding = ('' + encoding).toLowerCase()\n        loweredCase = true\n    }\n  }\n}\n\nBuffer.prototype.toJSON = function toJSON () {\n  return {\n    type: 'Buffer',\n    data: Array.prototype.slice.call(this._arr || this, 0)\n  }\n}\n\nfunction base64Slice (buf, start, end) {\n  if (start === 0 && end === buf.length) {\n    return base64.fromByteArray(buf)\n  } else {\n    return base64.fromByteArray(buf.slice(start, end))\n  }\n}\n\nfunction utf8Slice (buf, start, end) {\n  end = Math.min(buf.length, end)\n  var res = []\n\n  var i = start\n  while (i < end) {\n    var firstByte = buf[i]\n    var codePoint = null\n    var bytesPerSequence = (firstByte > 0xEF) ? 4\n      : (firstByte > 0xDF) ? 3\n      : (firstByte > 0xBF) ? 2\n      : 1\n\n    if (i + bytesPerSequence <= end) {\n      var secondByte, thirdByte, fourthByte, tempCodePoint\n\n      switch (bytesPerSequence) {\n        case 1:\n          if (firstByte < 0x80) {\n            codePoint = firstByte\n          }\n          break\n        case 2:\n          secondByte = buf[i + 1]\n          if ((secondByte & 0xC0) === 0x80) {\n            tempCodePoint = (firstByte & 0x1F) << 0x6 | (secondByte & 0x3F)\n            if (tempCodePoint > 0x7F) {\n              codePoint = tempCodePoint\n            }\n          }\n          break\n        case 3:\n          secondByte = buf[i + 1]\n          thirdByte = buf[i + 2]\n          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80) {\n            tempCodePoint = (firstByte & 0xF) << 0xC | (secondByte & 0x3F) << 0x6 | (thirdByte & 0x3F)\n            if (tempCodePoint > 0x7FF && (tempCodePoint < 0xD800 || tempCodePoint > 0xDFFF)) {\n              codePoint = tempCodePoint\n            }\n          }\n          break\n        case 4:\n          secondByte = buf[i + 1]\n          thirdByte = buf[i + 2]\n          fourthByte = buf[i + 3]\n          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80 && (fourthByte & 0xC0) === 0x80) {\n            tempCodePoint = (firstByte & 0xF) << 0x12 | (secondByte & 0x3F) << 0xC | (thirdByte & 0x3F) << 0x6 | (fourthByte & 0x3F)\n            if (tempCodePoint > 0xFFFF && tempCodePoint < 0x110000) {\n              codePoint = tempCodePoint\n            }\n          }\n      }\n    }\n\n    if (codePoint === null) {\n      // we did not generate a valid codePoint so insert a\n      // replacement char (U+FFFD) and advance only 1 byte\n      codePoint = 0xFFFD\n      bytesPerSequence = 1\n    } else if (codePoint > 0xFFFF) {\n      // encode to utf16 (surrogate pair dance)\n      codePoint -= 0x10000\n      res.push(codePoint >>> 10 & 0x3FF | 0xD800)\n      codePoint = 0xDC00 | codePoint & 0x3FF\n    }\n\n    res.push(codePoint)\n    i += bytesPerSequence\n  }\n\n  return decodeCodePointsArray(res)\n}\n\n// Based on http://stackoverflow.com/a/22747272/680742, the browser with\n// the lowest limit is Chrome, with 0x10000 args.\n// We go 1 magnitude less, for safety\nvar MAX_ARGUMENTS_LENGTH = 0x1000\n\nfunction decodeCodePointsArray (codePoints) {\n  var len = codePoints.length\n  if (len <= MAX_ARGUMENTS_LENGTH) {\n    return String.fromCharCode.apply(String, codePoints) // avoid extra slice()\n  }\n\n  // Decode in chunks to avoid \"call stack size exceeded\".\n  var res = ''\n  var i = 0\n  while (i < len) {\n    res += String.fromCharCode.apply(\n      String,\n      codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH)\n    )\n  }\n  return res\n}\n\nfunction asciiSlice (buf, start, end) {\n  var ret = ''\n  end = Math.min(buf.length, end)\n\n  for (var i = start; i < end; i++) {\n    ret += String.fromCharCode(buf[i] & 0x7F)\n  }\n  return ret\n}\n\nfunction binarySlice (buf, start, end) {\n  var ret = ''\n  end = Math.min(buf.length, end)\n\n  for (var i = start; i < end; i++) {\n    ret += String.fromCharCode(buf[i])\n  }\n  return ret\n}\n\nfunction hexSlice (buf, start, end) {\n  var len = buf.length\n\n  if (!start || start < 0) start = 0\n  if (!end || end < 0 || end > len) end = len\n\n  var out = ''\n  for (var i = start; i < end; i++) {\n    out += toHex(buf[i])\n  }\n  return out\n}\n\nfunction utf16leSlice (buf, start, end) {\n  var bytes = buf.slice(start, end)\n  var res = ''\n  for (var i = 0; i < bytes.length; i += 2) {\n    res += String.fromCharCode(bytes[i] + bytes[i + 1] * 256)\n  }\n  return res\n}\n\nBuffer.prototype.slice = function slice (start, end) {\n  var len = this.length\n  start = ~~start\n  end = end === undefined ? len : ~~end\n\n  if (start < 0) {\n    start += len\n    if (start < 0) start = 0\n  } else if (start > len) {\n    start = len\n  }\n\n  if (end < 0) {\n    end += len\n    if (end < 0) end = 0\n  } else if (end > len) {\n    end = len\n  }\n\n  if (end < start) end = start\n\n  var newBuf\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    newBuf = Buffer._augment(this.subarray(start, end))\n  } else {\n    var sliceLen = end - start\n    newBuf = new Buffer(sliceLen, undefined)\n    for (var i = 0; i < sliceLen; i++) {\n      newBuf[i] = this[i + start]\n    }\n  }\n\n  if (newBuf.length) newBuf.parent = this.parent || this\n\n  return newBuf\n}\n\n/*\n * Need to make sure that buffer isn't trying to write out of bounds.\n */\nfunction checkOffset (offset, ext, length) {\n  if ((offset % 1) !== 0 || offset < 0) throw new RangeError('offset is not uint')\n  if (offset + ext > length) throw new RangeError('Trying to access beyond buffer length')\n}\n\nBuffer.prototype.readUIntLE = function readUIntLE (offset, byteLength, noAssert) {\n  offset = offset | 0\n  byteLength = byteLength | 0\n  if (!noAssert) checkOffset(offset, byteLength, this.length)\n\n  var val = this[offset]\n  var mul = 1\n  var i = 0\n  while (++i < byteLength && (mul *= 0x100)) {\n    val += this[offset + i] * mul\n  }\n\n  return val\n}\n\nBuffer.prototype.readUIntBE = function readUIntBE (offset, byteLength, noAssert) {\n  offset = offset | 0\n  byteLength = byteLength | 0\n  if (!noAssert) {\n    checkOffset(offset, byteLength, this.length)\n  }\n\n  var val = this[offset + --byteLength]\n  var mul = 1\n  while (byteLength > 0 && (mul *= 0x100)) {\n    val += this[offset + --byteLength] * mul\n  }\n\n  return val\n}\n\nBuffer.prototype.readUInt8 = function readUInt8 (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 1, this.length)\n  return this[offset]\n}\n\nBuffer.prototype.readUInt16LE = function readUInt16LE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 2, this.length)\n  return this[offset] | (this[offset + 1] << 8)\n}\n\nBuffer.prototype.readUInt16BE = function readUInt16BE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 2, this.length)\n  return (this[offset] << 8) | this[offset + 1]\n}\n\nBuffer.prototype.readUInt32LE = function readUInt32LE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 4, this.length)\n\n  return ((this[offset]) |\n      (this[offset + 1] << 8) |\n      (this[offset + 2] << 16)) +\n      (this[offset + 3] * 0x1000000)\n}\n\nBuffer.prototype.readUInt32BE = function readUInt32BE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 4, this.length)\n\n  return (this[offset] * 0x1000000) +\n    ((this[offset + 1] << 16) |\n    (this[offset + 2] << 8) |\n    this[offset + 3])\n}\n\nBuffer.prototype.readIntLE = function readIntLE (offset, byteLength, noAssert) {\n  offset = offset | 0\n  byteLength = byteLength | 0\n  if (!noAssert) checkOffset(offset, byteLength, this.length)\n\n  var val = this[offset]\n  var mul = 1\n  var i = 0\n  while (++i < byteLength && (mul *= 0x100)) {\n    val += this[offset + i] * mul\n  }\n  mul *= 0x80\n\n  if (val >= mul) val -= Math.pow(2, 8 * byteLength)\n\n  return val\n}\n\nBuffer.prototype.readIntBE = function readIntBE (offset, byteLength, noAssert) {\n  offset = offset | 0\n  byteLength = byteLength | 0\n  if (!noAssert) checkOffset(offset, byteLength, this.length)\n\n  var i = byteLength\n  var mul = 1\n  var val = this[offset + --i]\n  while (i > 0 && (mul *= 0x100)) {\n    val += this[offset + --i] * mul\n  }\n  mul *= 0x80\n\n  if (val >= mul) val -= Math.pow(2, 8 * byteLength)\n\n  return val\n}\n\nBuffer.prototype.readInt8 = function readInt8 (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 1, this.length)\n  if (!(this[offset] & 0x80)) return (this[offset])\n  return ((0xff - this[offset] + 1) * -1)\n}\n\nBuffer.prototype.readInt16LE = function readInt16LE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 2, this.length)\n  var val = this[offset] | (this[offset + 1] << 8)\n  return (val & 0x8000) ? val | 0xFFFF0000 : val\n}\n\nBuffer.prototype.readInt16BE = function readInt16BE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 2, this.length)\n  var val = this[offset + 1] | (this[offset] << 8)\n  return (val & 0x8000) ? val | 0xFFFF0000 : val\n}\n\nBuffer.prototype.readInt32LE = function readInt32LE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 4, this.length)\n\n  return (this[offset]) |\n    (this[offset + 1] << 8) |\n    (this[offset + 2] << 16) |\n    (this[offset + 3] << 24)\n}\n\nBuffer.prototype.readInt32BE = function readInt32BE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 4, this.length)\n\n  return (this[offset] << 24) |\n    (this[offset + 1] << 16) |\n    (this[offset + 2] << 8) |\n    (this[offset + 3])\n}\n\nBuffer.prototype.readFloatLE = function readFloatLE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 4, this.length)\n  return ieee754.read(this, offset, true, 23, 4)\n}\n\nBuffer.prototype.readFloatBE = function readFloatBE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 4, this.length)\n  return ieee754.read(this, offset, false, 23, 4)\n}\n\nBuffer.prototype.readDoubleLE = function readDoubleLE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 8, this.length)\n  return ieee754.read(this, offset, true, 52, 8)\n}\n\nBuffer.prototype.readDoubleBE = function readDoubleBE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 8, this.length)\n  return ieee754.read(this, offset, false, 52, 8)\n}\n\nfunction checkInt (buf, value, offset, ext, max, min) {\n  if (!Buffer.isBuffer(buf)) throw new TypeError('buffer must be a Buffer instance')\n  if (value > max || value < min) throw new RangeError('value is out of bounds')\n  if (offset + ext > buf.length) throw new RangeError('index out of range')\n}\n\nBuffer.prototype.writeUIntLE = function writeUIntLE (value, offset, byteLength, noAssert) {\n  value = +value\n  offset = offset | 0\n  byteLength = byteLength | 0\n  if (!noAssert) checkInt(this, value, offset, byteLength, Math.pow(2, 8 * byteLength), 0)\n\n  var mul = 1\n  var i = 0\n  this[offset] = value & 0xFF\n  while (++i < byteLength && (mul *= 0x100)) {\n    this[offset + i] = (value / mul) & 0xFF\n  }\n\n  return offset + byteLength\n}\n\nBuffer.prototype.writeUIntBE = function writeUIntBE (value, offset, byteLength, noAssert) {\n  value = +value\n  offset = offset | 0\n  byteLength = byteLength | 0\n  if (!noAssert) checkInt(this, value, offset, byteLength, Math.pow(2, 8 * byteLength), 0)\n\n  var i = byteLength - 1\n  var mul = 1\n  this[offset + i] = value & 0xFF\n  while (--i >= 0 && (mul *= 0x100)) {\n    this[offset + i] = (value / mul) & 0xFF\n  }\n\n  return offset + byteLength\n}\n\nBuffer.prototype.writeUInt8 = function writeUInt8 (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 1, 0xff, 0)\n  if (!Buffer.TYPED_ARRAY_SUPPORT) value = Math.floor(value)\n  this[offset] = (value & 0xff)\n  return offset + 1\n}\n\nfunction objectWriteUInt16 (buf, value, offset, littleEndian) {\n  if (value < 0) value = 0xffff + value + 1\n  for (var i = 0, j = Math.min(buf.length - offset, 2); i < j; i++) {\n    buf[offset + i] = (value & (0xff << (8 * (littleEndian ? i : 1 - i)))) >>>\n      (littleEndian ? i : 1 - i) * 8\n  }\n}\n\nBuffer.prototype.writeUInt16LE = function writeUInt16LE (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    this[offset] = (value & 0xff)\n    this[offset + 1] = (value >>> 8)\n  } else {\n    objectWriteUInt16(this, value, offset, true)\n  }\n  return offset + 2\n}\n\nBuffer.prototype.writeUInt16BE = function writeUInt16BE (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    this[offset] = (value >>> 8)\n    this[offset + 1] = (value & 0xff)\n  } else {\n    objectWriteUInt16(this, value, offset, false)\n  }\n  return offset + 2\n}\n\nfunction objectWriteUInt32 (buf, value, offset, littleEndian) {\n  if (value < 0) value = 0xffffffff + value + 1\n  for (var i = 0, j = Math.min(buf.length - offset, 4); i < j; i++) {\n    buf[offset + i] = (value >>> (littleEndian ? i : 3 - i) * 8) & 0xff\n  }\n}\n\nBuffer.prototype.writeUInt32LE = function writeUInt32LE (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    this[offset + 3] = (value >>> 24)\n    this[offset + 2] = (value >>> 16)\n    this[offset + 1] = (value >>> 8)\n    this[offset] = (value & 0xff)\n  } else {\n    objectWriteUInt32(this, value, offset, true)\n  }\n  return offset + 4\n}\n\nBuffer.prototype.writeUInt32BE = function writeUInt32BE (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    this[offset] = (value >>> 24)\n    this[offset + 1] = (value >>> 16)\n    this[offset + 2] = (value >>> 8)\n    this[offset + 3] = (value & 0xff)\n  } else {\n    objectWriteUInt32(this, value, offset, false)\n  }\n  return offset + 4\n}\n\nBuffer.prototype.writeIntLE = function writeIntLE (value, offset, byteLength, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) {\n    var limit = Math.pow(2, 8 * byteLength - 1)\n\n    checkInt(this, value, offset, byteLength, limit - 1, -limit)\n  }\n\n  var i = 0\n  var mul = 1\n  var sub = value < 0 ? 1 : 0\n  this[offset] = value & 0xFF\n  while (++i < byteLength && (mul *= 0x100)) {\n    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF\n  }\n\n  return offset + byteLength\n}\n\nBuffer.prototype.writeIntBE = function writeIntBE (value, offset, byteLength, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) {\n    var limit = Math.pow(2, 8 * byteLength - 1)\n\n    checkInt(this, value, offset, byteLength, limit - 1, -limit)\n  }\n\n  var i = byteLength - 1\n  var mul = 1\n  var sub = value < 0 ? 1 : 0\n  this[offset + i] = value & 0xFF\n  while (--i >= 0 && (mul *= 0x100)) {\n    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF\n  }\n\n  return offset + byteLength\n}\n\nBuffer.prototype.writeInt8 = function writeInt8 (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 1, 0x7f, -0x80)\n  if (!Buffer.TYPED_ARRAY_SUPPORT) value = Math.floor(value)\n  if (value < 0) value = 0xff + value + 1\n  this[offset] = (value & 0xff)\n  return offset + 1\n}\n\nBuffer.prototype.writeInt16LE = function writeInt16LE (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    this[offset] = (value & 0xff)\n    this[offset + 1] = (value >>> 8)\n  } else {\n    objectWriteUInt16(this, value, offset, true)\n  }\n  return offset + 2\n}\n\nBuffer.prototype.writeInt16BE = function writeInt16BE (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    this[offset] = (value >>> 8)\n    this[offset + 1] = (value & 0xff)\n  } else {\n    objectWriteUInt16(this, value, offset, false)\n  }\n  return offset + 2\n}\n\nBuffer.prototype.writeInt32LE = function writeInt32LE (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    this[offset] = (value & 0xff)\n    this[offset + 1] = (value >>> 8)\n    this[offset + 2] = (value >>> 16)\n    this[offset + 3] = (value >>> 24)\n  } else {\n    objectWriteUInt32(this, value, offset, true)\n  }\n  return offset + 4\n}\n\nBuffer.prototype.writeInt32BE = function writeInt32BE (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)\n  if (value < 0) value = 0xffffffff + value + 1\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    this[offset] = (value >>> 24)\n    this[offset + 1] = (value >>> 16)\n    this[offset + 2] = (value >>> 8)\n    this[offset + 3] = (value & 0xff)\n  } else {\n    objectWriteUInt32(this, value, offset, false)\n  }\n  return offset + 4\n}\n\nfunction checkIEEE754 (buf, value, offset, ext, max, min) {\n  if (value > max || value < min) throw new RangeError('value is out of bounds')\n  if (offset + ext > buf.length) throw new RangeError('index out of range')\n  if (offset < 0) throw new RangeError('index out of range')\n}\n\nfunction writeFloat (buf, value, offset, littleEndian, noAssert) {\n  if (!noAssert) {\n    checkIEEE754(buf, value, offset, 4, 3.4028234663852886e+38, -3.4028234663852886e+38)\n  }\n  ieee754.write(buf, value, offset, littleEndian, 23, 4)\n  return offset + 4\n}\n\nBuffer.prototype.writeFloatLE = function writeFloatLE (value, offset, noAssert) {\n  return writeFloat(this, value, offset, true, noAssert)\n}\n\nBuffer.prototype.writeFloatBE = function writeFloatBE (value, offset, noAssert) {\n  return writeFloat(this, value, offset, false, noAssert)\n}\n\nfunction writeDouble (buf, value, offset, littleEndian, noAssert) {\n  if (!noAssert) {\n    checkIEEE754(buf, value, offset, 8, 1.7976931348623157E+308, -1.7976931348623157E+308)\n  }\n  ieee754.write(buf, value, offset, littleEndian, 52, 8)\n  return offset + 8\n}\n\nBuffer.prototype.writeDoubleLE = function writeDoubleLE (value, offset, noAssert) {\n  return writeDouble(this, value, offset, true, noAssert)\n}\n\nBuffer.prototype.writeDoubleBE = function writeDoubleBE (value, offset, noAssert) {\n  return writeDouble(this, value, offset, false, noAssert)\n}\n\n// copy(targetBuffer, targetStart=0, sourceStart=0, sourceEnd=buffer.length)\nBuffer.prototype.copy = function copy (target, targetStart, start, end) {\n  if (!start) start = 0\n  if (!end && end !== 0) end = this.length\n  if (targetStart >= target.length) targetStart = target.length\n  if (!targetStart) targetStart = 0\n  if (end > 0 && end < start) end = start\n\n  // Copy 0 bytes; we're done\n  if (end === start) return 0\n  if (target.length === 0 || this.length === 0) return 0\n\n  // Fatal error conditions\n  if (targetStart < 0) {\n    throw new RangeError('targetStart out of bounds')\n  }\n  if (start < 0 || start >= this.length) throw new RangeError('sourceStart out of bounds')\n  if (end < 0) throw new RangeError('sourceEnd out of bounds')\n\n  // Are we oob?\n  if (end > this.length) end = this.length\n  if (target.length - targetStart < end - start) {\n    end = target.length - targetStart + start\n  }\n\n  var len = end - start\n  var i\n\n  if (this === target && start < targetStart && targetStart < end) {\n    // descending copy from end\n    for (i = len - 1; i >= 0; i--) {\n      target[i + targetStart] = this[i + start]\n    }\n  } else if (len < 1000 || !Buffer.TYPED_ARRAY_SUPPORT) {\n    // ascending copy from start\n    for (i = 0; i < len; i++) {\n      target[i + targetStart] = this[i + start]\n    }\n  } else {\n    target._set(this.subarray(start, start + len), targetStart)\n  }\n\n  return len\n}\n\n// fill(value, start=0, end=buffer.length)\nBuffer.prototype.fill = function fill (value, start, end) {\n  if (!value) value = 0\n  if (!start) start = 0\n  if (!end) end = this.length\n\n  if (end < start) throw new RangeError('end < start')\n\n  // Fill 0 bytes; we're done\n  if (end === start) return\n  if (this.length === 0) return\n\n  if (start < 0 || start >= this.length) throw new RangeError('start out of bounds')\n  if (end < 0 || end > this.length) throw new RangeError('end out of bounds')\n\n  var i\n  if (typeof value === 'number') {\n    for (i = start; i < end; i++) {\n      this[i] = value\n    }\n  } else {\n    var bytes = utf8ToBytes(value.toString())\n    var len = bytes.length\n    for (i = start; i < end; i++) {\n      this[i] = bytes[i % len]\n    }\n  }\n\n  return this\n}\n\n/**\n * Creates a new `ArrayBuffer` with the *copied* memory of the buffer instance.\n * Added in Node 0.12. Only available in browsers that support ArrayBuffer.\n */\nBuffer.prototype.toArrayBuffer = function toArrayBuffer () {\n  if (typeof Uint8Array !== 'undefined') {\n    if (Buffer.TYPED_ARRAY_SUPPORT) {\n      return (new Buffer(this)).buffer\n    } else {\n      var buf = new Uint8Array(this.length)\n      for (var i = 0, len = buf.length; i < len; i += 1) {\n        buf[i] = this[i]\n      }\n      return buf.buffer\n    }\n  } else {\n    throw new TypeError('Buffer.toArrayBuffer not supported in this browser')\n  }\n}\n\n// HELPER FUNCTIONS\n// ================\n\nvar BP = Buffer.prototype\n\n/**\n * Augment a Uint8Array *instance* (not the Uint8Array class!) with Buffer methods\n */\nBuffer._augment = function _augment (arr) {\n  arr.constructor = Buffer\n  arr._isBuffer = true\n\n  // save reference to original Uint8Array set method before overwriting\n  arr._set = arr.set\n\n  // deprecated\n  arr.get = BP.get\n  arr.set = BP.set\n\n  arr.write = BP.write\n  arr.toString = BP.toString\n  arr.toLocaleString = BP.toString\n  arr.toJSON = BP.toJSON\n  arr.equals = BP.equals\n  arr.compare = BP.compare\n  arr.indexOf = BP.indexOf\n  arr.copy = BP.copy\n  arr.slice = BP.slice\n  arr.readUIntLE = BP.readUIntLE\n  arr.readUIntBE = BP.readUIntBE\n  arr.readUInt8 = BP.readUInt8\n  arr.readUInt16LE = BP.readUInt16LE\n  arr.readUInt16BE = BP.readUInt16BE\n  arr.readUInt32LE = BP.readUInt32LE\n  arr.readUInt32BE = BP.readUInt32BE\n  arr.readIntLE = BP.readIntLE\n  arr.readIntBE = BP.readIntBE\n  arr.readInt8 = BP.readInt8\n  arr.readInt16LE = BP.readInt16LE\n  arr.readInt16BE = BP.readInt16BE\n  arr.readInt32LE = BP.readInt32LE\n  arr.readInt32BE = BP.readInt32BE\n  arr.readFloatLE = BP.readFloatLE\n  arr.readFloatBE = BP.readFloatBE\n  arr.readDoubleLE = BP.readDoubleLE\n  arr.readDoubleBE = BP.readDoubleBE\n  arr.writeUInt8 = BP.writeUInt8\n  arr.writeUIntLE = BP.writeUIntLE\n  arr.writeUIntBE = BP.writeUIntBE\n  arr.writeUInt16LE = BP.writeUInt16LE\n  arr.writeUInt16BE = BP.writeUInt16BE\n  arr.writeUInt32LE = BP.writeUInt32LE\n  arr.writeUInt32BE = BP.writeUInt32BE\n  arr.writeIntLE = BP.writeIntLE\n  arr.writeIntBE = BP.writeIntBE\n  arr.writeInt8 = BP.writeInt8\n  arr.writeInt16LE = BP.writeInt16LE\n  arr.writeInt16BE = BP.writeInt16BE\n  arr.writeInt32LE = BP.writeInt32LE\n  arr.writeInt32BE = BP.writeInt32BE\n  arr.writeFloatLE = BP.writeFloatLE\n  arr.writeFloatBE = BP.writeFloatBE\n  arr.writeDoubleLE = BP.writeDoubleLE\n  arr.writeDoubleBE = BP.writeDoubleBE\n  arr.fill = BP.fill\n  arr.inspect = BP.inspect\n  arr.toArrayBuffer = BP.toArrayBuffer\n\n  return arr\n}\n\nvar INVALID_BASE64_RE = /[^+\\/0-9A-Za-z-_]/g\n\nfunction base64clean (str) {\n  // Node strips out invalid characters like \\n and \\t from the string, base64-js does not\n  str = stringtrim(str).replace(INVALID_BASE64_RE, '')\n  // Node converts strings with length < 2 to ''\n  if (str.length < 2) return ''\n  // Node allows for non-padded base64 strings (missing trailing ===), base64-js does not\n  while (str.length % 4 !== 0) {\n    str = str + '='\n  }\n  return str\n}\n\nfunction stringtrim (str) {\n  if (str.trim) return str.trim()\n  return str.replace(/^\\s+|\\s+$/g, '')\n}\n\nfunction toHex (n) {\n  if (n < 16) return '0' + n.toString(16)\n  return n.toString(16)\n}\n\nfunction utf8ToBytes (string, units) {\n  units = units || Infinity\n  var codePoint\n  var length = string.length\n  var leadSurrogate = null\n  var bytes = []\n\n  for (var i = 0; i < length; i++) {\n    codePoint = string.charCodeAt(i)\n\n    // is surrogate component\n    if (codePoint > 0xD7FF && codePoint < 0xE000) {\n      // last char was a lead\n      if (!leadSurrogate) {\n        // no lead yet\n        if (codePoint > 0xDBFF) {\n          // unexpected trail\n          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)\n          continue\n        } else if (i + 1 === length) {\n          // unpaired lead\n          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)\n          continue\n        }\n\n        // valid lead\n        leadSurrogate = codePoint\n\n        continue\n      }\n\n      // 2 leads in a row\n      if (codePoint < 0xDC00) {\n        if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)\n        leadSurrogate = codePoint\n        continue\n      }\n\n      // valid surrogate pair\n      codePoint = (leadSurrogate - 0xD800 << 10 | codePoint - 0xDC00) + 0x10000\n    } else if (leadSurrogate) {\n      // valid bmp char, but last char was a lead\n      if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)\n    }\n\n    leadSurrogate = null\n\n    // encode utf8\n    if (codePoint < 0x80) {\n      if ((units -= 1) < 0) break\n      bytes.push(codePoint)\n    } else if (codePoint < 0x800) {\n      if ((units -= 2) < 0) break\n      bytes.push(\n        codePoint >> 0x6 | 0xC0,\n        codePoint & 0x3F | 0x80\n      )\n    } else if (codePoint < 0x10000) {\n      if ((units -= 3) < 0) break\n      bytes.push(\n        codePoint >> 0xC | 0xE0,\n        codePoint >> 0x6 & 0x3F | 0x80,\n        codePoint & 0x3F | 0x80\n      )\n    } else if (codePoint < 0x110000) {\n      if ((units -= 4) < 0) break\n      bytes.push(\n        codePoint >> 0x12 | 0xF0,\n        codePoint >> 0xC & 0x3F | 0x80,\n        codePoint >> 0x6 & 0x3F | 0x80,\n        codePoint & 0x3F | 0x80\n      )\n    } else {\n      throw new Error('Invalid code point')\n    }\n  }\n\n  return bytes\n}\n\nfunction asciiToBytes (str) {\n  var byteArray = []\n  for (var i = 0; i < str.length; i++) {\n    // Node's code seems to be doing this and not & 0x7F..\n    byteArray.push(str.charCodeAt(i) & 0xFF)\n  }\n  return byteArray\n}\n\nfunction utf16leToBytes (str, units) {\n  var c, hi, lo\n  var byteArray = []\n  for (var i = 0; i < str.length; i++) {\n    if ((units -= 2) < 0) break\n\n    c = str.charCodeAt(i)\n    hi = c >> 8\n    lo = c % 256\n    byteArray.push(lo)\n    byteArray.push(hi)\n  }\n\n  return byteArray\n}\n\nfunction base64ToBytes (str) {\n  return base64.toByteArray(base64clean(str))\n}\n\nfunction blitBuffer (src, dst, offset, length) {\n  for (var i = 0; i < length; i++) {\n    if ((i + offset >= dst.length) || (i >= src.length)) break\n    dst[i + offset] = src[i]\n  }\n  return i\n}\n","var lookup = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';\n\n;(function (exports) {\n\t'use strict';\n\n  var Arr = (typeof Uint8Array !== 'undefined')\n    ? Uint8Array\n    : Array\n\n\tvar PLUS   = '+'.charCodeAt(0)\n\tvar SLASH  = '/'.charCodeAt(0)\n\tvar NUMBER = '0'.charCodeAt(0)\n\tvar LOWER  = 'a'.charCodeAt(0)\n\tvar UPPER  = 'A'.charCodeAt(0)\n\tvar PLUS_URL_SAFE = '-'.charCodeAt(0)\n\tvar SLASH_URL_SAFE = '_'.charCodeAt(0)\n\n\tfunction decode (elt) {\n\t\tvar code = elt.charCodeAt(0)\n\t\tif (code === PLUS ||\n\t\t    code === PLUS_URL_SAFE)\n\t\t\treturn 62 // '+'\n\t\tif (code === SLASH ||\n\t\t    code === SLASH_URL_SAFE)\n\t\t\treturn 63 // '/'\n\t\tif (code < NUMBER)\n\t\t\treturn -1 //no match\n\t\tif (code < NUMBER + 10)\n\t\t\treturn code - NUMBER + 26 + 26\n\t\tif (code < UPPER + 26)\n\t\t\treturn code - UPPER\n\t\tif (code < LOWER + 26)\n\t\t\treturn code - LOWER + 26\n\t}\n\n\tfunction b64ToByteArray (b64) {\n\t\tvar i, j, l, tmp, placeHolders, arr\n\n\t\tif (b64.length % 4 > 0) {\n\t\t\tthrow new Error('Invalid string. Length must be a multiple of 4')\n\t\t}\n\n\t\t// the number of equal signs (place holders)\n\t\t// if there are two placeholders, than the two characters before it\n\t\t// represent one byte\n\t\t// if there is only one, then the three characters before it represent 2 bytes\n\t\t// this is just a cheap hack to not do indexOf twice\n\t\tvar len = b64.length\n\t\tplaceHolders = '=' === b64.charAt(len - 2) ? 2 : '=' === b64.charAt(len - 1) ? 1 : 0\n\n\t\t// base64 is 4/3 + up to two characters of the original data\n\t\tarr = new Arr(b64.length * 3 / 4 - placeHolders)\n\n\t\t// if there are placeholders, only get up to the last complete 4 chars\n\t\tl = placeHolders > 0 ? b64.length - 4 : b64.length\n\n\t\tvar L = 0\n\n\t\tfunction push (v) {\n\t\t\tarr[L++] = v\n\t\t}\n\n\t\tfor (i = 0, j = 0; i < l; i += 4, j += 3) {\n\t\t\ttmp = (decode(b64.charAt(i)) << 18) | (decode(b64.charAt(i + 1)) << 12) | (decode(b64.charAt(i + 2)) << 6) | decode(b64.charAt(i + 3))\n\t\t\tpush((tmp & 0xFF0000) >> 16)\n\t\t\tpush((tmp & 0xFF00) >> 8)\n\t\t\tpush(tmp & 0xFF)\n\t\t}\n\n\t\tif (placeHolders === 2) {\n\t\t\ttmp = (decode(b64.charAt(i)) << 2) | (decode(b64.charAt(i + 1)) >> 4)\n\t\t\tpush(tmp & 0xFF)\n\t\t} else if (placeHolders === 1) {\n\t\t\ttmp = (decode(b64.charAt(i)) << 10) | (decode(b64.charAt(i + 1)) << 4) | (decode(b64.charAt(i + 2)) >> 2)\n\t\t\tpush((tmp >> 8) & 0xFF)\n\t\t\tpush(tmp & 0xFF)\n\t\t}\n\n\t\treturn arr\n\t}\n\n\tfunction uint8ToBase64 (uint8) {\n\t\tvar i,\n\t\t\textraBytes = uint8.length % 3, // if we have 1 byte left, pad 2 bytes\n\t\t\toutput = \"\",\n\t\t\ttemp, length\n\n\t\tfunction encode (num) {\n\t\t\treturn lookup.charAt(num)\n\t\t}\n\n\t\tfunction tripletToBase64 (num) {\n\t\t\treturn encode(num >> 18 & 0x3F) + encode(num >> 12 & 0x3F) + encode(num >> 6 & 0x3F) + encode(num & 0x3F)\n\t\t}\n\n\t\t// go through the array every three bytes, we'll deal with trailing stuff later\n\t\tfor (i = 0, length = uint8.length - extraBytes; i < length; i += 3) {\n\t\t\ttemp = (uint8[i] << 16) + (uint8[i + 1] << 8) + (uint8[i + 2])\n\t\t\toutput += tripletToBase64(temp)\n\t\t}\n\n\t\t// pad the end with zeros, but make sure to not forget the extra bytes\n\t\tswitch (extraBytes) {\n\t\t\tcase 1:\n\t\t\t\ttemp = uint8[uint8.length - 1]\n\t\t\t\toutput += encode(temp >> 2)\n\t\t\t\toutput += encode((temp << 4) & 0x3F)\n\t\t\t\toutput += '=='\n\t\t\t\tbreak\n\t\t\tcase 2:\n\t\t\t\ttemp = (uint8[uint8.length - 2] << 8) + (uint8[uint8.length - 1])\n\t\t\t\toutput += encode(temp >> 10)\n\t\t\t\toutput += encode((temp >> 4) & 0x3F)\n\t\t\t\toutput += encode((temp << 2) & 0x3F)\n\t\t\t\toutput += '='\n\t\t\t\tbreak\n\t\t}\n\n\t\treturn output\n\t}\n\n\texports.toByteArray = b64ToByteArray\n\texports.fromByteArray = uint8ToBase64\n}(typeof exports === 'undefined' ? (this.base64js = {}) : exports))\n","exports.read = function (buffer, offset, isLE, mLen, nBytes) {\n  var e, m\n  var eLen = nBytes * 8 - mLen - 1\n  var eMax = (1 << eLen) - 1\n  var eBias = eMax >> 1\n  var nBits = -7\n  var i = isLE ? (nBytes - 1) : 0\n  var d = isLE ? -1 : 1\n  var s = buffer[offset + i]\n\n  i += d\n\n  e = s & ((1 << (-nBits)) - 1)\n  s >>= (-nBits)\n  nBits += eLen\n  for (; nBits > 0; e = e * 256 + buffer[offset + i], i += d, nBits -= 8) {}\n\n  m = e & ((1 << (-nBits)) - 1)\n  e >>= (-nBits)\n  nBits += mLen\n  for (; nBits > 0; m = m * 256 + buffer[offset + i], i += d, nBits -= 8) {}\n\n  if (e === 0) {\n    e = 1 - eBias\n  } else if (e === eMax) {\n    return m ? NaN : ((s ? -1 : 1) * Infinity)\n  } else {\n    m = m + Math.pow(2, mLen)\n    e = e - eBias\n  }\n  return (s ? -1 : 1) * m * Math.pow(2, e - mLen)\n}\n\nexports.write = function (buffer, value, offset, isLE, mLen, nBytes) {\n  var e, m, c\n  var eLen = nBytes * 8 - mLen - 1\n  var eMax = (1 << eLen) - 1\n  var eBias = eMax >> 1\n  var rt = (mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0)\n  var i = isLE ? 0 : (nBytes - 1)\n  var d = isLE ? 1 : -1\n  var s = value < 0 || (value === 0 && 1 / value < 0) ? 1 : 0\n\n  value = Math.abs(value)\n\n  if (isNaN(value) || value === Infinity) {\n    m = isNaN(value) ? 1 : 0\n    e = eMax\n  } else {\n    e = Math.floor(Math.log(value) / Math.LN2)\n    if (value * (c = Math.pow(2, -e)) < 1) {\n      e--\n      c *= 2\n    }\n    if (e + eBias >= 1) {\n      value += rt / c\n    } else {\n      value += rt * Math.pow(2, 1 - eBias)\n    }\n    if (value * c >= 2) {\n      e++\n      c /= 2\n    }\n\n    if (e + eBias >= eMax) {\n      m = 0\n      e = eMax\n    } else if (e + eBias >= 1) {\n      m = (value * c - 1) * Math.pow(2, mLen)\n      e = e + eBias\n    } else {\n      m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen)\n      e = 0\n    }\n  }\n\n  for (; mLen >= 8; buffer[offset + i] = m & 0xff, i += d, m /= 256, mLen -= 8) {}\n\n  e = (e << mLen) | m\n  eLen += mLen\n  for (; eLen > 0; buffer[offset + i] = e & 0xff, i += d, e /= 256, eLen -= 8) {}\n\n  buffer[offset + i - d] |= s * 128\n}\n","var toString = {}.toString;\n\nmodule.exports = Array.isArray || function (arr) {\n  return toString.call(arr) == '[object Array]';\n};\n","// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\nfunction EventEmitter() {\n  this._events = this._events || {};\n  this._maxListeners = this._maxListeners || undefined;\n}\nmodule.exports = EventEmitter;\n\n// Backwards-compat with node 0.10.x\nEventEmitter.EventEmitter = EventEmitter;\n\nEventEmitter.prototype._events = undefined;\nEventEmitter.prototype._maxListeners = undefined;\n\n// By default EventEmitters will print a warning if more than 10 listeners are\n// added to it. This is a useful default which helps finding memory leaks.\nEventEmitter.defaultMaxListeners = 10;\n\n// Obviously not all Emitters should be limited to 10. This function allows\n// that to be increased. Set to zero for unlimited.\nEventEmitter.prototype.setMaxListeners = function(n) {\n  if (!isNumber(n) || n < 0 || isNaN(n))\n    throw TypeError('n must be a positive number');\n  this._maxListeners = n;\n  return this;\n};\n\nEventEmitter.prototype.emit = function(type) {\n  var er, handler, len, args, i, listeners;\n\n  if (!this._events)\n    this._events = {};\n\n  // If there is no 'error' event listener then throw.\n  if (type === 'error') {\n    if (!this._events.error ||\n        (isObject(this._events.error) && !this._events.error.length)) {\n      er = arguments[1];\n      if (er instanceof Error) {\n        throw er; // Unhandled 'error' event\n      }\n      throw TypeError('Uncaught, unspecified \"error\" event.');\n    }\n  }\n\n  handler = this._events[type];\n\n  if (isUndefined(handler))\n    return false;\n\n  if (isFunction(handler)) {\n    switch (arguments.length) {\n      // fast cases\n      case 1:\n        handler.call(this);\n        break;\n      case 2:\n        handler.call(this, arguments[1]);\n        break;\n      case 3:\n        handler.call(this, arguments[1], arguments[2]);\n        break;\n      // slower\n      default:\n        args = Array.prototype.slice.call(arguments, 1);\n        handler.apply(this, args);\n    }\n  } else if (isObject(handler)) {\n    args = Array.prototype.slice.call(arguments, 1);\n    listeners = handler.slice();\n    len = listeners.length;\n    for (i = 0; i < len; i++)\n      listeners[i].apply(this, args);\n  }\n\n  return true;\n};\n\nEventEmitter.prototype.addListener = function(type, listener) {\n  var m;\n\n  if (!isFunction(listener))\n    throw TypeError('listener must be a function');\n\n  if (!this._events)\n    this._events = {};\n\n  // To avoid recursion in the case that type === \"newListener\"! Before\n  // adding it to the listeners, first emit \"newListener\".\n  if (this._events.newListener)\n    this.emit('newListener', type,\n              isFunction(listener.listener) ?\n              listener.listener : listener);\n\n  if (!this._events[type])\n    // Optimize the case of one listener. Don't need the extra array object.\n    this._events[type] = listener;\n  else if (isObject(this._events[type]))\n    // If we've already got an array, just append.\n    this._events[type].push(listener);\n  else\n    // Adding the second element, need to change to array.\n    this._events[type] = [this._events[type], listener];\n\n  // Check for listener leak\n  if (isObject(this._events[type]) && !this._events[type].warned) {\n    if (!isUndefined(this._maxListeners)) {\n      m = this._maxListeners;\n    } else {\n      m = EventEmitter.defaultMaxListeners;\n    }\n\n    if (m && m > 0 && this._events[type].length > m) {\n      this._events[type].warned = true;\n      console.error('(node) warning: possible EventEmitter memory ' +\n                    'leak detected. %d listeners added. ' +\n                    'Use emitter.setMaxListeners() to increase limit.',\n                    this._events[type].length);\n      if (typeof console.trace === 'function') {\n        // not supported in IE 10\n        console.trace();\n      }\n    }\n  }\n\n  return this;\n};\n\nEventEmitter.prototype.on = EventEmitter.prototype.addListener;\n\nEventEmitter.prototype.once = function(type, listener) {\n  if (!isFunction(listener))\n    throw TypeError('listener must be a function');\n\n  var fired = false;\n\n  function g() {\n    this.removeListener(type, g);\n\n    if (!fired) {\n      fired = true;\n      listener.apply(this, arguments);\n    }\n  }\n\n  g.listener = listener;\n  this.on(type, g);\n\n  return this;\n};\n\n// emits a 'removeListener' event iff the listener was removed\nEventEmitter.prototype.removeListener = function(type, listener) {\n  var list, position, length, i;\n\n  if (!isFunction(listener))\n    throw TypeError('listener must be a function');\n\n  if (!this._events || !this._events[type])\n    return this;\n\n  list = this._events[type];\n  length = list.length;\n  position = -1;\n\n  if (list === listener ||\n      (isFunction(list.listener) && list.listener === listener)) {\n    delete this._events[type];\n    if (this._events.removeListener)\n      this.emit('removeListener', type, listener);\n\n  } else if (isObject(list)) {\n    for (i = length; i-- > 0;) {\n      if (list[i] === listener ||\n          (list[i].listener && list[i].listener === listener)) {\n        position = i;\n        break;\n      }\n    }\n\n    if (position < 0)\n      return this;\n\n    if (list.length === 1) {\n      list.length = 0;\n      delete this._events[type];\n    } else {\n      list.splice(position, 1);\n    }\n\n    if (this._events.removeListener)\n      this.emit('removeListener', type, listener);\n  }\n\n  return this;\n};\n\nEventEmitter.prototype.removeAllListeners = function(type) {\n  var key, listeners;\n\n  if (!this._events)\n    return this;\n\n  // not listening for removeListener, no need to emit\n  if (!this._events.removeListener) {\n    if (arguments.length === 0)\n      this._events = {};\n    else if (this._events[type])\n      delete this._events[type];\n    return this;\n  }\n\n  // emit removeListener for all listeners on all events\n  if (arguments.length === 0) {\n    for (key in this._events) {\n      if (key === 'removeListener') continue;\n      this.removeAllListeners(key);\n    }\n    this.removeAllListeners('removeListener');\n    this._events = {};\n    return this;\n  }\n\n  listeners = this._events[type];\n\n  if (isFunction(listeners)) {\n    this.removeListener(type, listeners);\n  } else if (listeners) {\n    // LIFO order\n    while (listeners.length)\n      this.removeListener(type, listeners[listeners.length - 1]);\n  }\n  delete this._events[type];\n\n  return this;\n};\n\nEventEmitter.prototype.listeners = function(type) {\n  var ret;\n  if (!this._events || !this._events[type])\n    ret = [];\n  else if (isFunction(this._events[type]))\n    ret = [this._events[type]];\n  else\n    ret = this._events[type].slice();\n  return ret;\n};\n\nEventEmitter.prototype.listenerCount = function(type) {\n  if (this._events) {\n    var evlistener = this._events[type];\n\n    if (isFunction(evlistener))\n      return 1;\n    else if (evlistener)\n      return evlistener.length;\n  }\n  return 0;\n};\n\nEventEmitter.listenerCount = function(emitter, type) {\n  return emitter.listenerCount(type);\n};\n\nfunction isFunction(arg) {\n  return typeof arg === 'function';\n}\n\nfunction isNumber(arg) {\n  return typeof arg === 'number';\n}\n\nfunction isObject(arg) {\n  return typeof arg === 'object' && arg !== null;\n}\n\nfunction isUndefined(arg) {\n  return arg === void 0;\n}\n","var http = require('http');\n\nvar https = module.exports;\n\nfor (var key in http) {\n    if (http.hasOwnProperty(key)) https[key] = http[key];\n};\n\nhttps.request = function (params, cb) {\n    if (!params) params = {};\n    params.scheme = 'https';\n    params.protocol = 'https:';\n    return http.request.call(this, params, cb);\n}\n","if (typeof Object.create === 'function') {\n  // implementation from standard node.js 'util' module\n  module.exports = function inherits(ctor, superCtor) {\n    ctor.super_ = superCtor\n    ctor.prototype = Object.create(superCtor.prototype, {\n      constructor: {\n        value: ctor,\n        enumerable: false,\n        writable: true,\n        configurable: true\n      }\n    });\n  };\n} else {\n  // old school shim for old browsers\n  module.exports = function inherits(ctor, superCtor) {\n    ctor.super_ = superCtor\n    var TempCtor = function () {}\n    TempCtor.prototype = superCtor.prototype\n    ctor.prototype = new TempCtor()\n    ctor.prototype.constructor = ctor\n  }\n}\n","/**\n * Determine if an object is Buffer\n *\n * Author:   Feross Aboukhadijeh <feross@feross.org> <http://feross.org>\n * License:  MIT\n *\n * `npm install is-buffer`\n */\n\nmodule.exports = function (obj) {\n  return !!(obj != null &&\n    (obj._isBuffer || // For Safari 5-7 (missing Object.prototype.constructor)\n      (obj.constructor &&\n      typeof obj.constructor.isBuffer === 'function' &&\n      obj.constructor.isBuffer(obj))\n    ))\n}\n","module.exports = Array.isArray || function (arr) {\n  return Object.prototype.toString.call(arr) == '[object Array]';\n};\n","// shim for using process in browser\n\nvar process = module.exports = {};\nvar queue = [];\nvar draining = false;\nvar currentQueue;\nvar queueIndex = -1;\n\nfunction cleanUpNextTick() {\n    draining = false;\n    if (currentQueue.length) {\n        queue = currentQueue.concat(queue);\n    } else {\n        queueIndex = -1;\n    }\n    if (queue.length) {\n        drainQueue();\n    }\n}\n\nfunction drainQueue() {\n    if (draining) {\n        return;\n    }\n    var timeout = setTimeout(cleanUpNextTick);\n    draining = true;\n\n    var len = queue.length;\n    while(len) {\n        currentQueue = queue;\n        queue = [];\n        while (++queueIndex < len) {\n            if (currentQueue) {\n                currentQueue[queueIndex].run();\n            }\n        }\n        queueIndex = -1;\n        len = queue.length;\n    }\n    currentQueue = null;\n    draining = false;\n    clearTimeout(timeout);\n}\n\nprocess.nextTick = function (fun) {\n    var args = new Array(arguments.length - 1);\n    if (arguments.length > 1) {\n        for (var i = 1; i < arguments.length; i++) {\n            args[i - 1] = arguments[i];\n        }\n    }\n    queue.push(new Item(fun, args));\n    if (queue.length === 1 && !draining) {\n        setTimeout(drainQueue, 0);\n    }\n};\n\n// v8 likes predictible objects\nfunction Item(fun, array) {\n    this.fun = fun;\n    this.array = array;\n}\nItem.prototype.run = function () {\n    this.fun.apply(null, this.array);\n};\nprocess.title = 'browser';\nprocess.browser = true;\nprocess.env = {};\nprocess.argv = [];\nprocess.version = ''; // empty string to avoid regexp issues\nprocess.versions = {};\n\nfunction noop() {}\n\nprocess.on = noop;\nprocess.addListener = noop;\nprocess.once = noop;\nprocess.off = noop;\nprocess.removeListener = noop;\nprocess.removeAllListeners = noop;\nprocess.emit = noop;\n\nprocess.binding = function (name) {\n    throw new Error('process.binding is not supported');\n};\n\nprocess.cwd = function () { return '/' };\nprocess.chdir = function (dir) {\n    throw new Error('process.chdir is not supported');\n};\nprocess.umask = function() { return 0; };\n","/*! https://mths.be/punycode v1.4.0 by @mathias */\n;(function(root) {\n\n\t/** Detect free variables */\n\tvar freeExports = typeof exports == 'object' && exports &&\n\t\t!exports.nodeType && exports;\n\tvar freeModule = typeof module == 'object' && module &&\n\t\t!module.nodeType && module;\n\tvar freeGlobal = typeof global == 'object' && global;\n\tif (\n\t\tfreeGlobal.global === freeGlobal ||\n\t\tfreeGlobal.window === freeGlobal ||\n\t\tfreeGlobal.self === freeGlobal\n\t) {\n\t\troot = freeGlobal;\n\t}\n\n\t/**\n\t * The `punycode` object.\n\t * @name punycode\n\t * @type Object\n\t */\n\tvar punycode,\n\n\t/** Highest positive signed 32-bit float value */\n\tmaxInt = 2147483647, // aka. 0x7FFFFFFF or 2^31-1\n\n\t/** Bootstring parameters */\n\tbase = 36,\n\ttMin = 1,\n\ttMax = 26,\n\tskew = 38,\n\tdamp = 700,\n\tinitialBias = 72,\n\tinitialN = 128, // 0x80\n\tdelimiter = '-', // '\\x2D'\n\n\t/** Regular expressions */\n\tregexPunycode = /^xn--/,\n\tregexNonASCII = /[^\\x20-\\x7E]/, // unprintable ASCII chars + non-ASCII chars\n\tregexSeparators = /[\\x2E\\u3002\\uFF0E\\uFF61]/g, // RFC 3490 separators\n\n\t/** Error messages */\n\terrors = {\n\t\t'overflow': 'Overflow: input needs wider integers to process',\n\t\t'not-basic': 'Illegal input >= 0x80 (not a basic code point)',\n\t\t'invalid-input': 'Invalid input'\n\t},\n\n\t/** Convenience shortcuts */\n\tbaseMinusTMin = base - tMin,\n\tfloor = Math.floor,\n\tstringFromCharCode = String.fromCharCode,\n\n\t/** Temporary variable */\n\tkey;\n\n\t/*--------------------------------------------------------------------------*/\n\n\t/**\n\t * A generic error utility function.\n\t * @private\n\t * @param {String} type The error type.\n\t * @returns {Error} Throws a `RangeError` with the applicable error message.\n\t */\n\tfunction error(type) {\n\t\tthrow new RangeError(errors[type]);\n\t}\n\n\t/**\n\t * A generic `Array#map` utility function.\n\t * @private\n\t * @param {Array} array The array to iterate over.\n\t * @param {Function} callback The function that gets called for every array\n\t * item.\n\t * @returns {Array} A new array of values returned by the callback function.\n\t */\n\tfunction map(array, fn) {\n\t\tvar length = array.length;\n\t\tvar result = [];\n\t\twhile (length--) {\n\t\t\tresult[length] = fn(array[length]);\n\t\t}\n\t\treturn result;\n\t}\n\n\t/**\n\t * A simple `Array#map`-like wrapper to work with domain name strings or email\n\t * addresses.\n\t * @private\n\t * @param {String} domain The domain name or email address.\n\t * @param {Function} callback The function that gets called for every\n\t * character.\n\t * @returns {Array} A new string of characters returned by the callback\n\t * function.\n\t */\n\tfunction mapDomain(string, fn) {\n\t\tvar parts = string.split('@');\n\t\tvar result = '';\n\t\tif (parts.length > 1) {\n\t\t\t// In email addresses, only the domain name should be punycoded. Leave\n\t\t\t// the local part (i.e. everything up to `@`) intact.\n\t\t\tresult = parts[0] + '@';\n\t\t\tstring = parts[1];\n\t\t}\n\t\t// Avoid `split(regex)` for IE8 compatibility. See #17.\n\t\tstring = string.replace(regexSeparators, '\\x2E');\n\t\tvar labels = string.split('.');\n\t\tvar encoded = map(labels, fn).join('.');\n\t\treturn result + encoded;\n\t}\n\n\t/**\n\t * Creates an array containing the numeric code points of each Unicode\n\t * character in the string. While JavaScript uses UCS-2 internally,\n\t * this function will convert a pair of surrogate halves (each of which\n\t * UCS-2 exposes as separate characters) into a single code point,\n\t * matching UTF-16.\n\t * @see `punycode.ucs2.encode`\n\t * @see <https://mathiasbynens.be/notes/javascript-encoding>\n\t * @memberOf punycode.ucs2\n\t * @name decode\n\t * @param {String} string The Unicode input string (UCS-2).\n\t * @returns {Array} The new array of code points.\n\t */\n\tfunction ucs2decode(string) {\n\t\tvar output = [],\n\t\t    counter = 0,\n\t\t    length = string.length,\n\t\t    value,\n\t\t    extra;\n\t\twhile (counter < length) {\n\t\t\tvalue = string.charCodeAt(counter++);\n\t\t\tif (value >= 0xD800 && value <= 0xDBFF && counter < length) {\n\t\t\t\t// high surrogate, and there is a next character\n\t\t\t\textra = string.charCodeAt(counter++);\n\t\t\t\tif ((extra & 0xFC00) == 0xDC00) { // low surrogate\n\t\t\t\t\toutput.push(((value & 0x3FF) << 10) + (extra & 0x3FF) + 0x10000);\n\t\t\t\t} else {\n\t\t\t\t\t// unmatched surrogate; only append this code unit, in case the next\n\t\t\t\t\t// code unit is the high surrogate of a surrogate pair\n\t\t\t\t\toutput.push(value);\n\t\t\t\t\tcounter--;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\toutput.push(value);\n\t\t\t}\n\t\t}\n\t\treturn output;\n\t}\n\n\t/**\n\t * Creates a string based on an array of numeric code points.\n\t * @see `punycode.ucs2.decode`\n\t * @memberOf punycode.ucs2\n\t * @name encode\n\t * @param {Array} codePoints The array of numeric code points.\n\t * @returns {String} The new Unicode string (UCS-2).\n\t */\n\tfunction ucs2encode(array) {\n\t\treturn map(array, function(value) {\n\t\t\tvar output = '';\n\t\t\tif (value > 0xFFFF) {\n\t\t\t\tvalue -= 0x10000;\n\t\t\t\toutput += stringFromCharCode(value >>> 10 & 0x3FF | 0xD800);\n\t\t\t\tvalue = 0xDC00 | value & 0x3FF;\n\t\t\t}\n\t\t\toutput += stringFromCharCode(value);\n\t\t\treturn output;\n\t\t}).join('');\n\t}\n\n\t/**\n\t * Converts a basic code point into a digit/integer.\n\t * @see `digitToBasic()`\n\t * @private\n\t * @param {Number} codePoint The basic numeric code point value.\n\t * @returns {Number} The numeric value of a basic code point (for use in\n\t * representing integers) in the range `0` to `base - 1`, or `base` if\n\t * the code point does not represent a value.\n\t */\n\tfunction basicToDigit(codePoint) {\n\t\tif (codePoint - 48 < 10) {\n\t\t\treturn codePoint - 22;\n\t\t}\n\t\tif (codePoint - 65 < 26) {\n\t\t\treturn codePoint - 65;\n\t\t}\n\t\tif (codePoint - 97 < 26) {\n\t\t\treturn codePoint - 97;\n\t\t}\n\t\treturn base;\n\t}\n\n\t/**\n\t * Converts a digit/integer into a basic code point.\n\t * @see `basicToDigit()`\n\t * @private\n\t * @param {Number} digit The numeric value of a basic code point.\n\t * @returns {Number} The basic code point whose value (when used for\n\t * representing integers) is `digit`, which needs to be in the range\n\t * `0` to `base - 1`. If `flag` is non-zero, the uppercase form is\n\t * used; else, the lowercase form is used. The behavior is undefined\n\t * if `flag` is non-zero and `digit` has no uppercase form.\n\t */\n\tfunction digitToBasic(digit, flag) {\n\t\t//  0..25 map to ASCII a..z or A..Z\n\t\t// 26..35 map to ASCII 0..9\n\t\treturn digit + 22 + 75 * (digit < 26) - ((flag != 0) << 5);\n\t}\n\n\t/**\n\t * Bias adaptation function as per section 3.4 of RFC 3492.\n\t * https://tools.ietf.org/html/rfc3492#section-3.4\n\t * @private\n\t */\n\tfunction adapt(delta, numPoints, firstTime) {\n\t\tvar k = 0;\n\t\tdelta = firstTime ? floor(delta / damp) : delta >> 1;\n\t\tdelta += floor(delta / numPoints);\n\t\tfor (/* no initialization */; delta > baseMinusTMin * tMax >> 1; k += base) {\n\t\t\tdelta = floor(delta / baseMinusTMin);\n\t\t}\n\t\treturn floor(k + (baseMinusTMin + 1) * delta / (delta + skew));\n\t}\n\n\t/**\n\t * Converts a Punycode string of ASCII-only symbols to a string of Unicode\n\t * symbols.\n\t * @memberOf punycode\n\t * @param {String} input The Punycode string of ASCII-only symbols.\n\t * @returns {String} The resulting string of Unicode symbols.\n\t */\n\tfunction decode(input) {\n\t\t// Don't use UCS-2\n\t\tvar output = [],\n\t\t    inputLength = input.length,\n\t\t    out,\n\t\t    i = 0,\n\t\t    n = initialN,\n\t\t    bias = initialBias,\n\t\t    basic,\n\t\t    j,\n\t\t    index,\n\t\t    oldi,\n\t\t    w,\n\t\t    k,\n\t\t    digit,\n\t\t    t,\n\t\t    /** Cached calculation results */\n\t\t    baseMinusT;\n\n\t\t// Handle the basic code points: let `basic` be the number of input code\n\t\t// points before the last delimiter, or `0` if there is none, then copy\n\t\t// the first basic code points to the output.\n\n\t\tbasic = input.lastIndexOf(delimiter);\n\t\tif (basic < 0) {\n\t\t\tbasic = 0;\n\t\t}\n\n\t\tfor (j = 0; j < basic; ++j) {\n\t\t\t// if it's not a basic code point\n\t\t\tif (input.charCodeAt(j) >= 0x80) {\n\t\t\t\terror('not-basic');\n\t\t\t}\n\t\t\toutput.push(input.charCodeAt(j));\n\t\t}\n\n\t\t// Main decoding loop: start just after the last delimiter if any basic code\n\t\t// points were copied; start at the beginning otherwise.\n\n\t\tfor (index = basic > 0 ? basic + 1 : 0; index < inputLength; /* no final expression */) {\n\n\t\t\t// `index` is the index of the next character to be consumed.\n\t\t\t// Decode a generalized variable-length integer into `delta`,\n\t\t\t// which gets added to `i`. The overflow checking is easier\n\t\t\t// if we increase `i` as we go, then subtract off its starting\n\t\t\t// value at the end to obtain `delta`.\n\t\t\tfor (oldi = i, w = 1, k = base; /* no condition */; k += base) {\n\n\t\t\t\tif (index >= inputLength) {\n\t\t\t\t\terror('invalid-input');\n\t\t\t\t}\n\n\t\t\t\tdigit = basicToDigit(input.charCodeAt(index++));\n\n\t\t\t\tif (digit >= base || digit > floor((maxInt - i) / w)) {\n\t\t\t\t\terror('overflow');\n\t\t\t\t}\n\n\t\t\t\ti += digit * w;\n\t\t\t\tt = k <= bias ? tMin : (k >= bias + tMax ? tMax : k - bias);\n\n\t\t\t\tif (digit < t) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\tbaseMinusT = base - t;\n\t\t\t\tif (w > floor(maxInt / baseMinusT)) {\n\t\t\t\t\terror('overflow');\n\t\t\t\t}\n\n\t\t\t\tw *= baseMinusT;\n\n\t\t\t}\n\n\t\t\tout = output.length + 1;\n\t\t\tbias = adapt(i - oldi, out, oldi == 0);\n\n\t\t\t// `i` was supposed to wrap around from `out` to `0`,\n\t\t\t// incrementing `n` each time, so we'll fix that now:\n\t\t\tif (floor(i / out) > maxInt - n) {\n\t\t\t\terror('overflow');\n\t\t\t}\n\n\t\t\tn += floor(i / out);\n\t\t\ti %= out;\n\n\t\t\t// Insert `n` at position `i` of the output\n\t\t\toutput.splice(i++, 0, n);\n\n\t\t}\n\n\t\treturn ucs2encode(output);\n\t}\n\n\t/**\n\t * Converts a string of Unicode symbols (e.g. a domain name label) to a\n\t * Punycode string of ASCII-only symbols.\n\t * @memberOf punycode\n\t * @param {String} input The string of Unicode symbols.\n\t * @returns {String} The resulting Punycode string of ASCII-only symbols.\n\t */\n\tfunction encode(input) {\n\t\tvar n,\n\t\t    delta,\n\t\t    handledCPCount,\n\t\t    basicLength,\n\t\t    bias,\n\t\t    j,\n\t\t    m,\n\t\t    q,\n\t\t    k,\n\t\t    t,\n\t\t    currentValue,\n\t\t    output = [],\n\t\t    /** `inputLength` will hold the number of code points in `input`. */\n\t\t    inputLength,\n\t\t    /** Cached calculation results */\n\t\t    handledCPCountPlusOne,\n\t\t    baseMinusT,\n\t\t    qMinusT;\n\n\t\t// Convert the input in UCS-2 to Unicode\n\t\tinput = ucs2decode(input);\n\n\t\t// Cache the length\n\t\tinputLength = input.length;\n\n\t\t// Initialize the state\n\t\tn = initialN;\n\t\tdelta = 0;\n\t\tbias = initialBias;\n\n\t\t// Handle the basic code points\n\t\tfor (j = 0; j < inputLength; ++j) {\n\t\t\tcurrentValue = input[j];\n\t\t\tif (currentValue < 0x80) {\n\t\t\t\toutput.push(stringFromCharCode(currentValue));\n\t\t\t}\n\t\t}\n\n\t\thandledCPCount = basicLength = output.length;\n\n\t\t// `handledCPCount` is the number of code points that have been handled;\n\t\t// `basicLength` is the number of basic code points.\n\n\t\t// Finish the basic string - if it is not empty - with a delimiter\n\t\tif (basicLength) {\n\t\t\toutput.push(delimiter);\n\t\t}\n\n\t\t// Main encoding loop:\n\t\twhile (handledCPCount < inputLength) {\n\n\t\t\t// All non-basic code points < n have been handled already. Find the next\n\t\t\t// larger one:\n\t\t\tfor (m = maxInt, j = 0; j < inputLength; ++j) {\n\t\t\t\tcurrentValue = input[j];\n\t\t\t\tif (currentValue >= n && currentValue < m) {\n\t\t\t\t\tm = currentValue;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Increase `delta` enough to advance the decoder's <n,i> state to <m,0>,\n\t\t\t// but guard against overflow\n\t\t\thandledCPCountPlusOne = handledCPCount + 1;\n\t\t\tif (m - n > floor((maxInt - delta) / handledCPCountPlusOne)) {\n\t\t\t\terror('overflow');\n\t\t\t}\n\n\t\t\tdelta += (m - n) * handledCPCountPlusOne;\n\t\t\tn = m;\n\n\t\t\tfor (j = 0; j < inputLength; ++j) {\n\t\t\t\tcurrentValue = input[j];\n\n\t\t\t\tif (currentValue < n && ++delta > maxInt) {\n\t\t\t\t\terror('overflow');\n\t\t\t\t}\n\n\t\t\t\tif (currentValue == n) {\n\t\t\t\t\t// Represent delta as a generalized variable-length integer\n\t\t\t\t\tfor (q = delta, k = base; /* no condition */; k += base) {\n\t\t\t\t\t\tt = k <= bias ? tMin : (k >= bias + tMax ? tMax : k - bias);\n\t\t\t\t\t\tif (q < t) {\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tqMinusT = q - t;\n\t\t\t\t\t\tbaseMinusT = base - t;\n\t\t\t\t\t\toutput.push(\n\t\t\t\t\t\t\tstringFromCharCode(digitToBasic(t + qMinusT % baseMinusT, 0))\n\t\t\t\t\t\t);\n\t\t\t\t\t\tq = floor(qMinusT / baseMinusT);\n\t\t\t\t\t}\n\n\t\t\t\t\toutput.push(stringFromCharCode(digitToBasic(q, 0)));\n\t\t\t\t\tbias = adapt(delta, handledCPCountPlusOne, handledCPCount == basicLength);\n\t\t\t\t\tdelta = 0;\n\t\t\t\t\t++handledCPCount;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t++delta;\n\t\t\t++n;\n\n\t\t}\n\t\treturn output.join('');\n\t}\n\n\t/**\n\t * Converts a Punycode string representing a domain name or an email address\n\t * to Unicode. Only the Punycoded parts of the input will be converted, i.e.\n\t * it doesn't matter if you call it on a string that has already been\n\t * converted to Unicode.\n\t * @memberOf punycode\n\t * @param {String} input The Punycoded domain name or email address to\n\t * convert to Unicode.\n\t * @returns {String} The Unicode representation of the given Punycode\n\t * string.\n\t */\n\tfunction toUnicode(input) {\n\t\treturn mapDomain(input, function(string) {\n\t\t\treturn regexPunycode.test(string)\n\t\t\t\t? decode(string.slice(4).toLowerCase())\n\t\t\t\t: string;\n\t\t});\n\t}\n\n\t/**\n\t * Converts a Unicode string representing a domain name or an email address to\n\t * Punycode. Only the non-ASCII parts of the domain name will be converted,\n\t * i.e. it doesn't matter if you call it with a domain that's already in\n\t * ASCII.\n\t * @memberOf punycode\n\t * @param {String} input The domain name or email address to convert, as a\n\t * Unicode string.\n\t * @returns {String} The Punycode representation of the given domain name or\n\t * email address.\n\t */\n\tfunction toASCII(input) {\n\t\treturn mapDomain(input, function(string) {\n\t\t\treturn regexNonASCII.test(string)\n\t\t\t\t? 'xn--' + encode(string)\n\t\t\t\t: string;\n\t\t});\n\t}\n\n\t/*--------------------------------------------------------------------------*/\n\n\t/** Define the public API */\n\tpunycode = {\n\t\t/**\n\t\t * A string representing the current Punycode.js version number.\n\t\t * @memberOf punycode\n\t\t * @type String\n\t\t */\n\t\t'version': '1.3.2',\n\t\t/**\n\t\t * An object of methods to convert from JavaScript's internal character\n\t\t * representation (UCS-2) to Unicode code points, and back.\n\t\t * @see <https://mathiasbynens.be/notes/javascript-encoding>\n\t\t * @memberOf punycode\n\t\t * @type Object\n\t\t */\n\t\t'ucs2': {\n\t\t\t'decode': ucs2decode,\n\t\t\t'encode': ucs2encode\n\t\t},\n\t\t'decode': decode,\n\t\t'encode': encode,\n\t\t'toASCII': toASCII,\n\t\t'toUnicode': toUnicode\n\t};\n\n\t/** Expose `punycode` */\n\t// Some AMD build optimizers, like r.js, check for specific condition patterns\n\t// like the following:\n\tif (\n\t\ttypeof define == 'function' &&\n\t\ttypeof define.amd == 'object' &&\n\t\tdefine.amd\n\t) {\n\t\tdefine('punycode', function() {\n\t\t\treturn punycode;\n\t\t});\n\t} else if (freeExports && freeModule) {\n\t\tif (module.exports == freeExports) {\n\t\t\t// in Node.js, io.js, or RingoJS v0.8.0+\n\t\t\tfreeModule.exports = punycode;\n\t\t} else {\n\t\t\t// in Narwhal or RingoJS v0.7.0-\n\t\t\tfor (key in punycode) {\n\t\t\t\tpunycode.hasOwnProperty(key) && (freeExports[key] = punycode[key]);\n\t\t\t}\n\t\t}\n\t} else {\n\t\t// in Rhino or a web browser\n\t\troot.punycode = punycode;\n\t}\n\n}(this));\n","// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n'use strict';\n\n// If obj.hasOwnProperty has been overridden, then calling\n// obj.hasOwnProperty(prop) will break.\n// See: https://github.com/joyent/node/issues/1707\nfunction hasOwnProperty(obj, prop) {\n  return Object.prototype.hasOwnProperty.call(obj, prop);\n}\n\nmodule.exports = function(qs, sep, eq, options) {\n  sep = sep || '&';\n  eq = eq || '=';\n  var obj = {};\n\n  if (typeof qs !== 'string' || qs.length === 0) {\n    return obj;\n  }\n\n  var regexp = /\\+/g;\n  qs = qs.split(sep);\n\n  var maxKeys = 1000;\n  if (options && typeof options.maxKeys === 'number') {\n    maxKeys = options.maxKeys;\n  }\n\n  var len = qs.length;\n  // maxKeys <= 0 means that we should not limit keys count\n  if (maxKeys > 0 && len > maxKeys) {\n    len = maxKeys;\n  }\n\n  for (var i = 0; i < len; ++i) {\n    var x = qs[i].replace(regexp, '%20'),\n        idx = x.indexOf(eq),\n        kstr, vstr, k, v;\n\n    if (idx >= 0) {\n      kstr = x.substr(0, idx);\n      vstr = x.substr(idx + 1);\n    } else {\n      kstr = x;\n      vstr = '';\n    }\n\n    k = decodeURIComponent(kstr);\n    v = decodeURIComponent(vstr);\n\n    if (!hasOwnProperty(obj, k)) {\n      obj[k] = v;\n    } else if (isArray(obj[k])) {\n      obj[k].push(v);\n    } else {\n      obj[k] = [obj[k], v];\n    }\n  }\n\n  return obj;\n};\n\nvar isArray = Array.isArray || function (xs) {\n  return Object.prototype.toString.call(xs) === '[object Array]';\n};\n","// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n'use strict';\n\nvar stringifyPrimitive = function(v) {\n  switch (typeof v) {\n    case 'string':\n      return v;\n\n    case 'boolean':\n      return v ? 'true' : 'false';\n\n    case 'number':\n      return isFinite(v) ? v : '';\n\n    default:\n      return '';\n  }\n};\n\nmodule.exports = function(obj, sep, eq, name) {\n  sep = sep || '&';\n  eq = eq || '=';\n  if (obj === null) {\n    obj = undefined;\n  }\n\n  if (typeof obj === 'object') {\n    return map(objectKeys(obj), function(k) {\n      var ks = encodeURIComponent(stringifyPrimitive(k)) + eq;\n      if (isArray(obj[k])) {\n        return map(obj[k], function(v) {\n          return ks + encodeURIComponent(stringifyPrimitive(v));\n        }).join(sep);\n      } else {\n        return ks + encodeURIComponent(stringifyPrimitive(obj[k]));\n      }\n    }).join(sep);\n\n  }\n\n  if (!name) return '';\n  return encodeURIComponent(stringifyPrimitive(name)) + eq +\n         encodeURIComponent(stringifyPrimitive(obj));\n};\n\nvar isArray = Array.isArray || function (xs) {\n  return Object.prototype.toString.call(xs) === '[object Array]';\n};\n\nfunction map (xs, f) {\n  if (xs.map) return xs.map(f);\n  var res = [];\n  for (var i = 0; i < xs.length; i++) {\n    res.push(f(xs[i], i));\n  }\n  return res;\n}\n\nvar objectKeys = Object.keys || function (obj) {\n  var res = [];\n  for (var key in obj) {\n    if (Object.prototype.hasOwnProperty.call(obj, key)) res.push(key);\n  }\n  return res;\n};\n","'use strict';\n\nexports.decode = exports.parse = require('./decode');\nexports.encode = exports.stringify = require('./encode');\n","module.exports = require(\"./lib/_stream_duplex.js\")\n","// a duplex stream is just a stream that is both readable and writable.\n// Since JS doesn't have multiple prototypal inheritance, this class\n// prototypally inherits from Readable, and then parasitically from\n// Writable.\n\n'use strict';\n\n/*<replacement>*/\nvar objectKeys = Object.keys || function (obj) {\n  var keys = [];\n  for (var key in obj) keys.push(key);\n  return keys;\n}\n/*</replacement>*/\n\n\nmodule.exports = Duplex;\n\n/*<replacement>*/\nvar processNextTick = require('process-nextick-args');\n/*</replacement>*/\n\n\n\n/*<replacement>*/\nvar util = require('core-util-is');\nutil.inherits = require('inherits');\n/*</replacement>*/\n\nvar Readable = require('./_stream_readable');\nvar Writable = require('./_stream_writable');\n\nutil.inherits(Duplex, Readable);\n\nvar keys = objectKeys(Writable.prototype);\nfor (var v = 0; v < keys.length; v++) {\n  var method = keys[v];\n  if (!Duplex.prototype[method])\n    Duplex.prototype[method] = Writable.prototype[method];\n}\n\nfunction Duplex(options) {\n  if (!(this instanceof Duplex))\n    return new Duplex(options);\n\n  Readable.call(this, options);\n  Writable.call(this, options);\n\n  if (options && options.readable === false)\n    this.readable = false;\n\n  if (options && options.writable === false)\n    this.writable = false;\n\n  this.allowHalfOpen = true;\n  if (options && options.allowHalfOpen === false)\n    this.allowHalfOpen = false;\n\n  this.once('end', onend);\n}\n\n// the no-half-open enforcer\nfunction onend() {\n  // if we allow half-open state, or if the writable side ended,\n  // then we're ok.\n  if (this.allowHalfOpen || this._writableState.ended)\n    return;\n\n  // no more data can be written.\n  // But allow more writes to happen in this tick.\n  processNextTick(onEndNT, this);\n}\n\nfunction onEndNT(self) {\n  self.end();\n}\n\nfunction forEach (xs, f) {\n  for (var i = 0, l = xs.length; i < l; i++) {\n    f(xs[i], i);\n  }\n}\n","// a passthrough stream.\n// basically just the most minimal sort of Transform stream.\n// Every written chunk gets output as-is.\n\n'use strict';\n\nmodule.exports = PassThrough;\n\nvar Transform = require('./_stream_transform');\n\n/*<replacement>*/\nvar util = require('core-util-is');\nutil.inherits = require('inherits');\n/*</replacement>*/\n\nutil.inherits(PassThrough, Transform);\n\nfunction PassThrough(options) {\n  if (!(this instanceof PassThrough))\n    return new PassThrough(options);\n\n  Transform.call(this, options);\n}\n\nPassThrough.prototype._transform = function(chunk, encoding, cb) {\n  cb(null, chunk);\n};\n","'use strict';\n\nmodule.exports = Readable;\n\n/*<replacement>*/\nvar processNextTick = require('process-nextick-args');\n/*</replacement>*/\n\n\n/*<replacement>*/\nvar isArray = require('isarray');\n/*</replacement>*/\n\n\n/*<replacement>*/\nvar Buffer = require('buffer').Buffer;\n/*</replacement>*/\n\nReadable.ReadableState = ReadableState;\n\nvar EE = require('events');\n\n/*<replacement>*/\nvar EElistenerCount = function(emitter, type) {\n  return emitter.listeners(type).length;\n};\n/*</replacement>*/\n\n\n\n/*<replacement>*/\nvar Stream;\n(function (){try{\n  Stream = require('st' + 'ream');\n}catch(_){}finally{\n  if (!Stream)\n    Stream = require('events').EventEmitter;\n}}())\n/*</replacement>*/\n\nvar Buffer = require('buffer').Buffer;\n\n/*<replacement>*/\nvar util = require('core-util-is');\nutil.inherits = require('inherits');\n/*</replacement>*/\n\n\n\n/*<replacement>*/\nvar debugUtil = require('util');\nvar debug;\nif (debugUtil && debugUtil.debuglog) {\n  debug = debugUtil.debuglog('stream');\n} else {\n  debug = function () {};\n}\n/*</replacement>*/\n\nvar StringDecoder;\n\nutil.inherits(Readable, Stream);\n\nfunction ReadableState(options, stream) {\n  var Duplex = require('./_stream_duplex');\n\n  options = options || {};\n\n  // object stream flag. Used to make read(n) ignore n and to\n  // make all the buffer merging and length checks go away\n  this.objectMode = !!options.objectMode;\n\n  if (stream instanceof Duplex)\n    this.objectMode = this.objectMode || !!options.readableObjectMode;\n\n  // the point at which it stops calling _read() to fill the buffer\n  // Note: 0 is a valid value, means \"don't call _read preemptively ever\"\n  var hwm = options.highWaterMark;\n  var defaultHwm = this.objectMode ? 16 : 16 * 1024;\n  this.highWaterMark = (hwm || hwm === 0) ? hwm : defaultHwm;\n\n  // cast to ints.\n  this.highWaterMark = ~~this.highWaterMark;\n\n  this.buffer = [];\n  this.length = 0;\n  this.pipes = null;\n  this.pipesCount = 0;\n  this.flowing = null;\n  this.ended = false;\n  this.endEmitted = false;\n  this.reading = false;\n\n  // a flag to be able to tell if the onwrite cb is called immediately,\n  // or on a later tick.  We set this to true at first, because any\n  // actions that shouldn't happen until \"later\" should generally also\n  // not happen before the first write call.\n  this.sync = true;\n\n  // whenever we return null, then we set a flag to say\n  // that we're awaiting a 'readable' event emission.\n  this.needReadable = false;\n  this.emittedReadable = false;\n  this.readableListening = false;\n\n  // Crypto is kind of old and crusty.  Historically, its default string\n  // encoding is 'binary' so we have to make this configurable.\n  // Everything else in the universe uses 'utf8', though.\n  this.defaultEncoding = options.defaultEncoding || 'utf8';\n\n  // when piping, we only care about 'readable' events that happen\n  // after read()ing all the bytes and not getting any pushback.\n  this.ranOut = false;\n\n  // the number of writers that are awaiting a drain event in .pipe()s\n  this.awaitDrain = 0;\n\n  // if true, a maybeReadMore has been scheduled\n  this.readingMore = false;\n\n  this.decoder = null;\n  this.encoding = null;\n  if (options.encoding) {\n    if (!StringDecoder)\n      StringDecoder = require('string_decoder/').StringDecoder;\n    this.decoder = new StringDecoder(options.encoding);\n    this.encoding = options.encoding;\n  }\n}\n\nfunction Readable(options) {\n  var Duplex = require('./_stream_duplex');\n\n  if (!(this instanceof Readable))\n    return new Readable(options);\n\n  this._readableState = new ReadableState(options, this);\n\n  // legacy\n  this.readable = true;\n\n  if (options && typeof options.read === 'function')\n    this._read = options.read;\n\n  Stream.call(this);\n}\n\n// Manually shove something into the read() buffer.\n// This returns true if the highWaterMark has not been hit yet,\n// similar to how Writable.write() returns true if you should\n// write() some more.\nReadable.prototype.push = function(chunk, encoding) {\n  var state = this._readableState;\n\n  if (!state.objectMode && typeof chunk === 'string') {\n    encoding = encoding || state.defaultEncoding;\n    if (encoding !== state.encoding) {\n      chunk = new Buffer(chunk, encoding);\n      encoding = '';\n    }\n  }\n\n  return readableAddChunk(this, state, chunk, encoding, false);\n};\n\n// Unshift should *always* be something directly out of read()\nReadable.prototype.unshift = function(chunk) {\n  var state = this._readableState;\n  return readableAddChunk(this, state, chunk, '', true);\n};\n\nReadable.prototype.isPaused = function() {\n  return this._readableState.flowing === false;\n};\n\nfunction readableAddChunk(stream, state, chunk, encoding, addToFront) {\n  var er = chunkInvalid(state, chunk);\n  if (er) {\n    stream.emit('error', er);\n  } else if (chunk === null) {\n    state.reading = false;\n    onEofChunk(stream, state);\n  } else if (state.objectMode || chunk && chunk.length > 0) {\n    if (state.ended && !addToFront) {\n      var e = new Error('stream.push() after EOF');\n      stream.emit('error', e);\n    } else if (state.endEmitted && addToFront) {\n      var e = new Error('stream.unshift() after end event');\n      stream.emit('error', e);\n    } else {\n      if (state.decoder && !addToFront && !encoding)\n        chunk = state.decoder.write(chunk);\n\n      if (!addToFront)\n        state.reading = false;\n\n      // if we want the data now, just emit it.\n      if (state.flowing && state.length === 0 && !state.sync) {\n        stream.emit('data', chunk);\n        stream.read(0);\n      } else {\n        // update the buffer info.\n        state.length += state.objectMode ? 1 : chunk.length;\n        if (addToFront)\n          state.buffer.unshift(chunk);\n        else\n          state.buffer.push(chunk);\n\n        if (state.needReadable)\n          emitReadable(stream);\n      }\n\n      maybeReadMore(stream, state);\n    }\n  } else if (!addToFront) {\n    state.reading = false;\n  }\n\n  return needMoreData(state);\n}\n\n\n// if it's past the high water mark, we can push in some more.\n// Also, if we have no data yet, we can stand some\n// more bytes.  This is to work around cases where hwm=0,\n// such as the repl.  Also, if the push() triggered a\n// readable event, and the user called read(largeNumber) such that\n// needReadable was set, then we ought to push more, so that another\n// 'readable' event will be triggered.\nfunction needMoreData(state) {\n  return !state.ended &&\n         (state.needReadable ||\n          state.length < state.highWaterMark ||\n          state.length === 0);\n}\n\n// backwards compatibility.\nReadable.prototype.setEncoding = function(enc) {\n  if (!StringDecoder)\n    StringDecoder = require('string_decoder/').StringDecoder;\n  this._readableState.decoder = new StringDecoder(enc);\n  this._readableState.encoding = enc;\n  return this;\n};\n\n// Don't raise the hwm > 8MB\nvar MAX_HWM = 0x800000;\nfunction computeNewHighWaterMark(n) {\n  if (n >= MAX_HWM) {\n    n = MAX_HWM;\n  } else {\n    // Get the next highest power of 2\n    n--;\n    n |= n >>> 1;\n    n |= n >>> 2;\n    n |= n >>> 4;\n    n |= n >>> 8;\n    n |= n >>> 16;\n    n++;\n  }\n  return n;\n}\n\nfunction howMuchToRead(n, state) {\n  if (state.length === 0 && state.ended)\n    return 0;\n\n  if (state.objectMode)\n    return n === 0 ? 0 : 1;\n\n  if (n === null || isNaN(n)) {\n    // only flow one buffer at a time\n    if (state.flowing && state.buffer.length)\n      return state.buffer[0].length;\n    else\n      return state.length;\n  }\n\n  if (n <= 0)\n    return 0;\n\n  // If we're asking for more than the target buffer level,\n  // then raise the water mark.  Bump up to the next highest\n  // power of 2, to prevent increasing it excessively in tiny\n  // amounts.\n  if (n > state.highWaterMark)\n    state.highWaterMark = computeNewHighWaterMark(n);\n\n  // don't have that much.  return null, unless we've ended.\n  if (n > state.length) {\n    if (!state.ended) {\n      state.needReadable = true;\n      return 0;\n    } else {\n      return state.length;\n    }\n  }\n\n  return n;\n}\n\n// you can override either this method, or the async _read(n) below.\nReadable.prototype.read = function(n) {\n  debug('read', n);\n  var state = this._readableState;\n  var nOrig = n;\n\n  if (typeof n !== 'number' || n > 0)\n    state.emittedReadable = false;\n\n  // if we're doing read(0) to trigger a readable event, but we\n  // already have a bunch of data in the buffer, then just trigger\n  // the 'readable' event and move on.\n  if (n === 0 &&\n      state.needReadable &&\n      (state.length >= state.highWaterMark || state.ended)) {\n    debug('read: emitReadable', state.length, state.ended);\n    if (state.length === 0 && state.ended)\n      endReadable(this);\n    else\n      emitReadable(this);\n    return null;\n  }\n\n  n = howMuchToRead(n, state);\n\n  // if we've ended, and we're now clear, then finish it up.\n  if (n === 0 && state.ended) {\n    if (state.length === 0)\n      endReadable(this);\n    return null;\n  }\n\n  // All the actual chunk generation logic needs to be\n  // *below* the call to _read.  The reason is that in certain\n  // synthetic stream cases, such as passthrough streams, _read\n  // may be a completely synchronous operation which may change\n  // the state of the read buffer, providing enough data when\n  // before there was *not* enough.\n  //\n  // So, the steps are:\n  // 1. Figure out what the state of things will be after we do\n  // a read from the buffer.\n  //\n  // 2. If that resulting state will trigger a _read, then call _read.\n  // Note that this may be asynchronous, or synchronous.  Yes, it is\n  // deeply ugly to write APIs this way, but that still doesn't mean\n  // that the Readable class should behave improperly, as streams are\n  // designed to be sync/async agnostic.\n  // Take note if the _read call is sync or async (ie, if the read call\n  // has returned yet), so that we know whether or not it's safe to emit\n  // 'readable' etc.\n  //\n  // 3. Actually pull the requested chunks out of the buffer and return.\n\n  // if we need a readable event, then we need to do some reading.\n  var doRead = state.needReadable;\n  debug('need readable', doRead);\n\n  // if we currently have less than the highWaterMark, then also read some\n  if (state.length === 0 || state.length - n < state.highWaterMark) {\n    doRead = true;\n    debug('length less than watermark', doRead);\n  }\n\n  // however, if we've ended, then there's no point, and if we're already\n  // reading, then it's unnecessary.\n  if (state.ended || state.reading) {\n    doRead = false;\n    debug('reading or ended', doRead);\n  }\n\n  if (doRead) {\n    debug('do read');\n    state.reading = true;\n    state.sync = true;\n    // if the length is currently zero, then we *need* a readable event.\n    if (state.length === 0)\n      state.needReadable = true;\n    // call internal read method\n    this._read(state.highWaterMark);\n    state.sync = false;\n  }\n\n  // If _read pushed data synchronously, then `reading` will be false,\n  // and we need to re-evaluate how much data we can return to the user.\n  if (doRead && !state.reading)\n    n = howMuchToRead(nOrig, state);\n\n  var ret;\n  if (n > 0)\n    ret = fromList(n, state);\n  else\n    ret = null;\n\n  if (ret === null) {\n    state.needReadable = true;\n    n = 0;\n  }\n\n  state.length -= n;\n\n  // If we have nothing in the buffer, then we want to know\n  // as soon as we *do* get something into the buffer.\n  if (state.length === 0 && !state.ended)\n    state.needReadable = true;\n\n  // If we tried to read() past the EOF, then emit end on the next tick.\n  if (nOrig !== n && state.ended && state.length === 0)\n    endReadable(this);\n\n  if (ret !== null)\n    this.emit('data', ret);\n\n  return ret;\n};\n\nfunction chunkInvalid(state, chunk) {\n  var er = null;\n  if (!(Buffer.isBuffer(chunk)) &&\n      typeof chunk !== 'string' &&\n      chunk !== null &&\n      chunk !== undefined &&\n      !state.objectMode) {\n    er = new TypeError('Invalid non-string/buffer chunk');\n  }\n  return er;\n}\n\n\nfunction onEofChunk(stream, state) {\n  if (state.ended) return;\n  if (state.decoder) {\n    var chunk = state.decoder.end();\n    if (chunk && chunk.length) {\n      state.buffer.push(chunk);\n      state.length += state.objectMode ? 1 : chunk.length;\n    }\n  }\n  state.ended = true;\n\n  // emit 'readable' now to make sure it gets picked up.\n  emitReadable(stream);\n}\n\n// Don't emit readable right away in sync mode, because this can trigger\n// another read() call => stack overflow.  This way, it might trigger\n// a nextTick recursion warning, but that's not so bad.\nfunction emitReadable(stream) {\n  var state = stream._readableState;\n  state.needReadable = false;\n  if (!state.emittedReadable) {\n    debug('emitReadable', state.flowing);\n    state.emittedReadable = true;\n    if (state.sync)\n      processNextTick(emitReadable_, stream);\n    else\n      emitReadable_(stream);\n  }\n}\n\nfunction emitReadable_(stream) {\n  debug('emit readable');\n  stream.emit('readable');\n  flow(stream);\n}\n\n\n// at this point, the user has presumably seen the 'readable' event,\n// and called read() to consume some data.  that may have triggered\n// in turn another _read(n) call, in which case reading = true if\n// it's in progress.\n// However, if we're not ended, or reading, and the length < hwm,\n// then go ahead and try to read some more preemptively.\nfunction maybeReadMore(stream, state) {\n  if (!state.readingMore) {\n    state.readingMore = true;\n    processNextTick(maybeReadMore_, stream, state);\n  }\n}\n\nfunction maybeReadMore_(stream, state) {\n  var len = state.length;\n  while (!state.reading && !state.flowing && !state.ended &&\n         state.length < state.highWaterMark) {\n    debug('maybeReadMore read 0');\n    stream.read(0);\n    if (len === state.length)\n      // didn't get any data, stop spinning.\n      break;\n    else\n      len = state.length;\n  }\n  state.readingMore = false;\n}\n\n// abstract method.  to be overridden in specific implementation classes.\n// call cb(er, data) where data is <= n in length.\n// for virtual (non-string, non-buffer) streams, \"length\" is somewhat\n// arbitrary, and perhaps not very meaningful.\nReadable.prototype._read = function(n) {\n  this.emit('error', new Error('not implemented'));\n};\n\nReadable.prototype.pipe = function(dest, pipeOpts) {\n  var src = this;\n  var state = this._readableState;\n\n  switch (state.pipesCount) {\n    case 0:\n      state.pipes = dest;\n      break;\n    case 1:\n      state.pipes = [state.pipes, dest];\n      break;\n    default:\n      state.pipes.push(dest);\n      break;\n  }\n  state.pipesCount += 1;\n  debug('pipe count=%d opts=%j', state.pipesCount, pipeOpts);\n\n  var doEnd = (!pipeOpts || pipeOpts.end !== false) &&\n              dest !== process.stdout &&\n              dest !== process.stderr;\n\n  var endFn = doEnd ? onend : cleanup;\n  if (state.endEmitted)\n    processNextTick(endFn);\n  else\n    src.once('end', endFn);\n\n  dest.on('unpipe', onunpipe);\n  function onunpipe(readable) {\n    debug('onunpipe');\n    if (readable === src) {\n      cleanup();\n    }\n  }\n\n  function onend() {\n    debug('onend');\n    dest.end();\n  }\n\n  // when the dest drains, it reduces the awaitDrain counter\n  // on the source.  This would be more elegant with a .once()\n  // handler in flow(), but adding and removing repeatedly is\n  // too slow.\n  var ondrain = pipeOnDrain(src);\n  dest.on('drain', ondrain);\n\n  var cleanedUp = false;\n  function cleanup() {\n    debug('cleanup');\n    // cleanup event handlers once the pipe is broken\n    dest.removeListener('close', onclose);\n    dest.removeListener('finish', onfinish);\n    dest.removeListener('drain', ondrain);\n    dest.removeListener('error', onerror);\n    dest.removeListener('unpipe', onunpipe);\n    src.removeListener('end', onend);\n    src.removeListener('end', cleanup);\n    src.removeListener('data', ondata);\n\n    cleanedUp = true;\n\n    // if the reader is waiting for a drain event from this\n    // specific writer, then it would cause it to never start\n    // flowing again.\n    // So, if this is awaiting a drain, then we just call it now.\n    // If we don't know, then assume that we are waiting for one.\n    if (state.awaitDrain &&\n        (!dest._writableState || dest._writableState.needDrain))\n      ondrain();\n  }\n\n  src.on('data', ondata);\n  function ondata(chunk) {\n    debug('ondata');\n    var ret = dest.write(chunk);\n    if (false === ret) {\n      // If the user unpiped during `dest.write()`, it is possible\n      // to get stuck in a permanently paused state if that write\n      // also returned false.\n      if (state.pipesCount === 1 &&\n          state.pipes[0] === dest &&\n          src.listenerCount('data') === 1 &&\n          !cleanedUp) {\n        debug('false write response, pause', src._readableState.awaitDrain);\n        src._readableState.awaitDrain++;\n      }\n      src.pause();\n    }\n  }\n\n  // if the dest has an error, then stop piping into it.\n  // however, don't suppress the throwing behavior for this.\n  function onerror(er) {\n    debug('onerror', er);\n    unpipe();\n    dest.removeListener('error', onerror);\n    if (EElistenerCount(dest, 'error') === 0)\n      dest.emit('error', er);\n  }\n  // This is a brutally ugly hack to make sure that our error handler\n  // is attached before any userland ones.  NEVER DO THIS.\n  if (!dest._events || !dest._events.error)\n    dest.on('error', onerror);\n  else if (isArray(dest._events.error))\n    dest._events.error.unshift(onerror);\n  else\n    dest._events.error = [onerror, dest._events.error];\n\n\n  // Both close and finish should trigger unpipe, but only once.\n  function onclose() {\n    dest.removeListener('finish', onfinish);\n    unpipe();\n  }\n  dest.once('close', onclose);\n  function onfinish() {\n    debug('onfinish');\n    dest.removeListener('close', onclose);\n    unpipe();\n  }\n  dest.once('finish', onfinish);\n\n  function unpipe() {\n    debug('unpipe');\n    src.unpipe(dest);\n  }\n\n  // tell the dest that it's being piped to\n  dest.emit('pipe', src);\n\n  // start the flow if it hasn't been started already.\n  if (!state.flowing) {\n    debug('pipe resume');\n    src.resume();\n  }\n\n  return dest;\n};\n\nfunction pipeOnDrain(src) {\n  return function() {\n    var state = src._readableState;\n    debug('pipeOnDrain', state.awaitDrain);\n    if (state.awaitDrain)\n      state.awaitDrain--;\n    if (state.awaitDrain === 0 && EElistenerCount(src, 'data')) {\n      state.flowing = true;\n      flow(src);\n    }\n  };\n}\n\n\nReadable.prototype.unpipe = function(dest) {\n  var state = this._readableState;\n\n  // if we're not piping anywhere, then do nothing.\n  if (state.pipesCount === 0)\n    return this;\n\n  // just one destination.  most common case.\n  if (state.pipesCount === 1) {\n    // passed in one, but it's not the right one.\n    if (dest && dest !== state.pipes)\n      return this;\n\n    if (!dest)\n      dest = state.pipes;\n\n    // got a match.\n    state.pipes = null;\n    state.pipesCount = 0;\n    state.flowing = false;\n    if (dest)\n      dest.emit('unpipe', this);\n    return this;\n  }\n\n  // slow case. multiple pipe destinations.\n\n  if (!dest) {\n    // remove all.\n    var dests = state.pipes;\n    var len = state.pipesCount;\n    state.pipes = null;\n    state.pipesCount = 0;\n    state.flowing = false;\n\n    for (var i = 0; i < len; i++)\n      dests[i].emit('unpipe', this);\n    return this;\n  }\n\n  // try to find the right one.\n  var i = indexOf(state.pipes, dest);\n  if (i === -1)\n    return this;\n\n  state.pipes.splice(i, 1);\n  state.pipesCount -= 1;\n  if (state.pipesCount === 1)\n    state.pipes = state.pipes[0];\n\n  dest.emit('unpipe', this);\n\n  return this;\n};\n\n// set up data events if they are asked for\n// Ensure readable listeners eventually get something\nReadable.prototype.on = function(ev, fn) {\n  var res = Stream.prototype.on.call(this, ev, fn);\n\n  // If listening to data, and it has not explicitly been paused,\n  // then call resume to start the flow of data on the next tick.\n  if (ev === 'data' && false !== this._readableState.flowing) {\n    this.resume();\n  }\n\n  if (ev === 'readable' && this.readable) {\n    var state = this._readableState;\n    if (!state.readableListening) {\n      state.readableListening = true;\n      state.emittedReadable = false;\n      state.needReadable = true;\n      if (!state.reading) {\n        processNextTick(nReadingNextTick, this);\n      } else if (state.length) {\n        emitReadable(this, state);\n      }\n    }\n  }\n\n  return res;\n};\nReadable.prototype.addListener = Readable.prototype.on;\n\nfunction nReadingNextTick(self) {\n  debug('readable nexttick read 0');\n  self.read(0);\n}\n\n// pause() and resume() are remnants of the legacy readable stream API\n// If the user uses them, then switch into old mode.\nReadable.prototype.resume = function() {\n  var state = this._readableState;\n  if (!state.flowing) {\n    debug('resume');\n    state.flowing = true;\n    resume(this, state);\n  }\n  return this;\n};\n\nfunction resume(stream, state) {\n  if (!state.resumeScheduled) {\n    state.resumeScheduled = true;\n    processNextTick(resume_, stream, state);\n  }\n}\n\nfunction resume_(stream, state) {\n  if (!state.reading) {\n    debug('resume read 0');\n    stream.read(0);\n  }\n\n  state.resumeScheduled = false;\n  stream.emit('resume');\n  flow(stream);\n  if (state.flowing && !state.reading)\n    stream.read(0);\n}\n\nReadable.prototype.pause = function() {\n  debug('call pause flowing=%j', this._readableState.flowing);\n  if (false !== this._readableState.flowing) {\n    debug('pause');\n    this._readableState.flowing = false;\n    this.emit('pause');\n  }\n  return this;\n};\n\nfunction flow(stream) {\n  var state = stream._readableState;\n  debug('flow', state.flowing);\n  if (state.flowing) {\n    do {\n      var chunk = stream.read();\n    } while (null !== chunk && state.flowing);\n  }\n}\n\n// wrap an old-style stream as the async data source.\n// This is *not* part of the readable stream interface.\n// It is an ugly unfortunate mess of history.\nReadable.prototype.wrap = function(stream) {\n  var state = this._readableState;\n  var paused = false;\n\n  var self = this;\n  stream.on('end', function() {\n    debug('wrapped end');\n    if (state.decoder && !state.ended) {\n      var chunk = state.decoder.end();\n      if (chunk && chunk.length)\n        self.push(chunk);\n    }\n\n    self.push(null);\n  });\n\n  stream.on('data', function(chunk) {\n    debug('wrapped data');\n    if (state.decoder)\n      chunk = state.decoder.write(chunk);\n\n    // don't skip over falsy values in objectMode\n    if (state.objectMode && (chunk === null || chunk === undefined))\n      return;\n    else if (!state.objectMode && (!chunk || !chunk.length))\n      return;\n\n    var ret = self.push(chunk);\n    if (!ret) {\n      paused = true;\n      stream.pause();\n    }\n  });\n\n  // proxy all the other methods.\n  // important when wrapping filters and duplexes.\n  for (var i in stream) {\n    if (this[i] === undefined && typeof stream[i] === 'function') {\n      this[i] = function(method) { return function() {\n        return stream[method].apply(stream, arguments);\n      }; }(i);\n    }\n  }\n\n  // proxy certain important events.\n  var events = ['error', 'close', 'destroy', 'pause', 'resume'];\n  forEach(events, function(ev) {\n    stream.on(ev, self.emit.bind(self, ev));\n  });\n\n  // when we try to consume some more bytes, simply unpause the\n  // underlying stream.\n  self._read = function(n) {\n    debug('wrapped _read', n);\n    if (paused) {\n      paused = false;\n      stream.resume();\n    }\n  };\n\n  return self;\n};\n\n\n// exposed for testing purposes only.\nReadable._fromList = fromList;\n\n// Pluck off n bytes from an array of buffers.\n// Length is the combined lengths of all the buffers in the list.\nfunction fromList(n, state) {\n  var list = state.buffer;\n  var length = state.length;\n  var stringMode = !!state.decoder;\n  var objectMode = !!state.objectMode;\n  var ret;\n\n  // nothing in the list, definitely empty.\n  if (list.length === 0)\n    return null;\n\n  if (length === 0)\n    ret = null;\n  else if (objectMode)\n    ret = list.shift();\n  else if (!n || n >= length) {\n    // read it all, truncate the array.\n    if (stringMode)\n      ret = list.join('');\n    else if (list.length === 1)\n      ret = list[0];\n    else\n      ret = Buffer.concat(list, length);\n    list.length = 0;\n  } else {\n    // read just some of it.\n    if (n < list[0].length) {\n      // just take a part of the first list item.\n      // slice is the same for buffers and strings.\n      var buf = list[0];\n      ret = buf.slice(0, n);\n      list[0] = buf.slice(n);\n    } else if (n === list[0].length) {\n      // first list is a perfect match\n      ret = list.shift();\n    } else {\n      // complex case.\n      // we have enough to cover it, but it spans past the first buffer.\n      if (stringMode)\n        ret = '';\n      else\n        ret = new Buffer(n);\n\n      var c = 0;\n      for (var i = 0, l = list.length; i < l && c < n; i++) {\n        var buf = list[0];\n        var cpy = Math.min(n - c, buf.length);\n\n        if (stringMode)\n          ret += buf.slice(0, cpy);\n        else\n          buf.copy(ret, c, 0, cpy);\n\n        if (cpy < buf.length)\n          list[0] = buf.slice(cpy);\n        else\n          list.shift();\n\n        c += cpy;\n      }\n    }\n  }\n\n  return ret;\n}\n\nfunction endReadable(stream) {\n  var state = stream._readableState;\n\n  // If we get here before consuming all the bytes, then that is a\n  // bug in node.  Should never happen.\n  if (state.length > 0)\n    throw new Error('endReadable called on non-empty stream');\n\n  if (!state.endEmitted) {\n    state.ended = true;\n    processNextTick(endReadableNT, state, stream);\n  }\n}\n\nfunction endReadableNT(state, stream) {\n  // Check that we didn't get one last unshift.\n  if (!state.endEmitted && state.length === 0) {\n    state.endEmitted = true;\n    stream.readable = false;\n    stream.emit('end');\n  }\n}\n\nfunction forEach (xs, f) {\n  for (var i = 0, l = xs.length; i < l; i++) {\n    f(xs[i], i);\n  }\n}\n\nfunction indexOf (xs, x) {\n  for (var i = 0, l = xs.length; i < l; i++) {\n    if (xs[i] === x) return i;\n  }\n  return -1;\n}\n","// a transform stream is a readable/writable stream where you do\n// something with the data.  Sometimes it's called a \"filter\",\n// but that's not a great name for it, since that implies a thing where\n// some bits pass through, and others are simply ignored.  (That would\n// be a valid example of a transform, of course.)\n//\n// While the output is causally related to the input, it's not a\n// necessarily symmetric or synchronous transformation.  For example,\n// a zlib stream might take multiple plain-text writes(), and then\n// emit a single compressed chunk some time in the future.\n//\n// Here's how this works:\n//\n// The Transform stream has all the aspects of the readable and writable\n// stream classes.  When you write(chunk), that calls _write(chunk,cb)\n// internally, and returns false if there's a lot of pending writes\n// buffered up.  When you call read(), that calls _read(n) until\n// there's enough pending readable data buffered up.\n//\n// In a transform stream, the written data is placed in a buffer.  When\n// _read(n) is called, it transforms the queued up data, calling the\n// buffered _write cb's as it consumes chunks.  If consuming a single\n// written chunk would result in multiple output chunks, then the first\n// outputted bit calls the readcb, and subsequent chunks just go into\n// the read buffer, and will cause it to emit 'readable' if necessary.\n//\n// This way, back-pressure is actually determined by the reading side,\n// since _read has to be called to start processing a new chunk.  However,\n// a pathological inflate type of transform can cause excessive buffering\n// here.  For example, imagine a stream where every byte of input is\n// interpreted as an integer from 0-255, and then results in that many\n// bytes of output.  Writing the 4 bytes {ff,ff,ff,ff} would result in\n// 1kb of data being output.  In this case, you could write a very small\n// amount of input, and end up with a very large amount of output.  In\n// such a pathological inflating mechanism, there'd be no way to tell\n// the system to stop doing the transform.  A single 4MB write could\n// cause the system to run out of memory.\n//\n// However, even in such a pathological case, only a single written chunk\n// would be consumed, and then the rest would wait (un-transformed) until\n// the results of the previous transformed chunk were consumed.\n\n'use strict';\n\nmodule.exports = Transform;\n\nvar Duplex = require('./_stream_duplex');\n\n/*<replacement>*/\nvar util = require('core-util-is');\nutil.inherits = require('inherits');\n/*</replacement>*/\n\nutil.inherits(Transform, Duplex);\n\n\nfunction TransformState(stream) {\n  this.afterTransform = function(er, data) {\n    return afterTransform(stream, er, data);\n  };\n\n  this.needTransform = false;\n  this.transforming = false;\n  this.writecb = null;\n  this.writechunk = null;\n}\n\nfunction afterTransform(stream, er, data) {\n  var ts = stream._transformState;\n  ts.transforming = false;\n\n  var cb = ts.writecb;\n\n  if (!cb)\n    return stream.emit('error', new Error('no writecb in Transform class'));\n\n  ts.writechunk = null;\n  ts.writecb = null;\n\n  if (data !== null && data !== undefined)\n    stream.push(data);\n\n  if (cb)\n    cb(er);\n\n  var rs = stream._readableState;\n  rs.reading = false;\n  if (rs.needReadable || rs.length < rs.highWaterMark) {\n    stream._read(rs.highWaterMark);\n  }\n}\n\n\nfunction Transform(options) {\n  if (!(this instanceof Transform))\n    return new Transform(options);\n\n  Duplex.call(this, options);\n\n  this._transformState = new TransformState(this);\n\n  // when the writable side finishes, then flush out anything remaining.\n  var stream = this;\n\n  // start out asking for a readable event once data is transformed.\n  this._readableState.needReadable = true;\n\n  // we have implemented the _read method, and done the other things\n  // that Readable wants before the first _read call, so unset the\n  // sync guard flag.\n  this._readableState.sync = false;\n\n  if (options) {\n    if (typeof options.transform === 'function')\n      this._transform = options.transform;\n\n    if (typeof options.flush === 'function')\n      this._flush = options.flush;\n  }\n\n  this.once('prefinish', function() {\n    if (typeof this._flush === 'function')\n      this._flush(function(er) {\n        done(stream, er);\n      });\n    else\n      done(stream);\n  });\n}\n\nTransform.prototype.push = function(chunk, encoding) {\n  this._transformState.needTransform = false;\n  return Duplex.prototype.push.call(this, chunk, encoding);\n};\n\n// This is the part where you do stuff!\n// override this function in implementation classes.\n// 'chunk' is an input chunk.\n//\n// Call `push(newChunk)` to pass along transformed output\n// to the readable side.  You may call 'push' zero or more times.\n//\n// Call `cb(err)` when you are done with this chunk.  If you pass\n// an error, then that'll put the hurt on the whole operation.  If you\n// never call cb(), then you'll never get another chunk.\nTransform.prototype._transform = function(chunk, encoding, cb) {\n  throw new Error('not implemented');\n};\n\nTransform.prototype._write = function(chunk, encoding, cb) {\n  var ts = this._transformState;\n  ts.writecb = cb;\n  ts.writechunk = chunk;\n  ts.writeencoding = encoding;\n  if (!ts.transforming) {\n    var rs = this._readableState;\n    if (ts.needTransform ||\n        rs.needReadable ||\n        rs.length < rs.highWaterMark)\n      this._read(rs.highWaterMark);\n  }\n};\n\n// Doesn't matter what the args are here.\n// _transform does all the work.\n// That we got here means that the readable side wants more data.\nTransform.prototype._read = function(n) {\n  var ts = this._transformState;\n\n  if (ts.writechunk !== null && ts.writecb && !ts.transforming) {\n    ts.transforming = true;\n    this._transform(ts.writechunk, ts.writeencoding, ts.afterTransform);\n  } else {\n    // mark that we need a transform, so that any data that comes in\n    // will get processed, now that we've asked for it.\n    ts.needTransform = true;\n  }\n};\n\n\nfunction done(stream, er) {\n  if (er)\n    return stream.emit('error', er);\n\n  // if there's nothing in the write buffer, then that means\n  // that nothing more will ever be provided\n  var ws = stream._writableState;\n  var ts = stream._transformState;\n\n  if (ws.length)\n    throw new Error('calling transform done when ws.length != 0');\n\n  if (ts.transforming)\n    throw new Error('calling transform done when still transforming');\n\n  return stream.push(null);\n}\n","// A bit simpler than readable streams.\n// Implement an async ._write(chunk, encoding, cb), and it'll handle all\n// the drain event emission and buffering.\n\n'use strict';\n\nmodule.exports = Writable;\n\n/*<replacement>*/\nvar processNextTick = require('process-nextick-args');\n/*</replacement>*/\n\n\n/*<replacement>*/\nvar Buffer = require('buffer').Buffer;\n/*</replacement>*/\n\nWritable.WritableState = WritableState;\n\n\n/*<replacement>*/\nvar util = require('core-util-is');\nutil.inherits = require('inherits');\n/*</replacement>*/\n\n\n/*<replacement>*/\nvar internalUtil = {\n  deprecate: require('util-deprecate')\n};\n/*</replacement>*/\n\n\n\n/*<replacement>*/\nvar Stream;\n(function (){try{\n  Stream = require('st' + 'ream');\n}catch(_){}finally{\n  if (!Stream)\n    Stream = require('events').EventEmitter;\n}}())\n/*</replacement>*/\n\nvar Buffer = require('buffer').Buffer;\n\nutil.inherits(Writable, Stream);\n\nfunction nop() {}\n\nfunction WriteReq(chunk, encoding, cb) {\n  this.chunk = chunk;\n  this.encoding = encoding;\n  this.callback = cb;\n  this.next = null;\n}\n\nfunction WritableState(options, stream) {\n  var Duplex = require('./_stream_duplex');\n\n  options = options || {};\n\n  // object stream flag to indicate whether or not this stream\n  // contains buffers or objects.\n  this.objectMode = !!options.objectMode;\n\n  if (stream instanceof Duplex)\n    this.objectMode = this.objectMode || !!options.writableObjectMode;\n\n  // the point at which write() starts returning false\n  // Note: 0 is a valid value, means that we always return false if\n  // the entire buffer is not flushed immediately on write()\n  var hwm = options.highWaterMark;\n  var defaultHwm = this.objectMode ? 16 : 16 * 1024;\n  this.highWaterMark = (hwm || hwm === 0) ? hwm : defaultHwm;\n\n  // cast to ints.\n  this.highWaterMark = ~~this.highWaterMark;\n\n  this.needDrain = false;\n  // at the start of calling end()\n  this.ending = false;\n  // when end() has been called, and returned\n  this.ended = false;\n  // when 'finish' is emitted\n  this.finished = false;\n\n  // should we decode strings into buffers before passing to _write?\n  // this is here so that some node-core streams can optimize string\n  // handling at a lower level.\n  var noDecode = options.decodeStrings === false;\n  this.decodeStrings = !noDecode;\n\n  // Crypto is kind of old and crusty.  Historically, its default string\n  // encoding is 'binary' so we have to make this configurable.\n  // Everything else in the universe uses 'utf8', though.\n  this.defaultEncoding = options.defaultEncoding || 'utf8';\n\n  // not an actual buffer we keep track of, but a measurement\n  // of how much we're waiting to get pushed to some underlying\n  // socket or file.\n  this.length = 0;\n\n  // a flag to see when we're in the middle of a write.\n  this.writing = false;\n\n  // when true all writes will be buffered until .uncork() call\n  this.corked = 0;\n\n  // a flag to be able to tell if the onwrite cb is called immediately,\n  // or on a later tick.  We set this to true at first, because any\n  // actions that shouldn't happen until \"later\" should generally also\n  // not happen before the first write call.\n  this.sync = true;\n\n  // a flag to know if we're processing previously buffered items, which\n  // may call the _write() callback in the same tick, so that we don't\n  // end up in an overlapped onwrite situation.\n  this.bufferProcessing = false;\n\n  // the callback that's passed to _write(chunk,cb)\n  this.onwrite = function(er) {\n    onwrite(stream, er);\n  };\n\n  // the callback that the user supplies to write(chunk,encoding,cb)\n  this.writecb = null;\n\n  // the amount that is being written when _write is called.\n  this.writelen = 0;\n\n  this.bufferedRequest = null;\n  this.lastBufferedRequest = null;\n\n  // number of pending user-supplied write callbacks\n  // this must be 0 before 'finish' can be emitted\n  this.pendingcb = 0;\n\n  // emit prefinish if the only thing we're waiting for is _write cbs\n  // This is relevant for synchronous Transform streams\n  this.prefinished = false;\n\n  // True if the error was already emitted and should not be thrown again\n  this.errorEmitted = false;\n}\n\nWritableState.prototype.getBuffer = function writableStateGetBuffer() {\n  var current = this.bufferedRequest;\n  var out = [];\n  while (current) {\n    out.push(current);\n    current = current.next;\n  }\n  return out;\n};\n\n(function (){try {\nObject.defineProperty(WritableState.prototype, 'buffer', {\n  get: internalUtil.deprecate(function() {\n    return this.getBuffer();\n  }, '_writableState.buffer is deprecated. Use _writableState.getBuffer ' +\n     'instead.')\n});\n}catch(_){}}());\n\n\nfunction Writable(options) {\n  var Duplex = require('./_stream_duplex');\n\n  // Writable ctor is applied to Duplexes, though they're not\n  // instanceof Writable, they're instanceof Readable.\n  if (!(this instanceof Writable) && !(this instanceof Duplex))\n    return new Writable(options);\n\n  this._writableState = new WritableState(options, this);\n\n  // legacy.\n  this.writable = true;\n\n  if (options) {\n    if (typeof options.write === 'function')\n      this._write = options.write;\n\n    if (typeof options.writev === 'function')\n      this._writev = options.writev;\n  }\n\n  Stream.call(this);\n}\n\n// Otherwise people can pipe Writable streams, which is just wrong.\nWritable.prototype.pipe = function() {\n  this.emit('error', new Error('Cannot pipe. Not readable.'));\n};\n\n\nfunction writeAfterEnd(stream, cb) {\n  var er = new Error('write after end');\n  // TODO: defer error events consistently everywhere, not just the cb\n  stream.emit('error', er);\n  processNextTick(cb, er);\n}\n\n// If we get something that is not a buffer, string, null, or undefined,\n// and we're not in objectMode, then that's an error.\n// Otherwise stream chunks are all considered to be of length=1, and the\n// watermarks determine how many objects to keep in the buffer, rather than\n// how many bytes or characters.\nfunction validChunk(stream, state, chunk, cb) {\n  var valid = true;\n\n  if (!(Buffer.isBuffer(chunk)) &&\n      typeof chunk !== 'string' &&\n      chunk !== null &&\n      chunk !== undefined &&\n      !state.objectMode) {\n    var er = new TypeError('Invalid non-string/buffer chunk');\n    stream.emit('error', er);\n    processNextTick(cb, er);\n    valid = false;\n  }\n  return valid;\n}\n\nWritable.prototype.write = function(chunk, encoding, cb) {\n  var state = this._writableState;\n  var ret = false;\n\n  if (typeof encoding === 'function') {\n    cb = encoding;\n    encoding = null;\n  }\n\n  if (Buffer.isBuffer(chunk))\n    encoding = 'buffer';\n  else if (!encoding)\n    encoding = state.defaultEncoding;\n\n  if (typeof cb !== 'function')\n    cb = nop;\n\n  if (state.ended)\n    writeAfterEnd(this, cb);\n  else if (validChunk(this, state, chunk, cb)) {\n    state.pendingcb++;\n    ret = writeOrBuffer(this, state, chunk, encoding, cb);\n  }\n\n  return ret;\n};\n\nWritable.prototype.cork = function() {\n  var state = this._writableState;\n\n  state.corked++;\n};\n\nWritable.prototype.uncork = function() {\n  var state = this._writableState;\n\n  if (state.corked) {\n    state.corked--;\n\n    if (!state.writing &&\n        !state.corked &&\n        !state.finished &&\n        !state.bufferProcessing &&\n        state.bufferedRequest)\n      clearBuffer(this, state);\n  }\n};\n\nWritable.prototype.setDefaultEncoding = function setDefaultEncoding(encoding) {\n  // node::ParseEncoding() requires lower case.\n  if (typeof encoding === 'string')\n    encoding = encoding.toLowerCase();\n  if (!(['hex', 'utf8', 'utf-8', 'ascii', 'binary', 'base64',\n'ucs2', 'ucs-2','utf16le', 'utf-16le', 'raw']\n.indexOf((encoding + '').toLowerCase()) > -1))\n    throw new TypeError('Unknown encoding: ' + encoding);\n  this._writableState.defaultEncoding = encoding;\n};\n\nfunction decodeChunk(state, chunk, encoding) {\n  if (!state.objectMode &&\n      state.decodeStrings !== false &&\n      typeof chunk === 'string') {\n    chunk = new Buffer(chunk, encoding);\n  }\n  return chunk;\n}\n\n// if we're already writing something, then just put this\n// in the queue, and wait our turn.  Otherwise, call _write\n// If we return false, then we need a drain event, so set that flag.\nfunction writeOrBuffer(stream, state, chunk, encoding, cb) {\n  chunk = decodeChunk(state, chunk, encoding);\n\n  if (Buffer.isBuffer(chunk))\n    encoding = 'buffer';\n  var len = state.objectMode ? 1 : chunk.length;\n\n  state.length += len;\n\n  var ret = state.length < state.highWaterMark;\n  // we must ensure that previous needDrain will not be reset to false.\n  if (!ret)\n    state.needDrain = true;\n\n  if (state.writing || state.corked) {\n    var last = state.lastBufferedRequest;\n    state.lastBufferedRequest = new WriteReq(chunk, encoding, cb);\n    if (last) {\n      last.next = state.lastBufferedRequest;\n    } else {\n      state.bufferedRequest = state.lastBufferedRequest;\n    }\n  } else {\n    doWrite(stream, state, false, len, chunk, encoding, cb);\n  }\n\n  return ret;\n}\n\nfunction doWrite(stream, state, writev, len, chunk, encoding, cb) {\n  state.writelen = len;\n  state.writecb = cb;\n  state.writing = true;\n  state.sync = true;\n  if (writev)\n    stream._writev(chunk, state.onwrite);\n  else\n    stream._write(chunk, encoding, state.onwrite);\n  state.sync = false;\n}\n\nfunction onwriteError(stream, state, sync, er, cb) {\n  --state.pendingcb;\n  if (sync)\n    processNextTick(cb, er);\n  else\n    cb(er);\n\n  stream._writableState.errorEmitted = true;\n  stream.emit('error', er);\n}\n\nfunction onwriteStateUpdate(state) {\n  state.writing = false;\n  state.writecb = null;\n  state.length -= state.writelen;\n  state.writelen = 0;\n}\n\nfunction onwrite(stream, er) {\n  var state = stream._writableState;\n  var sync = state.sync;\n  var cb = state.writecb;\n\n  onwriteStateUpdate(state);\n\n  if (er)\n    onwriteError(stream, state, sync, er, cb);\n  else {\n    // Check if we're actually ready to finish, but don't emit yet\n    var finished = needFinish(state);\n\n    if (!finished &&\n        !state.corked &&\n        !state.bufferProcessing &&\n        state.bufferedRequest) {\n      clearBuffer(stream, state);\n    }\n\n    if (sync) {\n      processNextTick(afterWrite, stream, state, finished, cb);\n    } else {\n      afterWrite(stream, state, finished, cb);\n    }\n  }\n}\n\nfunction afterWrite(stream, state, finished, cb) {\n  if (!finished)\n    onwriteDrain(stream, state);\n  state.pendingcb--;\n  cb();\n  finishMaybe(stream, state);\n}\n\n// Must force callback to be called on nextTick, so that we don't\n// emit 'drain' before the write() consumer gets the 'false' return\n// value, and has a chance to attach a 'drain' listener.\nfunction onwriteDrain(stream, state) {\n  if (state.length === 0 && state.needDrain) {\n    state.needDrain = false;\n    stream.emit('drain');\n  }\n}\n\n\n// if there's something in the buffer waiting, then process it\nfunction clearBuffer(stream, state) {\n  state.bufferProcessing = true;\n  var entry = state.bufferedRequest;\n\n  if (stream._writev && entry && entry.next) {\n    // Fast case, write everything using _writev()\n    var buffer = [];\n    var cbs = [];\n    while (entry) {\n      cbs.push(entry.callback);\n      buffer.push(entry);\n      entry = entry.next;\n    }\n\n    // count the one we are adding, as well.\n    // TODO(isaacs) clean this up\n    state.pendingcb++;\n    state.lastBufferedRequest = null;\n    doWrite(stream, state, true, state.length, buffer, '', function(err) {\n      for (var i = 0; i < cbs.length; i++) {\n        state.pendingcb--;\n        cbs[i](err);\n      }\n    });\n\n    // Clear buffer\n  } else {\n    // Slow case, write chunks one-by-one\n    while (entry) {\n      var chunk = entry.chunk;\n      var encoding = entry.encoding;\n      var cb = entry.callback;\n      var len = state.objectMode ? 1 : chunk.length;\n\n      doWrite(stream, state, false, len, chunk, encoding, cb);\n      entry = entry.next;\n      // if we didn't call the onwrite immediately, then\n      // it means that we need to wait until it does.\n      // also, that means that the chunk and cb are currently\n      // being processed, so move the buffer counter past them.\n      if (state.writing) {\n        break;\n      }\n    }\n\n    if (entry === null)\n      state.lastBufferedRequest = null;\n  }\n  state.bufferedRequest = entry;\n  state.bufferProcessing = false;\n}\n\nWritable.prototype._write = function(chunk, encoding, cb) {\n  cb(new Error('not implemented'));\n};\n\nWritable.prototype._writev = null;\n\nWritable.prototype.end = function(chunk, encoding, cb) {\n  var state = this._writableState;\n\n  if (typeof chunk === 'function') {\n    cb = chunk;\n    chunk = null;\n    encoding = null;\n  } else if (typeof encoding === 'function') {\n    cb = encoding;\n    encoding = null;\n  }\n\n  if (chunk !== null && chunk !== undefined)\n    this.write(chunk, encoding);\n\n  // .end() fully uncorks\n  if (state.corked) {\n    state.corked = 1;\n    this.uncork();\n  }\n\n  // ignore unnecessary end() calls.\n  if (!state.ending && !state.finished)\n    endWritable(this, state, cb);\n};\n\n\nfunction needFinish(state) {\n  return (state.ending &&\n          state.length === 0 &&\n          state.bufferedRequest === null &&\n          !state.finished &&\n          !state.writing);\n}\n\nfunction prefinish(stream, state) {\n  if (!state.prefinished) {\n    state.prefinished = true;\n    stream.emit('prefinish');\n  }\n}\n\nfunction finishMaybe(stream, state) {\n  var need = needFinish(state);\n  if (need) {\n    if (state.pendingcb === 0) {\n      prefinish(stream, state);\n      state.finished = true;\n      stream.emit('finish');\n    } else {\n      prefinish(stream, state);\n    }\n  }\n  return need;\n}\n\nfunction endWritable(stream, state, cb) {\n  state.ending = true;\n  finishMaybe(stream, state);\n  if (cb) {\n    if (state.finished)\n      processNextTick(cb);\n    else\n      stream.once('finish', cb);\n  }\n  state.ended = true;\n}\n","// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n// NOTE: These type checking functions intentionally don't use `instanceof`\n// because it is fragile and can be easily faked with `Object.create()`.\n\nfunction isArray(arg) {\n  if (Array.isArray) {\n    return Array.isArray(arg);\n  }\n  return objectToString(arg) === '[object Array]';\n}\nexports.isArray = isArray;\n\nfunction isBoolean(arg) {\n  return typeof arg === 'boolean';\n}\nexports.isBoolean = isBoolean;\n\nfunction isNull(arg) {\n  return arg === null;\n}\nexports.isNull = isNull;\n\nfunction isNullOrUndefined(arg) {\n  return arg == null;\n}\nexports.isNullOrUndefined = isNullOrUndefined;\n\nfunction isNumber(arg) {\n  return typeof arg === 'number';\n}\nexports.isNumber = isNumber;\n\nfunction isString(arg) {\n  return typeof arg === 'string';\n}\nexports.isString = isString;\n\nfunction isSymbol(arg) {\n  return typeof arg === 'symbol';\n}\nexports.isSymbol = isSymbol;\n\nfunction isUndefined(arg) {\n  return arg === void 0;\n}\nexports.isUndefined = isUndefined;\n\nfunction isRegExp(re) {\n  return objectToString(re) === '[object RegExp]';\n}\nexports.isRegExp = isRegExp;\n\nfunction isObject(arg) {\n  return typeof arg === 'object' && arg !== null;\n}\nexports.isObject = isObject;\n\nfunction isDate(d) {\n  return objectToString(d) === '[object Date]';\n}\nexports.isDate = isDate;\n\nfunction isError(e) {\n  return (objectToString(e) === '[object Error]' || e instanceof Error);\n}\nexports.isError = isError;\n\nfunction isFunction(arg) {\n  return typeof arg === 'function';\n}\nexports.isFunction = isFunction;\n\nfunction isPrimitive(arg) {\n  return arg === null ||\n         typeof arg === 'boolean' ||\n         typeof arg === 'number' ||\n         typeof arg === 'string' ||\n         typeof arg === 'symbol' ||  // ES6 symbol\n         typeof arg === 'undefined';\n}\nexports.isPrimitive = isPrimitive;\n\nexports.isBuffer = Buffer.isBuffer;\n\nfunction objectToString(o) {\n  return Object.prototype.toString.call(o);\n}\n","'use strict';\n\nif (!process.version ||\n    process.version.indexOf('v0.') === 0 ||\n    process.version.indexOf('v1.') === 0 && process.version.indexOf('v1.8.') !== 0) {\n  module.exports = nextTick;\n} else {\n  module.exports = process.nextTick;\n}\n\nfunction nextTick(fn) {\n  var args = new Array(arguments.length - 1);\n  var i = 0;\n  while (i < args.length) {\n    args[i++] = arguments[i];\n  }\n  process.nextTick(function afterTick() {\n    fn.apply(null, args);\n  });\n}\n","\n/**\n * Module exports.\n */\n\nmodule.exports = deprecate;\n\n/**\n * Mark that a method should not be used.\n * Returns a modified function which warns once by default.\n *\n * If `localStorage.noDeprecation = true` is set, then it is a no-op.\n *\n * If `localStorage.throwDeprecation = true` is set, then deprecated functions\n * will throw an Error when invoked.\n *\n * If `localStorage.traceDeprecation = true` is set, then deprecated functions\n * will invoke `console.trace()` instead of `console.error()`.\n *\n * @param {Function} fn - the function to deprecate\n * @param {String} msg - the string to print to the console when `fn` is invoked\n * @returns {Function} a new \"deprecated\" version of `fn`\n * @api public\n */\n\nfunction deprecate (fn, msg) {\n  if (config('noDeprecation')) {\n    return fn;\n  }\n\n  var warned = false;\n  function deprecated() {\n    if (!warned) {\n      if (config('throwDeprecation')) {\n        throw new Error(msg);\n      } else if (config('traceDeprecation')) {\n        console.trace(msg);\n      } else {\n        console.warn(msg);\n      }\n      warned = true;\n    }\n    return fn.apply(this, arguments);\n  }\n\n  return deprecated;\n}\n\n/**\n * Checks `localStorage` for boolean values for the given `name`.\n *\n * @param {String} name\n * @returns {Boolean}\n * @api private\n */\n\nfunction config (name) {\n  // accessing global.localStorage can trigger a DOMException in sandboxed iframes\n  try {\n    if (!global.localStorage) return false;\n  } catch (_) {\n    return false;\n  }\n  var val = global.localStorage[name];\n  if (null == val) return false;\n  return String(val).toLowerCase() === 'true';\n}\n","module.exports = require(\"./lib/_stream_passthrough.js\")\n","var Stream = (function (){\n  try {\n    return require('st' + 'ream'); // hack to fix a circular dependency issue when used with browserify\n  } catch(_){}\n}());\nexports = module.exports = require('./lib/_stream_readable.js');\nexports.Stream = Stream || exports;\nexports.Readable = exports;\nexports.Writable = require('./lib/_stream_writable.js');\nexports.Duplex = require('./lib/_stream_duplex.js');\nexports.Transform = require('./lib/_stream_transform.js');\nexports.PassThrough = require('./lib/_stream_passthrough.js');\n","module.exports = require(\"./lib/_stream_transform.js\")\n","module.exports = require(\"./lib/_stream_writable.js\")\n","// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\nmodule.exports = Stream;\n\nvar EE = require('events').EventEmitter;\nvar inherits = require('inherits');\n\ninherits(Stream, EE);\nStream.Readable = require('readable-stream/readable.js');\nStream.Writable = require('readable-stream/writable.js');\nStream.Duplex = require('readable-stream/duplex.js');\nStream.Transform = require('readable-stream/transform.js');\nStream.PassThrough = require('readable-stream/passthrough.js');\n\n// Backwards-compat with node 0.4.x\nStream.Stream = Stream;\n\n\n\n// old-style streams.  Note that the pipe method (the only relevant\n// part of this class) is overridden in the Readable class.\n\nfunction Stream() {\n  EE.call(this);\n}\n\nStream.prototype.pipe = function(dest, options) {\n  var source = this;\n\n  function ondata(chunk) {\n    if (dest.writable) {\n      if (false === dest.write(chunk) && source.pause) {\n        source.pause();\n      }\n    }\n  }\n\n  source.on('data', ondata);\n\n  function ondrain() {\n    if (source.readable && source.resume) {\n      source.resume();\n    }\n  }\n\n  dest.on('drain', ondrain);\n\n  // If the 'end' option is not supplied, dest.end() will be called when\n  // source gets the 'end' or 'close' events.  Only dest.end() once.\n  if (!dest._isStdio && (!options || options.end !== false)) {\n    source.on('end', onend);\n    source.on('close', onclose);\n  }\n\n  var didOnEnd = false;\n  function onend() {\n    if (didOnEnd) return;\n    didOnEnd = true;\n\n    dest.end();\n  }\n\n\n  function onclose() {\n    if (didOnEnd) return;\n    didOnEnd = true;\n\n    if (typeof dest.destroy === 'function') dest.destroy();\n  }\n\n  // don't leave dangling pipes when there are errors.\n  function onerror(er) {\n    cleanup();\n    if (EE.listenerCount(this, 'error') === 0) {\n      throw er; // Unhandled stream error in pipe.\n    }\n  }\n\n  source.on('error', onerror);\n  dest.on('error', onerror);\n\n  // remove all the event listeners that were added.\n  function cleanup() {\n    source.removeListener('data', ondata);\n    dest.removeListener('drain', ondrain);\n\n    source.removeListener('end', onend);\n    source.removeListener('close', onclose);\n\n    source.removeListener('error', onerror);\n    dest.removeListener('error', onerror);\n\n    source.removeListener('end', cleanup);\n    source.removeListener('close', cleanup);\n\n    dest.removeListener('close', cleanup);\n  }\n\n  source.on('end', cleanup);\n  source.on('close', cleanup);\n\n  dest.on('close', cleanup);\n\n  dest.emit('pipe', source);\n\n  // Allow for unix-like usage: A.pipe(B).pipe(C)\n  return dest;\n};\n","var ClientRequest = require('./lib/request')\nvar extend = require('xtend')\nvar statusCodes = require('builtin-status-codes')\nvar url = require('url')\n\nvar http = exports\n\nhttp.request = function (opts, cb) {\n\tif (typeof opts === 'string')\n\t\topts = url.parse(opts)\n\telse\n\t\topts = extend(opts)\n\n\tvar protocol = opts.protocol || ''\n\tvar host = opts.hostname || opts.host\n\tvar port = opts.port\n\tvar path = opts.path || '/'\n\n\t// Necessary for IPv6 addresses\n\tif (host && host.indexOf(':') !== -1)\n\t\thost = '[' + host + ']'\n\n\t// This may be a relative url. The browser should always be able to interpret it correctly.\n\topts.url = (host ? (protocol + '//' + host) : '') + (port ? ':' + port : '') + path\n\topts.method = (opts.method || 'GET').toUpperCase()\n\topts.headers = opts.headers || {}\n\n\t// Also valid opts.auth, opts.mode\n\n\tvar req = new ClientRequest(opts)\n\tif (cb)\n\t\treq.on('response', cb)\n\treturn req\n}\n\nhttp.get = function get (opts, cb) {\n\tvar req = http.request(opts, cb)\n\treq.end()\n\treturn req\n}\n\nhttp.Agent = function () {}\nhttp.Agent.defaultMaxSockets = 4\n\nhttp.STATUS_CODES = statusCodes\n\nhttp.METHODS = [\n\t'CHECKOUT',\n\t'CONNECT',\n\t'COPY',\n\t'DELETE',\n\t'GET',\n\t'HEAD',\n\t'LOCK',\n\t'M-SEARCH',\n\t'MERGE',\n\t'MKACTIVITY',\n\t'MKCOL',\n\t'MOVE',\n\t'NOTIFY',\n\t'OPTIONS',\n\t'PATCH',\n\t'POST',\n\t'PROPFIND',\n\t'PROPPATCH',\n\t'PURGE',\n\t'PUT',\n\t'REPORT',\n\t'SEARCH',\n\t'SUBSCRIBE',\n\t'TRACE',\n\t'UNLOCK',\n\t'UNSUBSCRIBE'\n]","exports.fetch = isFunction(global.fetch) && isFunction(global.ReadableByteStream)\n\nexports.blobConstructor = false\ntry {\n\tnew Blob([new ArrayBuffer(1)])\n\texports.blobConstructor = true\n} catch (e) {}\n\nvar xhr = new global.XMLHttpRequest()\n// If location.host is empty, e.g. if this page/worker was loaded\n// from a Blob, then use example.com to avoid an error\nxhr.open('GET', global.location.host ? '/' : 'https://example.com')\n\nfunction checkTypeSupport (type) {\n\ttry {\n\t\txhr.responseType = type\n\t\treturn xhr.responseType === type\n\t} catch (e) {}\n\treturn false\n}\n\n// For some strange reason, Safari 7.0 reports typeof global.ArrayBuffer === 'object'.\n// Safari 7.1 appears to have fixed this bug.\nvar haveArrayBuffer = typeof global.ArrayBuffer !== 'undefined'\nvar haveSlice = haveArrayBuffer && isFunction(global.ArrayBuffer.prototype.slice)\n\nexports.arraybuffer = haveArrayBuffer && checkTypeSupport('arraybuffer')\n// These next two tests unavoidably show warnings in Chrome. Since fetch will always\n// be used if it's available, just return false for these to avoid the warnings.\nexports.msstream = !exports.fetch && haveSlice && checkTypeSupport('ms-stream')\nexports.mozchunkedarraybuffer = !exports.fetch && haveArrayBuffer &&\n\tcheckTypeSupport('moz-chunked-arraybuffer')\nexports.overrideMimeType = isFunction(xhr.overrideMimeType)\nexports.vbArray = isFunction(global.VBArray)\n\nfunction isFunction (value) {\n  return typeof value === 'function'\n}\n\nxhr = null // Help gc\n","// var Base64 = require('Base64')\nvar capability = require('./capability')\nvar inherits = require('inherits')\nvar response = require('./response')\nvar stream = require('stream')\n\nvar IncomingMessage = response.IncomingMessage\nvar rStates = response.readyStates\n\nfunction decideMode (preferBinary) {\n\tif (capability.fetch) {\n\t\treturn 'fetch'\n\t} else if (capability.mozchunkedarraybuffer) {\n\t\treturn 'moz-chunked-arraybuffer'\n\t} else if (capability.msstream) {\n\t\treturn 'ms-stream'\n\t} else if (capability.arraybuffer && preferBinary) {\n\t\treturn 'arraybuffer'\n\t} else if (capability.vbArray && preferBinary) {\n\t\treturn 'text:vbarray'\n\t} else {\n\t\treturn 'text'\n\t}\n}\n\nvar ClientRequest = module.exports = function (opts) {\n\tvar self = this\n\tstream.Writable.call(self)\n\n\tself._opts = opts\n\tself._body = []\n\tself._headers = {}\n\tif (opts.auth)\n\t\tself.setHeader('Authorization', 'Basic ' + new Buffer(opts.auth).toString('base64'))\n\tObject.keys(opts.headers).forEach(function (name) {\n\t\tself.setHeader(name, opts.headers[name])\n\t})\n\n\tvar preferBinary\n\tif (opts.mode === 'prefer-streaming') {\n\t\t// If streaming is a high priority but binary compatibility and\n\t\t// the accuracy of the 'content-type' header aren't\n\t\tpreferBinary = false\n\t} else if (opts.mode === 'allow-wrong-content-type') {\n\t\t// If streaming is more important than preserving the 'content-type' header\n\t\tpreferBinary = !capability.overrideMimeType\n\t} else if (!opts.mode || opts.mode === 'default' || opts.mode === 'prefer-fast') {\n\t\t// Use binary if text streaming may corrupt data or the content-type header, or for speed\n\t\tpreferBinary = true\n\t} else {\n\t\tthrow new Error('Invalid value for opts.mode')\n\t}\n\tself._mode = decideMode(preferBinary)\n\n\tself.on('finish', function () {\n\t\tself._onFinish()\n\t})\n}\n\ninherits(ClientRequest, stream.Writable)\n\nClientRequest.prototype.setHeader = function (name, value) {\n\tvar self = this\n\tvar lowerName = name.toLowerCase()\n\t// This check is not necessary, but it prevents warnings from browsers about setting unsafe\n\t// headers. To be honest I'm not entirely sure hiding these warnings is a good thing, but\n\t// http-browserify did it, so I will too.\n\tif (unsafeHeaders.indexOf(lowerName) !== -1)\n\t\treturn\n\n\tself._headers[lowerName] = {\n\t\tname: name,\n\t\tvalue: value\n\t}\n}\n\nClientRequest.prototype.getHeader = function (name) {\n\tvar self = this\n\treturn self._headers[name.toLowerCase()].value\n}\n\nClientRequest.prototype.removeHeader = function (name) {\n\tvar self = this\n\tdelete self._headers[name.toLowerCase()]\n}\n\nClientRequest.prototype._onFinish = function () {\n\tvar self = this\n\n\tif (self._destroyed)\n\t\treturn\n\tvar opts = self._opts\n\n\tvar headersObj = self._headers\n\tvar body\n\tif (opts.method === 'POST' || opts.method === 'PUT' || opts.method === 'PATCH') {\n\t\tif (capability.blobConstructor) {\n\t\t\tbody = new global.Blob(self._body.map(function (buffer) {\n\t\t\t\treturn buffer.toArrayBuffer()\n\t\t\t}), {\n\t\t\t\ttype: (headersObj['content-type'] || {}).value || ''\n\t\t\t})\n\t\t} else {\n\t\t\t// get utf8 string\n\t\t\tbody = Buffer.concat(self._body).toString()\n\t\t}\n\t}\n\n\tif (self._mode === 'fetch') {\n\t\tvar headers = Object.keys(headersObj).map(function (name) {\n\t\t\treturn [headersObj[name].name, headersObj[name].value]\n\t\t})\n\n\t\tglobal.fetch(self._opts.url, {\n\t\t\tmethod: self._opts.method,\n\t\t\theaders: headers,\n\t\t\tbody: body,\n\t\t\tmode: 'cors',\n\t\t\tcredentials: opts.withCredentials ? 'include' : 'same-origin'\n\t\t}).then(function (response) {\n\t\t\tself._fetchResponse = response\n\t\t\tself._connect()\n\t\t}, function (reason) {\n\t\t\tself.emit('error', reason)\n\t\t})\n\t} else {\n\t\tvar xhr = self._xhr = new global.XMLHttpRequest()\n\t\ttry {\n\t\t\txhr.open(self._opts.method, self._opts.url, true)\n\t\t} catch (err) {\n\t\t\tprocess.nextTick(function () {\n\t\t\t\tself.emit('error', err)\n\t\t\t})\n\t\t\treturn\n\t\t}\n\n\t\t// Can't set responseType on really old browsers\n\t\tif ('responseType' in xhr)\n\t\t\txhr.responseType = self._mode.split(':')[0]\n\n\t\tif ('withCredentials' in xhr)\n\t\t\txhr.withCredentials = !!opts.withCredentials\n\n\t\tif (self._mode === 'text' && 'overrideMimeType' in xhr)\n\t\t\txhr.overrideMimeType('text/plain; charset=x-user-defined')\n\n\t\tObject.keys(headersObj).forEach(function (name) {\n\t\t\txhr.setRequestHeader(headersObj[name].name, headersObj[name].value)\n\t\t})\n\n\t\tself._response = null\n\t\txhr.onreadystatechange = function () {\n\t\t\tswitch (xhr.readyState) {\n\t\t\t\tcase rStates.LOADING:\n\t\t\t\tcase rStates.DONE:\n\t\t\t\t\tself._onXHRProgress()\n\t\t\t\t\tbreak\n\t\t\t}\n\t\t}\n\t\t// Necessary for streaming in Firefox, since xhr.response is ONLY defined\n\t\t// in onprogress, not in onreadystatechange with xhr.readyState = 3\n\t\tif (self._mode === 'moz-chunked-arraybuffer') {\n\t\t\txhr.onprogress = function () {\n\t\t\t\tself._onXHRProgress()\n\t\t\t}\n\t\t}\n\n\t\txhr.onerror = function () {\n\t\t\tif (self._destroyed)\n\t\t\t\treturn\n\t\t\tself.emit('error', new Error('XHR error'))\n\t\t}\n\n\t\ttry {\n\t\t\txhr.send(body)\n\t\t} catch (err) {\n\t\t\tprocess.nextTick(function () {\n\t\t\t\tself.emit('error', err)\n\t\t\t})\n\t\t\treturn\n\t\t}\n\t}\n}\n\n/**\n * Checks if xhr.status is readable. Even though the spec says it should\n * be available in readyState 3, accessing it throws an exception in IE8\n */\nfunction statusValid (xhr) {\n\ttry {\n\t\treturn (xhr.status !== null)\n\t} catch (e) {\n\t\treturn false\n\t}\n}\n\nClientRequest.prototype._onXHRProgress = function () {\n\tvar self = this\n\n\tif (!statusValid(self._xhr) || self._destroyed)\n\t\treturn\n\n\tif (!self._response)\n\t\tself._connect()\n\n\tself._response._onXHRProgress()\n}\n\nClientRequest.prototype._connect = function () {\n\tvar self = this\n\n\tif (self._destroyed)\n\t\treturn\n\n\tself._response = new IncomingMessage(self._xhr, self._fetchResponse, self._mode)\n\tself.emit('response', self._response)\n}\n\nClientRequest.prototype._write = function (chunk, encoding, cb) {\n\tvar self = this\n\n\tself._body.push(chunk)\n\tcb()\n}\n\nClientRequest.prototype.abort = ClientRequest.prototype.destroy = function () {\n\tvar self = this\n\tself._destroyed = true\n\tif (self._response)\n\t\tself._response._destroyed = true\n\tif (self._xhr)\n\t\tself._xhr.abort()\n\t// Currently, there isn't a way to truly abort a fetch.\n\t// If you like bikeshedding, see https://github.com/whatwg/fetch/issues/27\n}\n\nClientRequest.prototype.end = function (data, encoding, cb) {\n\tvar self = this\n\tif (typeof data === 'function') {\n\t\tcb = data\n\t\tdata = undefined\n\t}\n\n\tstream.Writable.prototype.end.call(self, data, encoding, cb)\n}\n\nClientRequest.prototype.flushHeaders = function () {}\nClientRequest.prototype.setTimeout = function () {}\nClientRequest.prototype.setNoDelay = function () {}\nClientRequest.prototype.setSocketKeepAlive = function () {}\n\n// Taken from http://www.w3.org/TR/XMLHttpRequest/#the-setrequestheader%28%29-method\nvar unsafeHeaders = [\n\t'accept-charset',\n\t'accept-encoding',\n\t'access-control-request-headers',\n\t'access-control-request-method',\n\t'connection',\n\t'content-length',\n\t'cookie',\n\t'cookie2',\n\t'date',\n\t'dnt',\n\t'expect',\n\t'host',\n\t'keep-alive',\n\t'origin',\n\t'referer',\n\t'te',\n\t'trailer',\n\t'transfer-encoding',\n\t'upgrade',\n\t'user-agent',\n\t'via'\n]\n","var capability = require('./capability')\nvar inherits = require('inherits')\nvar stream = require('stream')\n\nvar rStates = exports.readyStates = {\n\tUNSENT: 0,\n\tOPENED: 1,\n\tHEADERS_RECEIVED: 2,\n\tLOADING: 3,\n\tDONE: 4\n}\n\nvar IncomingMessage = exports.IncomingMessage = function (xhr, response, mode) {\n\tvar self = this\n\tstream.Readable.call(self)\n\n\tself._mode = mode\n\tself.headers = {}\n\tself.rawHeaders = []\n\tself.trailers = {}\n\tself.rawTrailers = []\n\n\t// Fake the 'close' event, but only once 'end' fires\n\tself.on('end', function () {\n\t\t// The nextTick is necessary to prevent the 'request' module from causing an infinite loop\n\t\tprocess.nextTick(function () {\n\t\t\tself.emit('close')\n\t\t})\n\t})\n\n\tif (mode === 'fetch') {\n\t\tself._fetchResponse = response\n\n\t\tself.statusCode = response.status\n\t\tself.statusMessage = response.statusText\n\t\t// backwards compatible version of for (<item> of <iterable>):\n\t\t// for (var <item>,_i,_it = <iterable>[Symbol.iterator](); <item> = (_i = _it.next()).value,!_i.done;)\n\t\tfor (var header, _i, _it = response.headers[Symbol.iterator](); header = (_i = _it.next()).value, !_i.done;) {\n\t\t\tself.headers[header[0].toLowerCase()] = header[1]\n\t\t\tself.rawHeaders.push(header[0], header[1])\n\t\t}\n\n\t\t// TODO: this doesn't respect backpressure. Once WritableStream is available, this can be fixed\n\t\tvar reader = response.body.getReader()\n\t\tfunction read () {\n\t\t\treader.read().then(function (result) {\n\t\t\t\tif (self._destroyed)\n\t\t\t\t\treturn\n\t\t\t\tif (result.done) {\n\t\t\t\t\tself.push(null)\n\t\t\t\t\treturn\n\t\t\t\t}\n\t\t\t\tself.push(new Buffer(result.value))\n\t\t\t\tread()\n\t\t\t})\n\t\t}\n\t\tread()\n\n\t} else {\n\t\tself._xhr = xhr\n\t\tself._pos = 0\n\n\t\tself.statusCode = xhr.status\n\t\tself.statusMessage = xhr.statusText\n\t\tvar headers = xhr.getAllResponseHeaders().split(/\\r?\\n/)\n\t\theaders.forEach(function (header) {\n\t\t\tvar matches = header.match(/^([^:]+):\\s*(.*)/)\n\t\t\tif (matches) {\n\t\t\t\tvar key = matches[1].toLowerCase()\n\t\t\t\tif (self.headers[key] !== undefined)\n\t\t\t\t\tself.headers[key] += ', ' + matches[2]\n\t\t\t\telse\n\t\t\t\t\tself.headers[key] = matches[2]\n\t\t\t\tself.rawHeaders.push(matches[1], matches[2])\n\t\t\t}\n\t\t})\n\n\t\tself._charset = 'x-user-defined'\n\t\tif (!capability.overrideMimeType) {\n\t\t\tvar mimeType = self.rawHeaders['mime-type']\n\t\t\tif (mimeType) {\n\t\t\t\tvar charsetMatch = mimeType.match(/;\\s*charset=([^;])(;|$)/)\n\t\t\t\tif (charsetMatch) {\n\t\t\t\t\tself._charset = charsetMatch[1].toLowerCase()\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (!self._charset)\n\t\t\t\tself._charset = 'utf-8' // best guess\n\t\t}\n\t}\n}\n\ninherits(IncomingMessage, stream.Readable)\n\nIncomingMessage.prototype._read = function () {}\n\nIncomingMessage.prototype._onXHRProgress = function () {\n\tvar self = this\n\n\tvar xhr = self._xhr\n\n\tvar response = null\n\tswitch (self._mode) {\n\t\tcase 'text:vbarray': // For IE9\n\t\t\tif (xhr.readyState !== rStates.DONE)\n\t\t\t\tbreak\n\t\t\ttry {\n\t\t\t\t// This fails in IE8\n\t\t\t\tresponse = new global.VBArray(xhr.responseBody).toArray()\n\t\t\t} catch (e) {}\n\t\t\tif (response !== null) {\n\t\t\t\tself.push(new Buffer(response))\n\t\t\t\tbreak\n\t\t\t}\n\t\t\t// Falls through in IE8\t\n\t\tcase 'text':\n\t\t\ttry { // This will fail when readyState = 3 in IE9. Switch mode and wait for readyState = 4\n\t\t\t\tresponse = xhr.responseText\n\t\t\t} catch (e) {\n\t\t\t\tself._mode = 'text:vbarray'\n\t\t\t\tbreak\n\t\t\t}\n\t\t\tif (response.length > self._pos) {\n\t\t\t\tvar newData = response.substr(self._pos)\n\t\t\t\tif (self._charset === 'x-user-defined') {\n\t\t\t\t\tvar buffer = new Buffer(newData.length)\n\t\t\t\t\tfor (var i = 0; i < newData.length; i++)\n\t\t\t\t\t\tbuffer[i] = newData.charCodeAt(i) & 0xff\n\n\t\t\t\t\tself.push(buffer)\n\t\t\t\t} else {\n\t\t\t\t\tself.push(newData, self._charset)\n\t\t\t\t}\n\t\t\t\tself._pos = response.length\n\t\t\t}\n\t\t\tbreak\n\t\tcase 'arraybuffer':\n\t\t\tif (xhr.readyState !== rStates.DONE)\n\t\t\t\tbreak\n\t\t\tresponse = xhr.response\n\t\t\tself.push(new Buffer(new Uint8Array(response)))\n\t\t\tbreak\n\t\tcase 'moz-chunked-arraybuffer': // take whole\n\t\t\tresponse = xhr.response\n\t\t\tif (xhr.readyState !== rStates.LOADING || !response)\n\t\t\t\tbreak\n\t\t\tself.push(new Buffer(new Uint8Array(response)))\n\t\t\tbreak\n\t\tcase 'ms-stream':\n\t\t\tresponse = xhr.response\n\t\t\tif (xhr.readyState !== rStates.LOADING)\n\t\t\t\tbreak\n\t\t\tvar reader = new global.MSStreamReader()\n\t\t\treader.onprogress = function () {\n\t\t\t\tif (reader.result.byteLength > self._pos) {\n\t\t\t\t\tself.push(new Buffer(new Uint8Array(reader.result.slice(self._pos))))\n\t\t\t\t\tself._pos = reader.result.byteLength\n\t\t\t\t}\n\t\t\t}\n\t\t\treader.onload = function () {\n\t\t\t\tself.push(null)\n\t\t\t}\n\t\t\t// reader.onerror = ??? // TODO: this\n\t\t\treader.readAsArrayBuffer(response)\n\t\t\tbreak\n\t}\n\n\t// The ms-stream case handles end separately in reader.onload()\n\tif (self._xhr.readyState === rStates.DONE && self._mode !== 'ms-stream') {\n\t\tself.push(null)\n\t}\n}\n","module.exports = {\n  \"100\": \"Continue\",\n  \"101\": \"Switching Protocols\",\n  \"102\": \"Processing\",\n  \"200\": \"OK\",\n  \"201\": \"Created\",\n  \"202\": \"Accepted\",\n  \"203\": \"Non-Authoritative Information\",\n  \"204\": \"No Content\",\n  \"205\": \"Reset Content\",\n  \"206\": \"Partial Content\",\n  \"207\": \"Multi-Status\",\n  \"300\": \"Multiple Choices\",\n  \"301\": \"Moved Permanently\",\n  \"302\": \"Moved Temporarily\",\n  \"303\": \"See Other\",\n  \"304\": \"Not Modified\",\n  \"305\": \"Use Proxy\",\n  \"307\": \"Temporary Redirect\",\n  \"308\": \"Permanent Redirect\",\n  \"400\": \"Bad Request\",\n  \"401\": \"Unauthorized\",\n  \"402\": \"Payment Required\",\n  \"403\": \"Forbidden\",\n  \"404\": \"Not Found\",\n  \"405\": \"Method Not Allowed\",\n  \"406\": \"Not Acceptable\",\n  \"407\": \"Proxy Authentication Required\",\n  \"408\": \"Request Time-out\",\n  \"409\": \"Conflict\",\n  \"410\": \"Gone\",\n  \"411\": \"Length Required\",\n  \"412\": \"Precondition Failed\",\n  \"413\": \"Request Entity Too Large\",\n  \"414\": \"Request-URI Too Large\",\n  \"415\": \"Unsupported Media Type\",\n  \"416\": \"Requested Range Not Satisfiable\",\n  \"417\": \"Expectation Failed\",\n  \"418\": \"I'm a teapot\",\n  \"422\": \"Unprocessable Entity\",\n  \"423\": \"Locked\",\n  \"424\": \"Failed Dependency\",\n  \"425\": \"Unordered Collection\",\n  \"426\": \"Upgrade Required\",\n  \"428\": \"Precondition Required\",\n  \"429\": \"Too Many Requests\",\n  \"431\": \"Request Header Fields Too Large\",\n  \"500\": \"Internal Server Error\",\n  \"501\": \"Not Implemented\",\n  \"502\": \"Bad Gateway\",\n  \"503\": \"Service Unavailable\",\n  \"504\": \"Gateway Time-out\",\n  \"505\": \"HTTP Version Not Supported\",\n  \"506\": \"Variant Also Negotiates\",\n  \"507\": \"Insufficient Storage\",\n  \"509\": \"Bandwidth Limit Exceeded\",\n  \"510\": \"Not Extended\",\n  \"511\": \"Network Authentication Required\"\n}\n","// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\nvar Buffer = require('buffer').Buffer;\n\nvar isBufferEncoding = Buffer.isEncoding\n  || function(encoding) {\n       switch (encoding && encoding.toLowerCase()) {\n         case 'hex': case 'utf8': case 'utf-8': case 'ascii': case 'binary': case 'base64': case 'ucs2': case 'ucs-2': case 'utf16le': case 'utf-16le': case 'raw': return true;\n         default: return false;\n       }\n     }\n\n\nfunction assertEncoding(encoding) {\n  if (encoding && !isBufferEncoding(encoding)) {\n    throw new Error('Unknown encoding: ' + encoding);\n  }\n}\n\n// StringDecoder provides an interface for efficiently splitting a series of\n// buffers into a series of JS strings without breaking apart multi-byte\n// characters. CESU-8 is handled as part of the UTF-8 encoding.\n//\n// @TODO Handling all encodings inside a single object makes it very difficult\n// to reason about this code, so it should be split up in the future.\n// @TODO There should be a utf8-strict encoding that rejects invalid UTF-8 code\n// points as used by CESU-8.\nvar StringDecoder = exports.StringDecoder = function(encoding) {\n  this.encoding = (encoding || 'utf8').toLowerCase().replace(/[-_]/, '');\n  assertEncoding(encoding);\n  switch (this.encoding) {\n    case 'utf8':\n      // CESU-8 represents each of Surrogate Pair by 3-bytes\n      this.surrogateSize = 3;\n      break;\n    case 'ucs2':\n    case 'utf16le':\n      // UTF-16 represents each of Surrogate Pair by 2-bytes\n      this.surrogateSize = 2;\n      this.detectIncompleteChar = utf16DetectIncompleteChar;\n      break;\n    case 'base64':\n      // Base-64 stores 3 bytes in 4 chars, and pads the remainder.\n      this.surrogateSize = 3;\n      this.detectIncompleteChar = base64DetectIncompleteChar;\n      break;\n    default:\n      this.write = passThroughWrite;\n      return;\n  }\n\n  // Enough space to store all bytes of a single character. UTF-8 needs 4\n  // bytes, but CESU-8 may require up to 6 (3 bytes per surrogate).\n  this.charBuffer = new Buffer(6);\n  // Number of bytes received for the current incomplete multi-byte character.\n  this.charReceived = 0;\n  // Number of bytes expected for the current incomplete multi-byte character.\n  this.charLength = 0;\n};\n\n\n// write decodes the given buffer and returns it as JS string that is\n// guaranteed to not contain any partial multi-byte characters. Any partial\n// character found at the end of the buffer is buffered up, and will be\n// returned when calling write again with the remaining bytes.\n//\n// Note: Converting a Buffer containing an orphan surrogate to a String\n// currently works, but converting a String to a Buffer (via `new Buffer`, or\n// Buffer#write) will replace incomplete surrogates with the unicode\n// replacement character. See https://codereview.chromium.org/121173009/ .\nStringDecoder.prototype.write = function(buffer) {\n  var charStr = '';\n  // if our last write ended with an incomplete multibyte character\n  while (this.charLength) {\n    // determine how many remaining bytes this buffer has to offer for this char\n    var available = (buffer.length >= this.charLength - this.charReceived) ?\n        this.charLength - this.charReceived :\n        buffer.length;\n\n    // add the new bytes to the char buffer\n    buffer.copy(this.charBuffer, this.charReceived, 0, available);\n    this.charReceived += available;\n\n    if (this.charReceived < this.charLength) {\n      // still not enough chars in this buffer? wait for more ...\n      return '';\n    }\n\n    // remove bytes belonging to the current character from the buffer\n    buffer = buffer.slice(available, buffer.length);\n\n    // get the character that was split\n    charStr = this.charBuffer.slice(0, this.charLength).toString(this.encoding);\n\n    // CESU-8: lead surrogate (D800-DBFF) is also the incomplete character\n    var charCode = charStr.charCodeAt(charStr.length - 1);\n    if (charCode >= 0xD800 && charCode <= 0xDBFF) {\n      this.charLength += this.surrogateSize;\n      charStr = '';\n      continue;\n    }\n    this.charReceived = this.charLength = 0;\n\n    // if there are no more bytes in this buffer, just emit our char\n    if (buffer.length === 0) {\n      return charStr;\n    }\n    break;\n  }\n\n  // determine and set charLength / charReceived\n  this.detectIncompleteChar(buffer);\n\n  var end = buffer.length;\n  if (this.charLength) {\n    // buffer the incomplete character bytes we got\n    buffer.copy(this.charBuffer, 0, buffer.length - this.charReceived, end);\n    end -= this.charReceived;\n  }\n\n  charStr += buffer.toString(this.encoding, 0, end);\n\n  var end = charStr.length - 1;\n  var charCode = charStr.charCodeAt(end);\n  // CESU-8: lead surrogate (D800-DBFF) is also the incomplete character\n  if (charCode >= 0xD800 && charCode <= 0xDBFF) {\n    var size = this.surrogateSize;\n    this.charLength += size;\n    this.charReceived += size;\n    this.charBuffer.copy(this.charBuffer, size, 0, size);\n    buffer.copy(this.charBuffer, 0, 0, size);\n    return charStr.substring(0, end);\n  }\n\n  // or just emit the charStr\n  return charStr;\n};\n\n// detectIncompleteChar determines if there is an incomplete UTF-8 character at\n// the end of the given buffer. If so, it sets this.charLength to the byte\n// length that character, and sets this.charReceived to the number of bytes\n// that are available for this character.\nStringDecoder.prototype.detectIncompleteChar = function(buffer) {\n  // determine how many bytes we have to check at the end of this buffer\n  var i = (buffer.length >= 3) ? 3 : buffer.length;\n\n  // Figure out if one of the last i bytes of our buffer announces an\n  // incomplete char.\n  for (; i > 0; i--) {\n    var c = buffer[buffer.length - i];\n\n    // See http://en.wikipedia.org/wiki/UTF-8#Description\n\n    // 110XXXXX\n    if (i == 1 && c >> 5 == 0x06) {\n      this.charLength = 2;\n      break;\n    }\n\n    // 1110XXXX\n    if (i <= 2 && c >> 4 == 0x0E) {\n      this.charLength = 3;\n      break;\n    }\n\n    // 11110XXX\n    if (i <= 3 && c >> 3 == 0x1E) {\n      this.charLength = 4;\n      break;\n    }\n  }\n  this.charReceived = i;\n};\n\nStringDecoder.prototype.end = function(buffer) {\n  var res = '';\n  if (buffer && buffer.length)\n    res = this.write(buffer);\n\n  if (this.charReceived) {\n    var cr = this.charReceived;\n    var buf = this.charBuffer;\n    var enc = this.encoding;\n    res += buf.slice(0, cr).toString(enc);\n  }\n\n  return res;\n};\n\nfunction passThroughWrite(buffer) {\n  return buffer.toString(this.encoding);\n}\n\nfunction utf16DetectIncompleteChar(buffer) {\n  this.charReceived = buffer.length % 2;\n  this.charLength = this.charReceived ? 2 : 0;\n}\n\nfunction base64DetectIncompleteChar(buffer) {\n  this.charReceived = buffer.length % 3;\n  this.charLength = this.charReceived ? 3 : 0;\n}\n","// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n'use strict';\n\nvar punycode = require('punycode');\nvar util = require('./util');\n\nexports.parse = urlParse;\nexports.resolve = urlResolve;\nexports.resolveObject = urlResolveObject;\nexports.format = urlFormat;\n\nexports.Url = Url;\n\nfunction Url() {\n  this.protocol = null;\n  this.slashes = null;\n  this.auth = null;\n  this.host = null;\n  this.port = null;\n  this.hostname = null;\n  this.hash = null;\n  this.search = null;\n  this.query = null;\n  this.pathname = null;\n  this.path = null;\n  this.href = null;\n}\n\n// Reference: RFC 3986, RFC 1808, RFC 2396\n\n// define these here so at least they only have to be\n// compiled once on the first module load.\nvar protocolPattern = /^([a-z0-9.+-]+:)/i,\n    portPattern = /:[0-9]*$/,\n\n    // Special case for a simple path URL\n    simplePathPattern = /^(\\/\\/?(?!\\/)[^\\?\\s]*)(\\?[^\\s]*)?$/,\n\n    // RFC 2396: characters reserved for delimiting URLs.\n    // We actually just auto-escape these.\n    delims = ['<', '>', '\"', '`', ' ', '\\r', '\\n', '\\t'],\n\n    // RFC 2396: characters not allowed for various reasons.\n    unwise = ['{', '}', '|', '\\\\', '^', '`'].concat(delims),\n\n    // Allowed by RFCs, but cause of XSS attacks.  Always escape these.\n    autoEscape = ['\\''].concat(unwise),\n    // Characters that are never ever allowed in a hostname.\n    // Note that any invalid chars are also handled, but these\n    // are the ones that are *expected* to be seen, so we fast-path\n    // them.\n    nonHostChars = ['%', '/', '?', ';', '#'].concat(autoEscape),\n    hostEndingChars = ['/', '?', '#'],\n    hostnameMaxLen = 255,\n    hostnamePartPattern = /^[+a-z0-9A-Z_-]{0,63}$/,\n    hostnamePartStart = /^([+a-z0-9A-Z_-]{0,63})(.*)$/,\n    // protocols that can allow \"unsafe\" and \"unwise\" chars.\n    unsafeProtocol = {\n      'javascript': true,\n      'javascript:': true\n    },\n    // protocols that never have a hostname.\n    hostlessProtocol = {\n      'javascript': true,\n      'javascript:': true\n    },\n    // protocols that always contain a // bit.\n    slashedProtocol = {\n      'http': true,\n      'https': true,\n      'ftp': true,\n      'gopher': true,\n      'file': true,\n      'http:': true,\n      'https:': true,\n      'ftp:': true,\n      'gopher:': true,\n      'file:': true\n    },\n    querystring = require('querystring');\n\nfunction urlParse(url, parseQueryString, slashesDenoteHost) {\n  if (url && util.isObject(url) && url instanceof Url) return url;\n\n  var u = new Url;\n  u.parse(url, parseQueryString, slashesDenoteHost);\n  return u;\n}\n\nUrl.prototype.parse = function(url, parseQueryString, slashesDenoteHost) {\n  if (!util.isString(url)) {\n    throw new TypeError(\"Parameter 'url' must be a string, not \" + typeof url);\n  }\n\n  // Copy chrome, IE, opera backslash-handling behavior.\n  // Back slashes before the query string get converted to forward slashes\n  // See: https://code.google.com/p/chromium/issues/detail?id=25916\n  var queryIndex = url.indexOf('?'),\n      splitter =\n          (queryIndex !== -1 && queryIndex < url.indexOf('#')) ? '?' : '#',\n      uSplit = url.split(splitter),\n      slashRegex = /\\\\/g;\n  uSplit[0] = uSplit[0].replace(slashRegex, '/');\n  url = uSplit.join(splitter);\n\n  var rest = url;\n\n  // trim before proceeding.\n  // This is to support parse stuff like \"  http://foo.com  \\n\"\n  rest = rest.trim();\n\n  if (!slashesDenoteHost && url.split('#').length === 1) {\n    // Try fast path regexp\n    var simplePath = simplePathPattern.exec(rest);\n    if (simplePath) {\n      this.path = rest;\n      this.href = rest;\n      this.pathname = simplePath[1];\n      if (simplePath[2]) {\n        this.search = simplePath[2];\n        if (parseQueryString) {\n          this.query = querystring.parse(this.search.substr(1));\n        } else {\n          this.query = this.search.substr(1);\n        }\n      } else if (parseQueryString) {\n        this.search = '';\n        this.query = {};\n      }\n      return this;\n    }\n  }\n\n  var proto = protocolPattern.exec(rest);\n  if (proto) {\n    proto = proto[0];\n    var lowerProto = proto.toLowerCase();\n    this.protocol = lowerProto;\n    rest = rest.substr(proto.length);\n  }\n\n  // figure out if it's got a host\n  // user@server is *always* interpreted as a hostname, and url\n  // resolution will treat //foo/bar as host=foo,path=bar because that's\n  // how the browser resolves relative URLs.\n  if (slashesDenoteHost || proto || rest.match(/^\\/\\/[^@\\/]+@[^@\\/]+/)) {\n    var slashes = rest.substr(0, 2) === '//';\n    if (slashes && !(proto && hostlessProtocol[proto])) {\n      rest = rest.substr(2);\n      this.slashes = true;\n    }\n  }\n\n  if (!hostlessProtocol[proto] &&\n      (slashes || (proto && !slashedProtocol[proto]))) {\n\n    // there's a hostname.\n    // the first instance of /, ?, ;, or # ends the host.\n    //\n    // If there is an @ in the hostname, then non-host chars *are* allowed\n    // to the left of the last @ sign, unless some host-ending character\n    // comes *before* the @-sign.\n    // URLs are obnoxious.\n    //\n    // ex:\n    // http://a@b@c/ => user:a@b host:c\n    // http://a@b?@c => user:a host:c path:/?@c\n\n    // v0.12 TODO(isaacs): This is not quite how Chrome does things.\n    // Review our test case against browsers more comprehensively.\n\n    // find the first instance of any hostEndingChars\n    var hostEnd = -1;\n    for (var i = 0; i < hostEndingChars.length; i++) {\n      var hec = rest.indexOf(hostEndingChars[i]);\n      if (hec !== -1 && (hostEnd === -1 || hec < hostEnd))\n        hostEnd = hec;\n    }\n\n    // at this point, either we have an explicit point where the\n    // auth portion cannot go past, or the last @ char is the decider.\n    var auth, atSign;\n    if (hostEnd === -1) {\n      // atSign can be anywhere.\n      atSign = rest.lastIndexOf('@');\n    } else {\n      // atSign must be in auth portion.\n      // http://a@b/c@d => host:b auth:a path:/c@d\n      atSign = rest.lastIndexOf('@', hostEnd);\n    }\n\n    // Now we have a portion which is definitely the auth.\n    // Pull that off.\n    if (atSign !== -1) {\n      auth = rest.slice(0, atSign);\n      rest = rest.slice(atSign + 1);\n      this.auth = decodeURIComponent(auth);\n    }\n\n    // the host is the remaining to the left of the first non-host char\n    hostEnd = -1;\n    for (var i = 0; i < nonHostChars.length; i++) {\n      var hec = rest.indexOf(nonHostChars[i]);\n      if (hec !== -1 && (hostEnd === -1 || hec < hostEnd))\n        hostEnd = hec;\n    }\n    // if we still have not hit it, then the entire thing is a host.\n    if (hostEnd === -1)\n      hostEnd = rest.length;\n\n    this.host = rest.slice(0, hostEnd);\n    rest = rest.slice(hostEnd);\n\n    // pull out port.\n    this.parseHost();\n\n    // we've indicated that there is a hostname,\n    // so even if it's empty, it has to be present.\n    this.hostname = this.hostname || '';\n\n    // if hostname begins with [ and ends with ]\n    // assume that it's an IPv6 address.\n    var ipv6Hostname = this.hostname[0] === '[' &&\n        this.hostname[this.hostname.length - 1] === ']';\n\n    // validate a little.\n    if (!ipv6Hostname) {\n      var hostparts = this.hostname.split(/\\./);\n      for (var i = 0, l = hostparts.length; i < l; i++) {\n        var part = hostparts[i];\n        if (!part) continue;\n        if (!part.match(hostnamePartPattern)) {\n          var newpart = '';\n          for (var j = 0, k = part.length; j < k; j++) {\n            if (part.charCodeAt(j) > 127) {\n              // we replace non-ASCII char with a temporary placeholder\n              // we need this to make sure size of hostname is not\n              // broken by replacing non-ASCII by nothing\n              newpart += 'x';\n            } else {\n              newpart += part[j];\n            }\n          }\n          // we test again with ASCII char only\n          if (!newpart.match(hostnamePartPattern)) {\n            var validParts = hostparts.slice(0, i);\n            var notHost = hostparts.slice(i + 1);\n            var bit = part.match(hostnamePartStart);\n            if (bit) {\n              validParts.push(bit[1]);\n              notHost.unshift(bit[2]);\n            }\n            if (notHost.length) {\n              rest = '/' + notHost.join('.') + rest;\n            }\n            this.hostname = validParts.join('.');\n            break;\n          }\n        }\n      }\n    }\n\n    if (this.hostname.length > hostnameMaxLen) {\n      this.hostname = '';\n    } else {\n      // hostnames are always lower case.\n      this.hostname = this.hostname.toLowerCase();\n    }\n\n    if (!ipv6Hostname) {\n      // IDNA Support: Returns a punycoded representation of \"domain\".\n      // It only converts parts of the domain name that\n      // have non-ASCII characters, i.e. it doesn't matter if\n      // you call it with a domain that already is ASCII-only.\n      this.hostname = punycode.toASCII(this.hostname);\n    }\n\n    var p = this.port ? ':' + this.port : '';\n    var h = this.hostname || '';\n    this.host = h + p;\n    this.href += this.host;\n\n    // strip [ and ] from the hostname\n    // the host field still retains them, though\n    if (ipv6Hostname) {\n      this.hostname = this.hostname.substr(1, this.hostname.length - 2);\n      if (rest[0] !== '/') {\n        rest = '/' + rest;\n      }\n    }\n  }\n\n  // now rest is set to the post-host stuff.\n  // chop off any delim chars.\n  if (!unsafeProtocol[lowerProto]) {\n\n    // First, make 100% sure that any \"autoEscape\" chars get\n    // escaped, even if encodeURIComponent doesn't think they\n    // need to be.\n    for (var i = 0, l = autoEscape.length; i < l; i++) {\n      var ae = autoEscape[i];\n      if (rest.indexOf(ae) === -1)\n        continue;\n      var esc = encodeURIComponent(ae);\n      if (esc === ae) {\n        esc = escape(ae);\n      }\n      rest = rest.split(ae).join(esc);\n    }\n  }\n\n\n  // chop off from the tail first.\n  var hash = rest.indexOf('#');\n  if (hash !== -1) {\n    // got a fragment string.\n    this.hash = rest.substr(hash);\n    rest = rest.slice(0, hash);\n  }\n  var qm = rest.indexOf('?');\n  if (qm !== -1) {\n    this.search = rest.substr(qm);\n    this.query = rest.substr(qm + 1);\n    if (parseQueryString) {\n      this.query = querystring.parse(this.query);\n    }\n    rest = rest.slice(0, qm);\n  } else if (parseQueryString) {\n    // no query string, but parseQueryString still requested\n    this.search = '';\n    this.query = {};\n  }\n  if (rest) this.pathname = rest;\n  if (slashedProtocol[lowerProto] &&\n      this.hostname && !this.pathname) {\n    this.pathname = '/';\n  }\n\n  //to support http.request\n  if (this.pathname || this.search) {\n    var p = this.pathname || '';\n    var s = this.search || '';\n    this.path = p + s;\n  }\n\n  // finally, reconstruct the href based on what has been validated.\n  this.href = this.format();\n  return this;\n};\n\n// format a parsed object into a url string\nfunction urlFormat(obj) {\n  // ensure it's an object, and not a string url.\n  // If it's an obj, this is a no-op.\n  // this way, you can call url_format() on strings\n  // to clean up potentially wonky urls.\n  if (util.isString(obj)) obj = urlParse(obj);\n  if (!(obj instanceof Url)) return Url.prototype.format.call(obj);\n  return obj.format();\n}\n\nUrl.prototype.format = function() {\n  var auth = this.auth || '';\n  if (auth) {\n    auth = encodeURIComponent(auth);\n    auth = auth.replace(/%3A/i, ':');\n    auth += '@';\n  }\n\n  var protocol = this.protocol || '',\n      pathname = this.pathname || '',\n      hash = this.hash || '',\n      host = false,\n      query = '';\n\n  if (this.host) {\n    host = auth + this.host;\n  } else if (this.hostname) {\n    host = auth + (this.hostname.indexOf(':') === -1 ?\n        this.hostname :\n        '[' + this.hostname + ']');\n    if (this.port) {\n      host += ':' + this.port;\n    }\n  }\n\n  if (this.query &&\n      util.isObject(this.query) &&\n      Object.keys(this.query).length) {\n    query = querystring.stringify(this.query);\n  }\n\n  var search = this.search || (query && ('?' + query)) || '';\n\n  if (protocol && protocol.substr(-1) !== ':') protocol += ':';\n\n  // only the slashedProtocols get the //.  Not mailto:, xmpp:, etc.\n  // unless they had them to begin with.\n  if (this.slashes ||\n      (!protocol || slashedProtocol[protocol]) && host !== false) {\n    host = '//' + (host || '');\n    if (pathname && pathname.charAt(0) !== '/') pathname = '/' + pathname;\n  } else if (!host) {\n    host = '';\n  }\n\n  if (hash && hash.charAt(0) !== '#') hash = '#' + hash;\n  if (search && search.charAt(0) !== '?') search = '?' + search;\n\n  pathname = pathname.replace(/[?#]/g, function(match) {\n    return encodeURIComponent(match);\n  });\n  search = search.replace('#', '%23');\n\n  return protocol + host + pathname + search + hash;\n};\n\nfunction urlResolve(source, relative) {\n  return urlParse(source, false, true).resolve(relative);\n}\n\nUrl.prototype.resolve = function(relative) {\n  return this.resolveObject(urlParse(relative, false, true)).format();\n};\n\nfunction urlResolveObject(source, relative) {\n  if (!source) return relative;\n  return urlParse(source, false, true).resolveObject(relative);\n}\n\nUrl.prototype.resolveObject = function(relative) {\n  if (util.isString(relative)) {\n    var rel = new Url();\n    rel.parse(relative, false, true);\n    relative = rel;\n  }\n\n  var result = new Url();\n  var tkeys = Object.keys(this);\n  for (var tk = 0; tk < tkeys.length; tk++) {\n    var tkey = tkeys[tk];\n    result[tkey] = this[tkey];\n  }\n\n  // hash is always overridden, no matter what.\n  // even href=\"\" will remove it.\n  result.hash = relative.hash;\n\n  // if the relative url is empty, then there's nothing left to do here.\n  if (relative.href === '') {\n    result.href = result.format();\n    return result;\n  }\n\n  // hrefs like //foo/bar always cut to the protocol.\n  if (relative.slashes && !relative.protocol) {\n    // take everything except the protocol from relative\n    var rkeys = Object.keys(relative);\n    for (var rk = 0; rk < rkeys.length; rk++) {\n      var rkey = rkeys[rk];\n      if (rkey !== 'protocol')\n        result[rkey] = relative[rkey];\n    }\n\n    //urlParse appends trailing / to urls like http://www.example.com\n    if (slashedProtocol[result.protocol] &&\n        result.hostname && !result.pathname) {\n      result.path = result.pathname = '/';\n    }\n\n    result.href = result.format();\n    return result;\n  }\n\n  if (relative.protocol && relative.protocol !== result.protocol) {\n    // if it's a known url protocol, then changing\n    // the protocol does weird things\n    // first, if it's not file:, then we MUST have a host,\n    // and if there was a path\n    // to begin with, then we MUST have a path.\n    // if it is file:, then the host is dropped,\n    // because that's known to be hostless.\n    // anything else is assumed to be absolute.\n    if (!slashedProtocol[relative.protocol]) {\n      var keys = Object.keys(relative);\n      for (var v = 0; v < keys.length; v++) {\n        var k = keys[v];\n        result[k] = relative[k];\n      }\n      result.href = result.format();\n      return result;\n    }\n\n    result.protocol = relative.protocol;\n    if (!relative.host && !hostlessProtocol[relative.protocol]) {\n      var relPath = (relative.pathname || '').split('/');\n      while (relPath.length && !(relative.host = relPath.shift()));\n      if (!relative.host) relative.host = '';\n      if (!relative.hostname) relative.hostname = '';\n      if (relPath[0] !== '') relPath.unshift('');\n      if (relPath.length < 2) relPath.unshift('');\n      result.pathname = relPath.join('/');\n    } else {\n      result.pathname = relative.pathname;\n    }\n    result.search = relative.search;\n    result.query = relative.query;\n    result.host = relative.host || '';\n    result.auth = relative.auth;\n    result.hostname = relative.hostname || relative.host;\n    result.port = relative.port;\n    // to support http.request\n    if (result.pathname || result.search) {\n      var p = result.pathname || '';\n      var s = result.search || '';\n      result.path = p + s;\n    }\n    result.slashes = result.slashes || relative.slashes;\n    result.href = result.format();\n    return result;\n  }\n\n  var isSourceAbs = (result.pathname && result.pathname.charAt(0) === '/'),\n      isRelAbs = (\n          relative.host ||\n          relative.pathname && relative.pathname.charAt(0) === '/'\n      ),\n      mustEndAbs = (isRelAbs || isSourceAbs ||\n                    (result.host && relative.pathname)),\n      removeAllDots = mustEndAbs,\n      srcPath = result.pathname && result.pathname.split('/') || [],\n      relPath = relative.pathname && relative.pathname.split('/') || [],\n      psychotic = result.protocol && !slashedProtocol[result.protocol];\n\n  // if the url is a non-slashed url, then relative\n  // links like ../.. should be able\n  // to crawl up to the hostname, as well.  This is strange.\n  // result.protocol has already been set by now.\n  // Later on, put the first path part into the host field.\n  if (psychotic) {\n    result.hostname = '';\n    result.port = null;\n    if (result.host) {\n      if (srcPath[0] === '') srcPath[0] = result.host;\n      else srcPath.unshift(result.host);\n    }\n    result.host = '';\n    if (relative.protocol) {\n      relative.hostname = null;\n      relative.port = null;\n      if (relative.host) {\n        if (relPath[0] === '') relPath[0] = relative.host;\n        else relPath.unshift(relative.host);\n      }\n      relative.host = null;\n    }\n    mustEndAbs = mustEndAbs && (relPath[0] === '' || srcPath[0] === '');\n  }\n\n  if (isRelAbs) {\n    // it's absolute.\n    result.host = (relative.host || relative.host === '') ?\n                  relative.host : result.host;\n    result.hostname = (relative.hostname || relative.hostname === '') ?\n                      relative.hostname : result.hostname;\n    result.search = relative.search;\n    result.query = relative.query;\n    srcPath = relPath;\n    // fall through to the dot-handling below.\n  } else if (relPath.length) {\n    // it's relative\n    // throw away the existing file, and take the new path instead.\n    if (!srcPath) srcPath = [];\n    srcPath.pop();\n    srcPath = srcPath.concat(relPath);\n    result.search = relative.search;\n    result.query = relative.query;\n  } else if (!util.isNullOrUndefined(relative.search)) {\n    // just pull out the search.\n    // like href='?foo'.\n    // Put this after the other two cases because it simplifies the booleans\n    if (psychotic) {\n      result.hostname = result.host = srcPath.shift();\n      //occationaly the auth can get stuck only in host\n      //this especially happens in cases like\n      //url.resolveObject('mailto:local1@domain1', 'local2@domain2')\n      var authInHost = result.host && result.host.indexOf('@') > 0 ?\n                       result.host.split('@') : false;\n      if (authInHost) {\n        result.auth = authInHost.shift();\n        result.host = result.hostname = authInHost.shift();\n      }\n    }\n    result.search = relative.search;\n    result.query = relative.query;\n    //to support http.request\n    if (!util.isNull(result.pathname) || !util.isNull(result.search)) {\n      result.path = (result.pathname ? result.pathname : '') +\n                    (result.search ? result.search : '');\n    }\n    result.href = result.format();\n    return result;\n  }\n\n  if (!srcPath.length) {\n    // no path at all.  easy.\n    // we've already handled the other stuff above.\n    result.pathname = null;\n    //to support http.request\n    if (result.search) {\n      result.path = '/' + result.search;\n    } else {\n      result.path = null;\n    }\n    result.href = result.format();\n    return result;\n  }\n\n  // if a url ENDs in . or .., then it must get a trailing slash.\n  // however, if it ends in anything else non-slashy,\n  // then it must NOT get a trailing slash.\n  var last = srcPath.slice(-1)[0];\n  var hasTrailingSlash = (\n      (result.host || relative.host || srcPath.length > 1) &&\n      (last === '.' || last === '..') || last === '');\n\n  // strip single dots, resolve double dots to parent dir\n  // if the path tries to go above the root, `up` ends up > 0\n  var up = 0;\n  for (var i = srcPath.length; i >= 0; i--) {\n    last = srcPath[i];\n    if (last === '.') {\n      srcPath.splice(i, 1);\n    } else if (last === '..') {\n      srcPath.splice(i, 1);\n      up++;\n    } else if (up) {\n      srcPath.splice(i, 1);\n      up--;\n    }\n  }\n\n  // if the path is allowed to go above the root, restore leading ..s\n  if (!mustEndAbs && !removeAllDots) {\n    for (; up--; up) {\n      srcPath.unshift('..');\n    }\n  }\n\n  if (mustEndAbs && srcPath[0] !== '' &&\n      (!srcPath[0] || srcPath[0].charAt(0) !== '/')) {\n    srcPath.unshift('');\n  }\n\n  if (hasTrailingSlash && (srcPath.join('/').substr(-1) !== '/')) {\n    srcPath.push('');\n  }\n\n  var isAbsolute = srcPath[0] === '' ||\n      (srcPath[0] && srcPath[0].charAt(0) === '/');\n\n  // put the host back\n  if (psychotic) {\n    result.hostname = result.host = isAbsolute ? '' :\n                                    srcPath.length ? srcPath.shift() : '';\n    //occationaly the auth can get stuck only in host\n    //this especially happens in cases like\n    //url.resolveObject('mailto:local1@domain1', 'local2@domain2')\n    var authInHost = result.host && result.host.indexOf('@') > 0 ?\n                     result.host.split('@') : false;\n    if (authInHost) {\n      result.auth = authInHost.shift();\n      result.host = result.hostname = authInHost.shift();\n    }\n  }\n\n  mustEndAbs = mustEndAbs || (result.host && srcPath.length);\n\n  if (mustEndAbs && !isAbsolute) {\n    srcPath.unshift('');\n  }\n\n  if (!srcPath.length) {\n    result.pathname = null;\n    result.path = null;\n  } else {\n    result.pathname = srcPath.join('/');\n  }\n\n  //to support request.http\n  if (!util.isNull(result.pathname) || !util.isNull(result.search)) {\n    result.path = (result.pathname ? result.pathname : '') +\n                  (result.search ? result.search : '');\n  }\n  result.auth = relative.auth || result.auth;\n  result.slashes = result.slashes || relative.slashes;\n  result.href = result.format();\n  return result;\n};\n\nUrl.prototype.parseHost = function() {\n  var host = this.host;\n  var port = portPattern.exec(host);\n  if (port) {\n    port = port[0];\n    if (port !== ':') {\n      this.port = port.substr(1);\n    }\n    host = host.substr(0, host.length - port.length);\n  }\n  if (host) this.hostname = host;\n};\n","'use strict';\n\nmodule.exports = {\n  isString: function(arg) {\n    return typeof(arg) === 'string';\n  },\n  isObject: function(arg) {\n    return typeof(arg) === 'object' && arg !== null;\n  },\n  isNull: function(arg) {\n    return arg === null;\n  },\n  isNullOrUndefined: function(arg) {\n    return arg == null;\n  }\n};\n","module.exports = extend\n\nvar hasOwnProperty = Object.prototype.hasOwnProperty;\n\nfunction extend() {\n    var target = {}\n\n    for (var i = 0; i < arguments.length; i++) {\n        var source = arguments[i]\n\n        for (var key in source) {\n            if (hasOwnProperty.call(source, key)) {\n                target[key] = source[key]\n            }\n        }\n    }\n\n    return target\n}\n","/*!\n * escape-html\n * Copyright(c) 2012-2013 TJ Holowaychuk\n * Copyright(c) 2015 Andreas Lubbe\n * Copyright(c) 2015 Tiancheng \"Timothy\" Gu\n * MIT Licensed\n */\n\n'use strict';\n\n/**\n * Module variables.\n * @private\n */\n\nvar matchHtmlRegExp = /[\"'&<>]/;\n\n/**\n * Module exports.\n * @public\n */\n\nmodule.exports = escapeHtml;\n\n/**\n * Escape special characters in the given string of html.\n *\n * @param  {string} string The string to escape for inserting into HTML\n * @return {string}\n * @public\n */\n\nfunction escapeHtml(string) {\n  var str = '' + string;\n  var match = matchHtmlRegExp.exec(str);\n\n  if (!match) {\n    return str;\n  }\n\n  var escape;\n  var html = '';\n  var index = 0;\n  var lastIndex = 0;\n\n  for (index = match.index; index < str.length; index++) {\n    switch (str.charCodeAt(index)) {\n      case 34: // \"\n        escape = '&quot;';\n        break;\n      case 38: // &\n        escape = '&amp;';\n        break;\n      case 39: // '\n        escape = '&#39;';\n        break;\n      case 60: // <\n        escape = '&lt;';\n        break;\n      case 62: // >\n        escape = '&gt;';\n        break;\n      default:\n        continue;\n    }\n\n    if (lastIndex !== index) {\n      html += str.substring(lastIndex, index);\n    }\n\n    lastIndex = index + 1;\n    html += escape;\n  }\n\n  return lastIndex !== index\n    ? html + str.substring(lastIndex, index)\n    : html;\n}\n",";(function (sax) { // wrapper for non-node envs\n  sax.parser = function (strict, opt) { return new SAXParser(strict, opt) }\n  sax.SAXParser = SAXParser\n  sax.SAXStream = SAXStream\n  sax.createStream = createStream\n\n  // When we pass the MAX_BUFFER_LENGTH position, start checking for buffer overruns.\n  // When we check, schedule the next check for MAX_BUFFER_LENGTH - (max(buffer lengths)),\n  // since that's the earliest that a buffer overrun could occur.  This way, checks are\n  // as rare as required, but as often as necessary to ensure never crossing this bound.\n  // Furthermore, buffers are only tested at most once per write(), so passing a very\n  // large string into write() might have undesirable effects, but this is manageable by\n  // the caller, so it is assumed to be safe.  Thus, a call to write() may, in the extreme\n  // edge case, result in creating at most one complete copy of the string passed in.\n  // Set to Infinity to have unlimited buffers.\n  sax.MAX_BUFFER_LENGTH = 64 * 1024\n\n  var buffers = [\n    'comment', 'sgmlDecl', 'textNode', 'tagName', 'doctype',\n    'procInstName', 'procInstBody', 'entity', 'attribName',\n    'attribValue', 'cdata', 'script'\n  ]\n\n  sax.EVENTS = [\n    'text',\n    'processinginstruction',\n    'sgmldeclaration',\n    'doctype',\n    'comment',\n    'attribute',\n    'opentag',\n    'closetag',\n    'opencdata',\n    'cdata',\n    'closecdata',\n    'error',\n    'end',\n    'ready',\n    'script',\n    'opennamespace',\n    'closenamespace'\n  ]\n\n  function SAXParser (strict, opt) {\n    if (!(this instanceof SAXParser)) {\n      return new SAXParser(strict, opt)\n    }\n\n    var parser = this\n    clearBuffers(parser)\n    parser.q = parser.c = ''\n    parser.bufferCheckPosition = sax.MAX_BUFFER_LENGTH\n    parser.opt = opt || {}\n    parser.opt.lowercase = parser.opt.lowercase || parser.opt.lowercasetags\n    parser.looseCase = parser.opt.lowercase ? 'toLowerCase' : 'toUpperCase'\n    parser.tags = []\n    parser.closed = parser.closedRoot = parser.sawRoot = false\n    parser.tag = parser.error = null\n    parser.strict = !!strict\n    parser.noscript = !!(strict || parser.opt.noscript)\n    parser.state = S.BEGIN\n    parser.strictEntities = parser.opt.strictEntities\n    parser.ENTITIES = parser.strictEntities ? Object.create(sax.XML_ENTITIES) : Object.create(sax.ENTITIES)\n    parser.attribList = []\n\n    // namespaces form a prototype chain.\n    // it always points at the current tag,\n    // which protos to its parent tag.\n    if (parser.opt.xmlns) {\n      parser.ns = Object.create(rootNS)\n    }\n\n    // mostly just for error reporting\n    parser.trackPosition = parser.opt.position !== false\n    if (parser.trackPosition) {\n      parser.position = parser.line = parser.column = 0\n    }\n    emit(parser, 'onready')\n  }\n\n  if (!Object.create) {\n    Object.create = function (o) {\n      function F () {}\n      F.prototype = o\n      var newf = new F()\n      return newf\n    }\n  }\n\n  if (!Object.keys) {\n    Object.keys = function (o) {\n      var a = []\n      for (var i in o) if (o.hasOwnProperty(i)) a.push(i)\n      return a\n    }\n  }\n\n  function checkBufferLength (parser) {\n    var maxAllowed = Math.max(sax.MAX_BUFFER_LENGTH, 10)\n    var maxActual = 0\n    for (var i = 0, l = buffers.length; i < l; i++) {\n      var len = parser[buffers[i]].length\n      if (len > maxAllowed) {\n        // Text/cdata nodes can get big, and since they're buffered,\n        // we can get here under normal conditions.\n        // Avoid issues by emitting the text node now,\n        // so at least it won't get any bigger.\n        switch (buffers[i]) {\n          case 'textNode':\n            closeText(parser)\n            break\n\n          case 'cdata':\n            emitNode(parser, 'oncdata', parser.cdata)\n            parser.cdata = ''\n            break\n\n          case 'script':\n            emitNode(parser, 'onscript', parser.script)\n            parser.script = ''\n            break\n\n          default:\n            error(parser, 'Max buffer length exceeded: ' + buffers[i])\n        }\n      }\n      maxActual = Math.max(maxActual, len)\n    }\n    // schedule the next check for the earliest possible buffer overrun.\n    var m = sax.MAX_BUFFER_LENGTH - maxActual\n    parser.bufferCheckPosition = m + parser.position\n  }\n\n  function clearBuffers (parser) {\n    for (var i = 0, l = buffers.length; i < l; i++) {\n      parser[buffers[i]] = ''\n    }\n  }\n\n  function flushBuffers (parser) {\n    closeText(parser)\n    if (parser.cdata !== '') {\n      emitNode(parser, 'oncdata', parser.cdata)\n      parser.cdata = ''\n    }\n    if (parser.script !== '') {\n      emitNode(parser, 'onscript', parser.script)\n      parser.script = ''\n    }\n  }\n\n  SAXParser.prototype = {\n    end: function () { end(this) },\n    write: write,\n    resume: function () { this.error = null; return this },\n    close: function () { return this.write(null) },\n    flush: function () { flushBuffers(this) }\n  }\n\n  var Stream\n  try {\n    Stream = require('stream').Stream\n  } catch (ex) {\n    Stream = function () {}\n  }\n\n  var streamWraps = sax.EVENTS.filter(function (ev) {\n    return ev !== 'error' && ev !== 'end'\n  })\n\n  function createStream (strict, opt) {\n    return new SAXStream(strict, opt)\n  }\n\n  function SAXStream (strict, opt) {\n    if (!(this instanceof SAXStream)) {\n      return new SAXStream(strict, opt)\n    }\n\n    Stream.apply(this)\n\n    this._parser = new SAXParser(strict, opt)\n    this.writable = true\n    this.readable = true\n\n    var me = this\n\n    this._parser.onend = function () {\n      me.emit('end')\n    }\n\n    this._parser.onerror = function (er) {\n      me.emit('error', er)\n\n      // if didn't throw, then means error was handled.\n      // go ahead and clear error, so we can write again.\n      me._parser.error = null\n    }\n\n    this._decoder = null\n\n    streamWraps.forEach(function (ev) {\n      Object.defineProperty(me, 'on' + ev, {\n        get: function () {\n          return me._parser['on' + ev]\n        },\n        set: function (h) {\n          if (!h) {\n            me.removeAllListeners(ev)\n            me._parser['on' + ev] = h\n            return h\n          }\n          me.on(ev, h)\n        },\n        enumerable: true,\n        configurable: false\n      })\n    })\n  }\n\n  SAXStream.prototype = Object.create(Stream.prototype, {\n    constructor: {\n      value: SAXStream\n    }\n  })\n\n  SAXStream.prototype.write = function (data) {\n    if (typeof Buffer === 'function' &&\n      typeof Buffer.isBuffer === 'function' &&\n      Buffer.isBuffer(data)) {\n      if (!this._decoder) {\n        var SD = require('string_decoder').StringDecoder\n        this._decoder = new SD('utf8')\n      }\n      data = this._decoder.write(data)\n    }\n\n    this._parser.write(data.toString())\n    this.emit('data', data)\n    return true\n  }\n\n  SAXStream.prototype.end = function (chunk) {\n    if (chunk && chunk.length) {\n      this.write(chunk)\n    }\n    this._parser.end()\n    return true\n  }\n\n  SAXStream.prototype.on = function (ev, handler) {\n    var me = this\n    if (!me._parser['on' + ev] && streamWraps.indexOf(ev) !== -1) {\n      me._parser['on' + ev] = function () {\n        var args = arguments.length === 1 ? [arguments[0]] : Array.apply(null, arguments)\n        args.splice(0, 0, ev)\n        me.emit.apply(me, args)\n      }\n    }\n\n    return Stream.prototype.on.call(me, ev, handler)\n  }\n\n  // character classes and tokens\n  var whitespace = '\\r\\n\\t '\n\n  // this really needs to be replaced with character classes.\n  // XML allows all manner of ridiculous numbers and digits.\n  var number = '0124356789'\n  var letter = 'abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ'\n\n  // (Letter | \"_\" | \":\")\n  var quote = '\\'\"'\n  var attribEnd = whitespace + '>'\n  var CDATA = '[CDATA['\n  var DOCTYPE = 'DOCTYPE'\n  var XML_NAMESPACE = 'http://www.w3.org/XML/1998/namespace'\n  var XMLNS_NAMESPACE = 'http://www.w3.org/2000/xmlns/'\n  var rootNS = { xml: XML_NAMESPACE, xmlns: XMLNS_NAMESPACE }\n\n  // turn all the string character sets into character class objects.\n  whitespace = charClass(whitespace)\n  number = charClass(number)\n  letter = charClass(letter)\n\n  // http://www.w3.org/TR/REC-xml/#NT-NameStartChar\n  // This implementation works on strings, a single character at a time\n  // as such, it cannot ever support astral-plane characters (10000-EFFFF)\n  // without a significant breaking change to either this  parser, or the\n  // JavaScript language.  Implementation of an emoji-capable xml parser\n  // is left as an exercise for the reader.\n  var nameStart = /[:_A-Za-z\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD]/\n\n  var nameBody = /[:_A-Za-z\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD\\u00B7\\u0300-\\u036F\\u203F-\\u2040\\.\\d-]/\n\n  var entityStart = /[#:_A-Za-z\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD]/\n  var entityBody = /[#:_A-Za-z\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD\\u00B7\\u0300-\\u036F\\u203F-\\u2040\\.\\d-]/\n\n  quote = charClass(quote)\n  attribEnd = charClass(attribEnd)\n\n  function charClass (str) {\n    return str.split('').reduce(function (s, c) {\n      s[c] = true\n      return s\n    }, {})\n  }\n\n  function isRegExp (c) {\n    return Object.prototype.toString.call(c) === '[object RegExp]'\n  }\n\n  function is (charclass, c) {\n    return isRegExp(charclass) ? !!c.match(charclass) : charclass[c]\n  }\n\n  function not (charclass, c) {\n    return !is(charclass, c)\n  }\n\n  var S = 0\n  sax.STATE = {\n    BEGIN: S++, // leading byte order mark or whitespace\n    BEGIN_WHITESPACE: S++, // leading whitespace\n    TEXT: S++, // general stuff\n    TEXT_ENTITY: S++, // &amp and such.\n    OPEN_WAKA: S++, // <\n    SGML_DECL: S++, // <!BLARG\n    SGML_DECL_QUOTED: S++, // <!BLARG foo \"bar\n    DOCTYPE: S++, // <!DOCTYPE\n    DOCTYPE_QUOTED: S++, // <!DOCTYPE \"//blah\n    DOCTYPE_DTD: S++, // <!DOCTYPE \"//blah\" [ ...\n    DOCTYPE_DTD_QUOTED: S++, // <!DOCTYPE \"//blah\" [ \"foo\n    COMMENT_STARTING: S++, // <!-\n    COMMENT: S++, // <!--\n    COMMENT_ENDING: S++, // <!-- blah -\n    COMMENT_ENDED: S++, // <!-- blah --\n    CDATA: S++, // <![CDATA[ something\n    CDATA_ENDING: S++, // ]\n    CDATA_ENDING_2: S++, // ]]\n    PROC_INST: S++, // <?hi\n    PROC_INST_BODY: S++, // <?hi there\n    PROC_INST_ENDING: S++, // <?hi \"there\" ?\n    OPEN_TAG: S++, // <strong\n    OPEN_TAG_SLASH: S++, // <strong /\n    ATTRIB: S++, // <a\n    ATTRIB_NAME: S++, // <a foo\n    ATTRIB_NAME_SAW_WHITE: S++, // <a foo _\n    ATTRIB_VALUE: S++, // <a foo=\n    ATTRIB_VALUE_QUOTED: S++, // <a foo=\"bar\n    ATTRIB_VALUE_CLOSED: S++, // <a foo=\"bar\"\n    ATTRIB_VALUE_UNQUOTED: S++, // <a foo=bar\n    ATTRIB_VALUE_ENTITY_Q: S++, // <foo bar=\"&quot;\"\n    ATTRIB_VALUE_ENTITY_U: S++, // <foo bar=&quot\n    CLOSE_TAG: S++, // </a\n    CLOSE_TAG_SAW_WHITE: S++, // </a   >\n    SCRIPT: S++, // <script> ...\n    SCRIPT_ENDING: S++ // <script> ... <\n  }\n\n  sax.XML_ENTITIES = {\n    'amp': '&',\n    'gt': '>',\n    'lt': '<',\n    'quot': '\"',\n    'apos': \"'\"\n  }\n\n  sax.ENTITIES = {\n    'amp': '&',\n    'gt': '>',\n    'lt': '<',\n    'quot': '\"',\n    'apos': \"'\",\n    'AElig': 198,\n    'Aacute': 193,\n    'Acirc': 194,\n    'Agrave': 192,\n    'Aring': 197,\n    'Atilde': 195,\n    'Auml': 196,\n    'Ccedil': 199,\n    'ETH': 208,\n    'Eacute': 201,\n    'Ecirc': 202,\n    'Egrave': 200,\n    'Euml': 203,\n    'Iacute': 205,\n    'Icirc': 206,\n    'Igrave': 204,\n    'Iuml': 207,\n    'Ntilde': 209,\n    'Oacute': 211,\n    'Ocirc': 212,\n    'Ograve': 210,\n    'Oslash': 216,\n    'Otilde': 213,\n    'Ouml': 214,\n    'THORN': 222,\n    'Uacute': 218,\n    'Ucirc': 219,\n    'Ugrave': 217,\n    'Uuml': 220,\n    'Yacute': 221,\n    'aacute': 225,\n    'acirc': 226,\n    'aelig': 230,\n    'agrave': 224,\n    'aring': 229,\n    'atilde': 227,\n    'auml': 228,\n    'ccedil': 231,\n    'eacute': 233,\n    'ecirc': 234,\n    'egrave': 232,\n    'eth': 240,\n    'euml': 235,\n    'iacute': 237,\n    'icirc': 238,\n    'igrave': 236,\n    'iuml': 239,\n    'ntilde': 241,\n    'oacute': 243,\n    'ocirc': 244,\n    'ograve': 242,\n    'oslash': 248,\n    'otilde': 245,\n    'ouml': 246,\n    'szlig': 223,\n    'thorn': 254,\n    'uacute': 250,\n    'ucirc': 251,\n    'ugrave': 249,\n    'uuml': 252,\n    'yacute': 253,\n    'yuml': 255,\n    'copy': 169,\n    'reg': 174,\n    'nbsp': 160,\n    'iexcl': 161,\n    'cent': 162,\n    'pound': 163,\n    'curren': 164,\n    'yen': 165,\n    'brvbar': 166,\n    'sect': 167,\n    'uml': 168,\n    'ordf': 170,\n    'laquo': 171,\n    'not': 172,\n    'shy': 173,\n    'macr': 175,\n    'deg': 176,\n    'plusmn': 177,\n    'sup1': 185,\n    'sup2': 178,\n    'sup3': 179,\n    'acute': 180,\n    'micro': 181,\n    'para': 182,\n    'middot': 183,\n    'cedil': 184,\n    'ordm': 186,\n    'raquo': 187,\n    'frac14': 188,\n    'frac12': 189,\n    'frac34': 190,\n    'iquest': 191,\n    'times': 215,\n    'divide': 247,\n    'OElig': 338,\n    'oelig': 339,\n    'Scaron': 352,\n    'scaron': 353,\n    'Yuml': 376,\n    'fnof': 402,\n    'circ': 710,\n    'tilde': 732,\n    'Alpha': 913,\n    'Beta': 914,\n    'Gamma': 915,\n    'Delta': 916,\n    'Epsilon': 917,\n    'Zeta': 918,\n    'Eta': 919,\n    'Theta': 920,\n    'Iota': 921,\n    'Kappa': 922,\n    'Lambda': 923,\n    'Mu': 924,\n    'Nu': 925,\n    'Xi': 926,\n    'Omicron': 927,\n    'Pi': 928,\n    'Rho': 929,\n    'Sigma': 931,\n    'Tau': 932,\n    'Upsilon': 933,\n    'Phi': 934,\n    'Chi': 935,\n    'Psi': 936,\n    'Omega': 937,\n    'alpha': 945,\n    'beta': 946,\n    'gamma': 947,\n    'delta': 948,\n    'epsilon': 949,\n    'zeta': 950,\n    'eta': 951,\n    'theta': 952,\n    'iota': 953,\n    'kappa': 954,\n    'lambda': 955,\n    'mu': 956,\n    'nu': 957,\n    'xi': 958,\n    'omicron': 959,\n    'pi': 960,\n    'rho': 961,\n    'sigmaf': 962,\n    'sigma': 963,\n    'tau': 964,\n    'upsilon': 965,\n    'phi': 966,\n    'chi': 967,\n    'psi': 968,\n    'omega': 969,\n    'thetasym': 977,\n    'upsih': 978,\n    'piv': 982,\n    'ensp': 8194,\n    'emsp': 8195,\n    'thinsp': 8201,\n    'zwnj': 8204,\n    'zwj': 8205,\n    'lrm': 8206,\n    'rlm': 8207,\n    'ndash': 8211,\n    'mdash': 8212,\n    'lsquo': 8216,\n    'rsquo': 8217,\n    'sbquo': 8218,\n    'ldquo': 8220,\n    'rdquo': 8221,\n    'bdquo': 8222,\n    'dagger': 8224,\n    'Dagger': 8225,\n    'bull': 8226,\n    'hellip': 8230,\n    'permil': 8240,\n    'prime': 8242,\n    'Prime': 8243,\n    'lsaquo': 8249,\n    'rsaquo': 8250,\n    'oline': 8254,\n    'frasl': 8260,\n    'euro': 8364,\n    'image': 8465,\n    'weierp': 8472,\n    'real': 8476,\n    'trade': 8482,\n    'alefsym': 8501,\n    'larr': 8592,\n    'uarr': 8593,\n    'rarr': 8594,\n    'darr': 8595,\n    'harr': 8596,\n    'crarr': 8629,\n    'lArr': 8656,\n    'uArr': 8657,\n    'rArr': 8658,\n    'dArr': 8659,\n    'hArr': 8660,\n    'forall': 8704,\n    'part': 8706,\n    'exist': 8707,\n    'empty': 8709,\n    'nabla': 8711,\n    'isin': 8712,\n    'notin': 8713,\n    'ni': 8715,\n    'prod': 8719,\n    'sum': 8721,\n    'minus': 8722,\n    'lowast': 8727,\n    'radic': 8730,\n    'prop': 8733,\n    'infin': 8734,\n    'ang': 8736,\n    'and': 8743,\n    'or': 8744,\n    'cap': 8745,\n    'cup': 8746,\n    'int': 8747,\n    'there4': 8756,\n    'sim': 8764,\n    'cong': 8773,\n    'asymp': 8776,\n    'ne': 8800,\n    'equiv': 8801,\n    'le': 8804,\n    'ge': 8805,\n    'sub': 8834,\n    'sup': 8835,\n    'nsub': 8836,\n    'sube': 8838,\n    'supe': 8839,\n    'oplus': 8853,\n    'otimes': 8855,\n    'perp': 8869,\n    'sdot': 8901,\n    'lceil': 8968,\n    'rceil': 8969,\n    'lfloor': 8970,\n    'rfloor': 8971,\n    'lang': 9001,\n    'rang': 9002,\n    'loz': 9674,\n    'spades': 9824,\n    'clubs': 9827,\n    'hearts': 9829,\n    'diams': 9830\n  }\n\n  Object.keys(sax.ENTITIES).forEach(function (key) {\n    var e = sax.ENTITIES[key]\n    var s = typeof e === 'number' ? String.fromCharCode(e) : e\n    sax.ENTITIES[key] = s\n  })\n\n  for (var s in sax.STATE) {\n    sax.STATE[sax.STATE[s]] = s\n  }\n\n  // shorthand\n  S = sax.STATE\n\n  function emit (parser, event, data) {\n    parser[event] && parser[event](data)\n  }\n\n  function emitNode (parser, nodeType, data) {\n    if (parser.textNode) closeText(parser)\n    emit(parser, nodeType, data)\n  }\n\n  function closeText (parser) {\n    parser.textNode = textopts(parser.opt, parser.textNode)\n    if (parser.textNode) emit(parser, 'ontext', parser.textNode)\n    parser.textNode = ''\n  }\n\n  function textopts (opt, text) {\n    if (opt.trim) text = text.trim()\n    if (opt.normalize) text = text.replace(/\\s+/g, ' ')\n    return text\n  }\n\n  function error (parser, er) {\n    closeText(parser)\n    if (parser.trackPosition) {\n      er += '\\nLine: ' + parser.line +\n        '\\nColumn: ' + parser.column +\n        '\\nChar: ' + parser.c\n    }\n    er = new Error(er)\n    parser.error = er\n    emit(parser, 'onerror', er)\n    return parser\n  }\n\n  function end (parser) {\n    if (parser.sawRoot && !parser.closedRoot) strictFail(parser, 'Unclosed root tag')\n    if ((parser.state !== S.BEGIN) &&\n      (parser.state !== S.BEGIN_WHITESPACE) &&\n      (parser.state !== S.TEXT)) {\n      error(parser, 'Unexpected end')\n    }\n    closeText(parser)\n    parser.c = ''\n    parser.closed = true\n    emit(parser, 'onend')\n    SAXParser.call(parser, parser.strict, parser.opt)\n    return parser\n  }\n\n  function strictFail (parser, message) {\n    if (typeof parser !== 'object' || !(parser instanceof SAXParser)) {\n      throw new Error('bad call to strictFail')\n    }\n    if (parser.strict) {\n      error(parser, message)\n    }\n  }\n\n  function newTag (parser) {\n    if (!parser.strict) parser.tagName = parser.tagName[parser.looseCase]()\n    var parent = parser.tags[parser.tags.length - 1] || parser\n    var tag = parser.tag = { name: parser.tagName, attributes: {} }\n\n    // will be overridden if tag contails an xmlns=\"foo\" or xmlns:foo=\"bar\"\n    if (parser.opt.xmlns) {\n      tag.ns = parent.ns\n    }\n    parser.attribList.length = 0\n  }\n\n  function qname (name, attribute) {\n    var i = name.indexOf(':')\n    var qualName = i < 0 ? [ '', name ] : name.split(':')\n    var prefix = qualName[0]\n    var local = qualName[1]\n\n    // <x \"xmlns\"=\"http://foo\">\n    if (attribute && name === 'xmlns') {\n      prefix = 'xmlns'\n      local = ''\n    }\n\n    return { prefix: prefix, local: local }\n  }\n\n  function attrib (parser) {\n    if (!parser.strict) {\n      parser.attribName = parser.attribName[parser.looseCase]()\n    }\n\n    if (parser.attribList.indexOf(parser.attribName) !== -1 ||\n      parser.tag.attributes.hasOwnProperty(parser.attribName)) {\n      parser.attribName = parser.attribValue = ''\n      return\n    }\n\n    if (parser.opt.xmlns) {\n      var qn = qname(parser.attribName, true)\n      var prefix = qn.prefix\n      var local = qn.local\n\n      if (prefix === 'xmlns') {\n        // namespace binding attribute. push the binding into scope\n        if (local === 'xml' && parser.attribValue !== XML_NAMESPACE) {\n          strictFail(parser,\n            'xml: prefix must be bound to ' + XML_NAMESPACE + '\\n' +\n            'Actual: ' + parser.attribValue)\n        } else if (local === 'xmlns' && parser.attribValue !== XMLNS_NAMESPACE) {\n          strictFail(parser,\n            'xmlns: prefix must be bound to ' + XMLNS_NAMESPACE + '\\n' +\n            'Actual: ' + parser.attribValue)\n        } else {\n          var tag = parser.tag\n          var parent = parser.tags[parser.tags.length - 1] || parser\n          if (tag.ns === parent.ns) {\n            tag.ns = Object.create(parent.ns)\n          }\n          tag.ns[local] = parser.attribValue\n        }\n      }\n\n      // defer onattribute events until all attributes have been seen\n      // so any new bindings can take effect. preserve attribute order\n      // so deferred events can be emitted in document order\n      parser.attribList.push([parser.attribName, parser.attribValue])\n    } else {\n      // in non-xmlns mode, we can emit the event right away\n      parser.tag.attributes[parser.attribName] = parser.attribValue\n      emitNode(parser, 'onattribute', {\n        name: parser.attribName,\n        value: parser.attribValue\n      })\n    }\n\n    parser.attribName = parser.attribValue = ''\n  }\n\n  function openTag (parser, selfClosing) {\n    if (parser.opt.xmlns) {\n      // emit namespace binding events\n      var tag = parser.tag\n\n      // add namespace info to tag\n      var qn = qname(parser.tagName)\n      tag.prefix = qn.prefix\n      tag.local = qn.local\n      tag.uri = tag.ns[qn.prefix] || ''\n\n      if (tag.prefix && !tag.uri) {\n        strictFail(parser, 'Unbound namespace prefix: ' +\n          JSON.stringify(parser.tagName))\n        tag.uri = qn.prefix\n      }\n\n      var parent = parser.tags[parser.tags.length - 1] || parser\n      if (tag.ns && parent.ns !== tag.ns) {\n        Object.keys(tag.ns).forEach(function (p) {\n          emitNode(parser, 'onopennamespace', {\n            prefix: p,\n            uri: tag.ns[p]\n          })\n        })\n      }\n\n      // handle deferred onattribute events\n      // Note: do not apply default ns to attributes:\n      //   http://www.w3.org/TR/REC-xml-names/#defaulting\n      for (var i = 0, l = parser.attribList.length; i < l; i++) {\n        var nv = parser.attribList[i]\n        var name = nv[0]\n        var value = nv[1]\n        var qualName = qname(name, true)\n        var prefix = qualName.prefix\n        var local = qualName.local\n        var uri = prefix === '' ? '' : (tag.ns[prefix] || '')\n        var a = {\n          name: name,\n          value: value,\n          prefix: prefix,\n          local: local,\n          uri: uri\n        }\n\n        // if there's any attributes with an undefined namespace,\n        // then fail on them now.\n        if (prefix && prefix !== 'xmlns' && !uri) {\n          strictFail(parser, 'Unbound namespace prefix: ' +\n            JSON.stringify(prefix))\n          a.uri = prefix\n        }\n        parser.tag.attributes[name] = a\n        emitNode(parser, 'onattribute', a)\n      }\n      parser.attribList.length = 0\n    }\n\n    parser.tag.isSelfClosing = !!selfClosing\n\n    // process the tag\n    parser.sawRoot = true\n    parser.tags.push(parser.tag)\n    emitNode(parser, 'onopentag', parser.tag)\n    if (!selfClosing) {\n      // special case for <script> in non-strict mode.\n      if (!parser.noscript && parser.tagName.toLowerCase() === 'script') {\n        parser.state = S.SCRIPT\n      } else {\n        parser.state = S.TEXT\n      }\n      parser.tag = null\n      parser.tagName = ''\n    }\n    parser.attribName = parser.attribValue = ''\n    parser.attribList.length = 0\n  }\n\n  function closeTag (parser) {\n    if (!parser.tagName) {\n      strictFail(parser, 'Weird empty close tag.')\n      parser.textNode += '</>'\n      parser.state = S.TEXT\n      return\n    }\n\n    if (parser.script) {\n      if (parser.tagName !== 'script') {\n        parser.script += '</' + parser.tagName + '>'\n        parser.tagName = ''\n        parser.state = S.SCRIPT\n        return\n      }\n      emitNode(parser, 'onscript', parser.script)\n      parser.script = ''\n    }\n\n    // first make sure that the closing tag actually exists.\n    // <a><b></c></b></a> will close everything, otherwise.\n    var t = parser.tags.length\n    var tagName = parser.tagName\n    if (!parser.strict) {\n      tagName = tagName[parser.looseCase]()\n    }\n    var closeTo = tagName\n    while (t--) {\n      var close = parser.tags[t]\n      if (close.name !== closeTo) {\n        // fail the first time in strict mode\n        strictFail(parser, 'Unexpected close tag')\n      } else {\n        break\n      }\n    }\n\n    // didn't find it.  we already failed for strict, so just abort.\n    if (t < 0) {\n      strictFail(parser, 'Unmatched closing tag: ' + parser.tagName)\n      parser.textNode += '</' + parser.tagName + '>'\n      parser.state = S.TEXT\n      return\n    }\n    parser.tagName = tagName\n    var s = parser.tags.length\n    while (s-- > t) {\n      var tag = parser.tag = parser.tags.pop()\n      parser.tagName = parser.tag.name\n      emitNode(parser, 'onclosetag', parser.tagName)\n\n      var x = {}\n      for (var i in tag.ns) {\n        x[i] = tag.ns[i]\n      }\n\n      var parent = parser.tags[parser.tags.length - 1] || parser\n      if (parser.opt.xmlns && tag.ns !== parent.ns) {\n        // remove namespace bindings introduced by tag\n        Object.keys(tag.ns).forEach(function (p) {\n          var n = tag.ns[p]\n          emitNode(parser, 'onclosenamespace', { prefix: p, uri: n })\n        })\n      }\n    }\n    if (t === 0) parser.closedRoot = true\n    parser.tagName = parser.attribValue = parser.attribName = ''\n    parser.attribList.length = 0\n    parser.state = S.TEXT\n  }\n\n  function parseEntity (parser) {\n    var entity = parser.entity\n    var entityLC = entity.toLowerCase()\n    var num\n    var numStr = ''\n\n    if (parser.ENTITIES[entity]) {\n      return parser.ENTITIES[entity]\n    }\n    if (parser.ENTITIES[entityLC]) {\n      return parser.ENTITIES[entityLC]\n    }\n    entity = entityLC\n    if (entity.charAt(0) === '#') {\n      if (entity.charAt(1) === 'x') {\n        entity = entity.slice(2)\n        num = parseInt(entity, 16)\n        numStr = num.toString(16)\n      } else {\n        entity = entity.slice(1)\n        num = parseInt(entity, 10)\n        numStr = num.toString(10)\n      }\n    }\n    entity = entity.replace(/^0+/, '')\n    if (numStr.toLowerCase() !== entity) {\n      strictFail(parser, 'Invalid character entity')\n      return '&' + parser.entity + ';'\n    }\n\n    return String.fromCodePoint(num)\n  }\n\n  function beginWhiteSpace (parser, c) {\n    if (c === '<') {\n      parser.state = S.OPEN_WAKA\n      parser.startTagPosition = parser.position\n    } else if (not(whitespace, c)) {\n      // have to process this as a text node.\n      // weird, but happens.\n      strictFail(parser, 'Non-whitespace before first tag.')\n      parser.textNode = c\n      parser.state = S.TEXT\n    }\n  }\n\n  function write (chunk) {\n    var parser = this\n    if (this.error) {\n      throw this.error\n    }\n    if (parser.closed) {\n      return error(parser,\n        'Cannot write after close. Assign an onready handler.')\n    }\n    if (chunk === null) {\n      return end(parser)\n    }\n    var i = 0\n    var c = ''\n    while (true) {\n      c = chunk.charAt(i++)\n      parser.c = c\n      if (!c) {\n        break\n      }\n      if (parser.trackPosition) {\n        parser.position++\n        if (c === '\\n') {\n          parser.line++\n          parser.column = 0\n        } else {\n          parser.column++\n        }\n      }\n      switch (parser.state) {\n        case S.BEGIN:\n          parser.state = S.BEGIN_WHITESPACE\n          if (c === '\\uFEFF') {\n            continue\n          }\n          beginWhiteSpace(parser, c)\n          continue\n\n        case S.BEGIN_WHITESPACE:\n          beginWhiteSpace(parser, c)\n          continue\n\n        case S.TEXT:\n          if (parser.sawRoot && !parser.closedRoot) {\n            var starti = i - 1\n            while (c && c !== '<' && c !== '&') {\n              c = chunk.charAt(i++)\n              if (c && parser.trackPosition) {\n                parser.position++\n                if (c === '\\n') {\n                  parser.line++\n                  parser.column = 0\n                } else {\n                  parser.column++\n                }\n              }\n            }\n            parser.textNode += chunk.substring(starti, i - 1)\n          }\n          if (c === '<' && !(parser.sawRoot && parser.closedRoot && !parser.strict)) {\n            parser.state = S.OPEN_WAKA\n            parser.startTagPosition = parser.position\n          } else {\n            if (not(whitespace, c) && (!parser.sawRoot || parser.closedRoot)) {\n              strictFail(parser, 'Text data outside of root node.')\n            }\n            if (c === '&') {\n              parser.state = S.TEXT_ENTITY\n            } else {\n              parser.textNode += c\n            }\n          }\n          continue\n\n        case S.SCRIPT:\n          // only non-strict\n          if (c === '<') {\n            parser.state = S.SCRIPT_ENDING\n          } else {\n            parser.script += c\n          }\n          continue\n\n        case S.SCRIPT_ENDING:\n          if (c === '/') {\n            parser.state = S.CLOSE_TAG\n          } else {\n            parser.script += '<' + c\n            parser.state = S.SCRIPT\n          }\n          continue\n\n        case S.OPEN_WAKA:\n          // either a /, ?, !, or text is coming next.\n          if (c === '!') {\n            parser.state = S.SGML_DECL\n            parser.sgmlDecl = ''\n          } else if (is(whitespace, c)) {\n            // wait for it...\n          } else if (is(nameStart, c)) {\n            parser.state = S.OPEN_TAG\n            parser.tagName = c\n          } else if (c === '/') {\n            parser.state = S.CLOSE_TAG\n            parser.tagName = ''\n          } else if (c === '?') {\n            parser.state = S.PROC_INST\n            parser.procInstName = parser.procInstBody = ''\n          } else {\n            strictFail(parser, 'Unencoded <')\n            // if there was some whitespace, then add that in.\n            if (parser.startTagPosition + 1 < parser.position) {\n              var pad = parser.position - parser.startTagPosition\n              c = new Array(pad).join(' ') + c\n            }\n            parser.textNode += '<' + c\n            parser.state = S.TEXT\n          }\n          continue\n\n        case S.SGML_DECL:\n          if ((parser.sgmlDecl + c).toUpperCase() === CDATA) {\n            emitNode(parser, 'onopencdata')\n            parser.state = S.CDATA\n            parser.sgmlDecl = ''\n            parser.cdata = ''\n          } else if (parser.sgmlDecl + c === '--') {\n            parser.state = S.COMMENT\n            parser.comment = ''\n            parser.sgmlDecl = ''\n          } else if ((parser.sgmlDecl + c).toUpperCase() === DOCTYPE) {\n            parser.state = S.DOCTYPE\n            if (parser.doctype || parser.sawRoot) {\n              strictFail(parser,\n                'Inappropriately located doctype declaration')\n            }\n            parser.doctype = ''\n            parser.sgmlDecl = ''\n          } else if (c === '>') {\n            emitNode(parser, 'onsgmldeclaration', parser.sgmlDecl)\n            parser.sgmlDecl = ''\n            parser.state = S.TEXT\n          } else if (is(quote, c)) {\n            parser.state = S.SGML_DECL_QUOTED\n            parser.sgmlDecl += c\n          } else {\n            parser.sgmlDecl += c\n          }\n          continue\n\n        case S.SGML_DECL_QUOTED:\n          if (c === parser.q) {\n            parser.state = S.SGML_DECL\n            parser.q = ''\n          }\n          parser.sgmlDecl += c\n          continue\n\n        case S.DOCTYPE:\n          if (c === '>') {\n            parser.state = S.TEXT\n            emitNode(parser, 'ondoctype', parser.doctype)\n            parser.doctype = true // just remember that we saw it.\n          } else {\n            parser.doctype += c\n            if (c === '[') {\n              parser.state = S.DOCTYPE_DTD\n            } else if (is(quote, c)) {\n              parser.state = S.DOCTYPE_QUOTED\n              parser.q = c\n            }\n          }\n          continue\n\n        case S.DOCTYPE_QUOTED:\n          parser.doctype += c\n          if (c === parser.q) {\n            parser.q = ''\n            parser.state = S.DOCTYPE\n          }\n          continue\n\n        case S.DOCTYPE_DTD:\n          parser.doctype += c\n          if (c === ']') {\n            parser.state = S.DOCTYPE\n          } else if (is(quote, c)) {\n            parser.state = S.DOCTYPE_DTD_QUOTED\n            parser.q = c\n          }\n          continue\n\n        case S.DOCTYPE_DTD_QUOTED:\n          parser.doctype += c\n          if (c === parser.q) {\n            parser.state = S.DOCTYPE_DTD\n            parser.q = ''\n          }\n          continue\n\n        case S.COMMENT:\n          if (c === '-') {\n            parser.state = S.COMMENT_ENDING\n          } else {\n            parser.comment += c\n          }\n          continue\n\n        case S.COMMENT_ENDING:\n          if (c === '-') {\n            parser.state = S.COMMENT_ENDED\n            parser.comment = textopts(parser.opt, parser.comment)\n            if (parser.comment) {\n              emitNode(parser, 'oncomment', parser.comment)\n            }\n            parser.comment = ''\n          } else {\n            parser.comment += '-' + c\n            parser.state = S.COMMENT\n          }\n          continue\n\n        case S.COMMENT_ENDED:\n          if (c !== '>') {\n            strictFail(parser, 'Malformed comment')\n            // allow <!-- blah -- bloo --> in non-strict mode,\n            // which is a comment of \" blah -- bloo \"\n            parser.comment += '--' + c\n            parser.state = S.COMMENT\n          } else {\n            parser.state = S.TEXT\n          }\n          continue\n\n        case S.CDATA:\n          if (c === ']') {\n            parser.state = S.CDATA_ENDING\n          } else {\n            parser.cdata += c\n          }\n          continue\n\n        case S.CDATA_ENDING:\n          if (c === ']') {\n            parser.state = S.CDATA_ENDING_2\n          } else {\n            parser.cdata += ']' + c\n            parser.state = S.CDATA\n          }\n          continue\n\n        case S.CDATA_ENDING_2:\n          if (c === '>') {\n            if (parser.cdata) {\n              emitNode(parser, 'oncdata', parser.cdata)\n            }\n            emitNode(parser, 'onclosecdata')\n            parser.cdata = ''\n            parser.state = S.TEXT\n          } else if (c === ']') {\n            parser.cdata += ']'\n          } else {\n            parser.cdata += ']]' + c\n            parser.state = S.CDATA\n          }\n          continue\n\n        case S.PROC_INST:\n          if (c === '?') {\n            parser.state = S.PROC_INST_ENDING\n          } else if (is(whitespace, c)) {\n            parser.state = S.PROC_INST_BODY\n          } else {\n            parser.procInstName += c\n          }\n          continue\n\n        case S.PROC_INST_BODY:\n          if (!parser.procInstBody && is(whitespace, c)) {\n            continue\n          } else if (c === '?') {\n            parser.state = S.PROC_INST_ENDING\n          } else {\n            parser.procInstBody += c\n          }\n          continue\n\n        case S.PROC_INST_ENDING:\n          if (c === '>') {\n            emitNode(parser, 'onprocessinginstruction', {\n              name: parser.procInstName,\n              body: parser.procInstBody\n            })\n            parser.procInstName = parser.procInstBody = ''\n            parser.state = S.TEXT\n          } else {\n            parser.procInstBody += '?' + c\n            parser.state = S.PROC_INST_BODY\n          }\n          continue\n\n        case S.OPEN_TAG:\n          if (is(nameBody, c)) {\n            parser.tagName += c\n          } else {\n            newTag(parser)\n            if (c === '>') {\n              openTag(parser)\n            } else if (c === '/') {\n              parser.state = S.OPEN_TAG_SLASH\n            } else {\n              if (not(whitespace, c)) {\n                strictFail(parser, 'Invalid character in tag name')\n              }\n              parser.state = S.ATTRIB\n            }\n          }\n          continue\n\n        case S.OPEN_TAG_SLASH:\n          if (c === '>') {\n            openTag(parser, true)\n            closeTag(parser)\n          } else {\n            strictFail(parser, 'Forward-slash in opening tag not followed by >')\n            parser.state = S.ATTRIB\n          }\n          continue\n\n        case S.ATTRIB:\n          // haven't read the attribute name yet.\n          if (is(whitespace, c)) {\n            continue\n          } else if (c === '>') {\n            openTag(parser)\n          } else if (c === '/') {\n            parser.state = S.OPEN_TAG_SLASH\n          } else if (is(nameStart, c)) {\n            parser.attribName = c\n            parser.attribValue = ''\n            parser.state = S.ATTRIB_NAME\n          } else {\n            strictFail(parser, 'Invalid attribute name')\n          }\n          continue\n\n        case S.ATTRIB_NAME:\n          if (c === '=') {\n            parser.state = S.ATTRIB_VALUE\n          } else if (c === '>') {\n            strictFail(parser, 'Attribute without value')\n            parser.attribValue = parser.attribName\n            attrib(parser)\n            openTag(parser)\n          } else if (is(whitespace, c)) {\n            parser.state = S.ATTRIB_NAME_SAW_WHITE\n          } else if (is(nameBody, c)) {\n            parser.attribName += c\n          } else {\n            strictFail(parser, 'Invalid attribute name')\n          }\n          continue\n\n        case S.ATTRIB_NAME_SAW_WHITE:\n          if (c === '=') {\n            parser.state = S.ATTRIB_VALUE\n          } else if (is(whitespace, c)) {\n            continue\n          } else {\n            strictFail(parser, 'Attribute without value')\n            parser.tag.attributes[parser.attribName] = ''\n            parser.attribValue = ''\n            emitNode(parser, 'onattribute', {\n              name: parser.attribName,\n              value: ''\n            })\n            parser.attribName = ''\n            if (c === '>') {\n              openTag(parser)\n            } else if (is(nameStart, c)) {\n              parser.attribName = c\n              parser.state = S.ATTRIB_NAME\n            } else {\n              strictFail(parser, 'Invalid attribute name')\n              parser.state = S.ATTRIB\n            }\n          }\n          continue\n\n        case S.ATTRIB_VALUE:\n          if (is(whitespace, c)) {\n            continue\n          } else if (is(quote, c)) {\n            parser.q = c\n            parser.state = S.ATTRIB_VALUE_QUOTED\n          } else {\n            strictFail(parser, 'Unquoted attribute value')\n            parser.state = S.ATTRIB_VALUE_UNQUOTED\n            parser.attribValue = c\n          }\n          continue\n\n        case S.ATTRIB_VALUE_QUOTED:\n          if (c !== parser.q) {\n            if (c === '&') {\n              parser.state = S.ATTRIB_VALUE_ENTITY_Q\n            } else {\n              parser.attribValue += c\n            }\n            continue\n          }\n          attrib(parser)\n          parser.q = ''\n          parser.state = S.ATTRIB_VALUE_CLOSED\n          continue\n\n        case S.ATTRIB_VALUE_CLOSED:\n          if (is(whitespace, c)) {\n            parser.state = S.ATTRIB\n          } else if (c === '>') {\n            openTag(parser)\n          } else if (c === '/') {\n            parser.state = S.OPEN_TAG_SLASH\n          } else if (is(nameStart, c)) {\n            strictFail(parser, 'No whitespace between attributes')\n            parser.attribName = c\n            parser.attribValue = ''\n            parser.state = S.ATTRIB_NAME\n          } else {\n            strictFail(parser, 'Invalid attribute name')\n          }\n          continue\n\n        case S.ATTRIB_VALUE_UNQUOTED:\n          if (not(attribEnd, c)) {\n            if (c === '&') {\n              parser.state = S.ATTRIB_VALUE_ENTITY_U\n            } else {\n              parser.attribValue += c\n            }\n            continue\n          }\n          attrib(parser)\n          if (c === '>') {\n            openTag(parser)\n          } else {\n            parser.state = S.ATTRIB\n          }\n          continue\n\n        case S.CLOSE_TAG:\n          if (!parser.tagName) {\n            if (is(whitespace, c)) {\n              continue\n            } else if (not(nameStart, c)) {\n              if (parser.script) {\n                parser.script += '</' + c\n                parser.state = S.SCRIPT\n              } else {\n                strictFail(parser, 'Invalid tagname in closing tag.')\n              }\n            } else {\n              parser.tagName = c\n            }\n          } else if (c === '>') {\n            closeTag(parser)\n          } else if (is(nameBody, c)) {\n            parser.tagName += c\n          } else if (parser.script) {\n            parser.script += '</' + parser.tagName\n            parser.tagName = ''\n            parser.state = S.SCRIPT\n          } else {\n            if (not(whitespace, c)) {\n              strictFail(parser, 'Invalid tagname in closing tag')\n            }\n            parser.state = S.CLOSE_TAG_SAW_WHITE\n          }\n          continue\n\n        case S.CLOSE_TAG_SAW_WHITE:\n          if (is(whitespace, c)) {\n            continue\n          }\n          if (c === '>') {\n            closeTag(parser)\n          } else {\n            strictFail(parser, 'Invalid characters in closing tag')\n          }\n          continue\n\n        case S.TEXT_ENTITY:\n        case S.ATTRIB_VALUE_ENTITY_Q:\n        case S.ATTRIB_VALUE_ENTITY_U:\n          var returnState\n          var buffer\n          switch (parser.state) {\n            case S.TEXT_ENTITY:\n              returnState = S.TEXT\n              buffer = 'textNode'\n              break\n\n            case S.ATTRIB_VALUE_ENTITY_Q:\n              returnState = S.ATTRIB_VALUE_QUOTED\n              buffer = 'attribValue'\n              break\n\n            case S.ATTRIB_VALUE_ENTITY_U:\n              returnState = S.ATTRIB_VALUE_UNQUOTED\n              buffer = 'attribValue'\n              break\n          }\n\n          if (c === ';') {\n            parser[buffer] += parseEntity(parser)\n            parser.entity = ''\n            parser.state = returnState\n          } else if (is(parser.entity.length ? entityBody : entityStart, c)) {\n            parser.entity += c\n          } else {\n            strictFail(parser, 'Invalid character in entity name')\n            parser[buffer] += '&' + parser.entity + c\n            parser.entity = ''\n            parser.state = returnState\n          }\n\n          continue\n\n        default:\n          throw new Error(parser, 'Unknown state: ' + parser.state)\n      }\n    } // while\n\n    if (parser.position >= parser.bufferCheckPosition) {\n      checkBufferLength(parser)\n    }\n    return parser\n  }\n\n  /*! http://mths.be/fromcodepoint v0.1.0 by @mathias */\n  if (!String.fromCodePoint) {\n    (function () {\n      var stringFromCharCode = String.fromCharCode\n      var floor = Math.floor\n      var fromCodePoint = function () {\n        var MAX_SIZE = 0x4000\n        var codeUnits = []\n        var highSurrogate\n        var lowSurrogate\n        var index = -1\n        var length = arguments.length\n        if (!length) {\n          return ''\n        }\n        var result = ''\n        while (++index < length) {\n          var codePoint = Number(arguments[index])\n          if (\n            !isFinite(codePoint) || // `NaN`, `+Infinity`, or `-Infinity`\n            codePoint < 0 || // not a valid Unicode code point\n            codePoint > 0x10FFFF || // not a valid Unicode code point\n            floor(codePoint) !== codePoint // not an integer\n          ) {\n            throw RangeError('Invalid code point: ' + codePoint)\n          }\n          if (codePoint <= 0xFFFF) { // BMP code point\n            codeUnits.push(codePoint)\n          } else { // Astral code point; split in surrogate halves\n            // http://mathiasbynens.be/notes/javascript-encoding#surrogate-formulae\n            codePoint -= 0x10000\n            highSurrogate = (codePoint >> 10) + 0xD800\n            lowSurrogate = (codePoint % 0x400) + 0xDC00\n            codeUnits.push(highSurrogate, lowSurrogate)\n          }\n          if (index + 1 === length || codeUnits.length > MAX_SIZE) {\n            result += stringFromCharCode.apply(null, codeUnits)\n            codeUnits.length = 0\n          }\n        }\n        return result\n      }\n      if (Object.defineProperty) {\n        Object.defineProperty(String, 'fromCodePoint', {\n          value: fromCodePoint,\n          configurable: true,\n          writable: true\n        })\n      } else {\n        String.fromCodePoint = fromCodePoint\n      }\n    }())\n  }\n})(typeof exports === 'undefined' ? this.sax = {} : exports)\n"],"sourceRoot":"/source/"}